[
  {
    "model": "qwen3:30b",
    "prompt": "Your task is to generate a set of up to 10 relevant questions and answers based on the provided section of documentation. The questions should be those a junior developer or data analyst might have.\n\nFor each question, you must provide a code example as the answer. You can add comments to the code to explain the steps. A brief, one-sentence explanation may be included in a comment if the code alone is not a sufficient answer.\n\nThe questions must be directly related to the documentation section provided below and must not ask about topics outside its scope. The answer should be grounded in the documentation provided. Do not make assumptions.\n\nWrite simple and straightforward code examples. Don't create functions to encapsulate your code.\n\nYour answers should always be wrapped in triple backticks (```ts at the beginning and ``` at the end) for code blocks.\n\nIf the documentation section is about SimpleDB, make sure to wrap your answer with:\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\nconst sdb = new SimpleDB();\n[PUT THE CODE EXAMPLE HERE. IF THERE IS NO CODE TO ADD, JUST ADD A COMMENT SAYING \"Do your magic here!\"]\nawait sdb.done();\n```\n\nIf the documentation section is about SimpleTable, make sure to wrap your answer with:\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\nconst sdb = new SimpleDB();\nconst table = sdb.newTable();\nawait table.loadData(\"path/to/your/data.csv\"); // Remove this line if not needed or change the file extension if relevant\n[PUT THE CODE EXAMPLE HERE. IF THERE IS NO CODE TO ADD, JUST ADD A COMMENT SAYING \"Do your magic here!\"]\nawait sdb.done();\n```\n\nIf you need inspiration, here is a comprehensive example with comments.\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\n\n// We start a SimpleDB instance.\nconst sdb = new SimpleDB();\n\n// We create a new table\nconst fires = sdb.newTable(\"fires\");\n// We fetch the wildfires data. It's a csv.\nawait fires.loadData(\n  \"data/firesCanada2023.csv\",\n);\n\n// We summarize to count the number of fires\n// and sum up the area burnt in each province.\nawait fires.summarize({\n  values: \"hectares\",\n  categories: \"province\",\n  summaries: [\"count\", \"sum\"],\n  decimals: 0,\n});\n// We rename columns.\nawait fires.renameColumns({\n  count: \"nbFires\",\n  sum: \"burntArea\",\n});\n// We want the province with\n// the greatest burnt area first.\nawait fires.sort({ burntArea: \"desc\" });\n\n// We log the results. By default, the method\n// logs the first 10 rows, but there is 13\n// rows in our data. We also log the data types.\nawait fires.logTable({ nbRowsToLog: 13, types: true });\n\n// And we can write the data to a parquet, json or csv file.\nawait fires.writeData(\"./fires.parquet\");\n\n// We close everything.\nawait sdb.done();\n```\n\nReturn your response as a JSON object with the following structure:\n{\n  \"data\": [\n    { \"question\": \"question1\", \"answer\": \"answer1\" },\n    { \"question\": \"question2\", \"answer\": \"answer2\" },\n    ...\n  ]\n}\n\nHere's the documentation section:\n\n\n#### `getTable`\n\nRetrieves an existing SimpleTable instance from the database.\n\n##### Signature\n\n```typescript\nasync getTable(name: string): Promise<SimpleTable>;\n```\n\n##### Parameters\n\n- **`name`**: - The name of the table to retrieve.\n\n##### Returns\n\nA promise that resolves to the SimpleTable instance if found.\n\n##### Examples\n\n```ts\n// Retrieve the \"employees\" table\nconst employees = await sdb.getTable(\"employees\");\n```"
  },
  {
    "model": "qwen3:30b",
    "prompt": "Your task is to generate a set of up to 10 relevant questions and answers based on the provided section of documentation. The questions should be those a junior developer or data analyst might have.\n\nFor each question, you must provide a code example as the answer. You can add comments to the code to explain the steps. A brief, one-sentence explanation may be included in a comment if the code alone is not a sufficient answer.\n\nThe questions must be directly related to the documentation section provided below and must not ask about topics outside its scope. The answer should be grounded in the documentation provided. Do not make assumptions.\n\nWrite simple and straightforward code examples. Don't create functions to encapsulate your code.\n\nYour answers should always be wrapped in triple backticks (```ts at the beginning and ``` at the end) for code blocks.\n\nIf the documentation section is about SimpleDB, make sure to wrap your answer with:\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\nconst sdb = new SimpleDB();\n[PUT THE CODE EXAMPLE HERE. IF THERE IS NO CODE TO ADD, JUST ADD A COMMENT SAYING \"Do your magic here!\"]\nawait sdb.done();\n```\n\nIf the documentation section is about SimpleTable, make sure to wrap your answer with:\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\nconst sdb = new SimpleDB();\nconst table = sdb.newTable();\nawait table.loadData(\"path/to/your/data.csv\"); // Remove this line if not needed or change the file extension if relevant\n[PUT THE CODE EXAMPLE HERE. IF THERE IS NO CODE TO ADD, JUST ADD A COMMENT SAYING \"Do your magic here!\"]\nawait sdb.done();\n```\n\nIf you need inspiration, here is a comprehensive example with comments.\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\n\n// We start a SimpleDB instance.\nconst sdb = new SimpleDB();\n\n// We create a new table\nconst fires = sdb.newTable(\"fires\");\n// We fetch the wildfires data. It's a csv.\nawait fires.loadData(\n  \"data/firesCanada2023.csv\",\n);\n\n// We summarize to count the number of fires\n// and sum up the area burnt in each province.\nawait fires.summarize({\n  values: \"hectares\",\n  categories: \"province\",\n  summaries: [\"count\", \"sum\"],\n  decimals: 0,\n});\n// We rename columns.\nawait fires.renameColumns({\n  count: \"nbFires\",\n  sum: \"burntArea\",\n});\n// We want the province with\n// the greatest burnt area first.\nawait fires.sort({ burntArea: \"desc\" });\n\n// We log the results. By default, the method\n// logs the first 10 rows, but there is 13\n// rows in our data. We also log the data types.\nawait fires.logTable({ nbRowsToLog: 13, types: true });\n\n// And we can write the data to a parquet, json or csv file.\nawait fires.writeData(\"./fires.parquet\");\n\n// We close everything.\nawait sdb.done();\n```\n\nReturn your response as a JSON object with the following structure:\n{\n  \"data\": [\n    { \"question\": \"question1\", \"answer\": \"answer1\" },\n    { \"question\": \"question2\", \"answer\": \"answer2\" },\n    ...\n  ]\n}\n\nHere's the documentation section:\n\n\n#### `selectTables`\n\nSelects one or more tables to keep in the database, removing all others.\n\n##### Signature\n\n```typescript\nasync selectTables(tables: SimpleTable | string | (SimpleTable | string)[]): Promise<void>;\n```\n\n##### Parameters\n\n- **`tables`**: - A single table or an array of tables to select, specified by\n  name or as SimpleTable instances.\n\n##### Returns\n\nA promise that resolves when the tables have been selected.\n\n##### Examples\n\n```ts\n// Select a single table by name, removing all other tables\nawait sdb.selectTables(\"employees\");\n```\n\n```ts\n// Select multiple tables by name, removing all other tables\nawait sdb.selectTables([\"customers\", \"products\"]);\n```\n\n```ts\n// Select a single table using a SimpleTable instance\nconst employeesTable = sdb.newTable(\"employees\");\n// ... load data ...\nawait sdb.selectTables(employeesTable);\n```"
  },
  {
    "model": "qwen3:30b",
    "prompt": "Your task is to generate a set of up to 10 relevant questions and answers based on the provided section of documentation. The questions should be those a junior developer or data analyst might have.\n\nFor each question, you must provide a code example as the answer. You can add comments to the code to explain the steps. A brief, one-sentence explanation may be included in a comment if the code alone is not a sufficient answer.\n\nThe questions must be directly related to the documentation section provided below and must not ask about topics outside its scope. The answer should be grounded in the documentation provided. Do not make assumptions.\n\nWrite simple and straightforward code examples. Don't create functions to encapsulate your code.\n\nYour answers should always be wrapped in triple backticks (```ts at the beginning and ``` at the end) for code blocks.\n\nIf the documentation section is about SimpleDB, make sure to wrap your answer with:\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\nconst sdb = new SimpleDB();\n[PUT THE CODE EXAMPLE HERE. IF THERE IS NO CODE TO ADD, JUST ADD A COMMENT SAYING \"Do your magic here!\"]\nawait sdb.done();\n```\n\nIf the documentation section is about SimpleTable, make sure to wrap your answer with:\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\nconst sdb = new SimpleDB();\nconst table = sdb.newTable();\nawait table.loadData(\"path/to/your/data.csv\"); // Remove this line if not needed or change the file extension if relevant\n[PUT THE CODE EXAMPLE HERE. IF THERE IS NO CODE TO ADD, JUST ADD A COMMENT SAYING \"Do your magic here!\"]\nawait sdb.done();\n```\n\nIf you need inspiration, here is a comprehensive example with comments.\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\n\n// We start a SimpleDB instance.\nconst sdb = new SimpleDB();\n\n// We create a new table\nconst fires = sdb.newTable(\"fires\");\n// We fetch the wildfires data. It's a csv.\nawait fires.loadData(\n  \"data/firesCanada2023.csv\",\n);\n\n// We summarize to count the number of fires\n// and sum up the area burnt in each province.\nawait fires.summarize({\n  values: \"hectares\",\n  categories: \"province\",\n  summaries: [\"count\", \"sum\"],\n  decimals: 0,\n});\n// We rename columns.\nawait fires.renameColumns({\n  count: \"nbFires\",\n  sum: \"burntArea\",\n});\n// We want the province with\n// the greatest burnt area first.\nawait fires.sort({ burntArea: \"desc\" });\n\n// We log the results. By default, the method\n// logs the first 10 rows, but there is 13\n// rows in our data. We also log the data types.\nawait fires.logTable({ nbRowsToLog: 13, types: true });\n\n// And we can write the data to a parquet, json or csv file.\nawait fires.writeData(\"./fires.parquet\");\n\n// We close everything.\nawait sdb.done();\n```\n\nReturn your response as a JSON object with the following structure:\n{\n  \"data\": [\n    { \"question\": \"question1\", \"answer\": \"answer1\" },\n    { \"question\": \"question2\", \"answer\": \"answer2\" },\n    ...\n  ]\n}\n\nHere's the documentation section:\n\n\n#### `hasTable`\n\nChecks if a table exists in the database.\n\n##### Signature\n\n```typescript\nasync hasTable(table: SimpleTable | string): Promise<boolean>;\n```\n\n##### Parameters\n\n- **`table`**: - The name of the table or a SimpleTable instance.\n\n##### Returns\n\nA promise that resolves to `true` if the table exists, `false` otherwise.\n\n##### Examples\n\n```ts\n// Check if a table named \"employees\" exists\nconst exists = await sdb.hasTable(\"employees\");\nconsole.log(exists); // Output: true or false\n```\n\n```ts\n// Check if a SimpleTable instance exists in the database\nconst myTable = sdb.newTable(\"my_data\");\nconst existsInstance = await sdb.hasTable(myTable);\nconsole.log(existsInstance); // Output: true or false\n```"
  },
  {
    "model": "qwen3:30b",
    "prompt": "Your task is to generate a set of up to 10 relevant questions and answers based on the provided section of documentation. The questions should be those a junior developer or data analyst might have.\n\nFor each question, you must provide a code example as the answer. You can add comments to the code to explain the steps. A brief, one-sentence explanation may be included in a comment if the code alone is not a sufficient answer.\n\nThe questions must be directly related to the documentation section provided below and must not ask about topics outside its scope. The answer should be grounded in the documentation provided. Do not make assumptions.\n\nWrite simple and straightforward code examples. Don't create functions to encapsulate your code.\n\nYour answers should always be wrapped in triple backticks (```ts at the beginning and ``` at the end) for code blocks.\n\nIf the documentation section is about SimpleDB, make sure to wrap your answer with:\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\nconst sdb = new SimpleDB();\n[PUT THE CODE EXAMPLE HERE. IF THERE IS NO CODE TO ADD, JUST ADD A COMMENT SAYING \"Do your magic here!\"]\nawait sdb.done();\n```\n\nIf the documentation section is about SimpleTable, make sure to wrap your answer with:\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\nconst sdb = new SimpleDB();\nconst table = sdb.newTable();\nawait table.loadData(\"path/to/your/data.csv\"); // Remove this line if not needed or change the file extension if relevant\n[PUT THE CODE EXAMPLE HERE. IF THERE IS NO CODE TO ADD, JUST ADD A COMMENT SAYING \"Do your magic here!\"]\nawait sdb.done();\n```\n\nIf you need inspiration, here is a comprehensive example with comments.\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\n\n// We start a SimpleDB instance.\nconst sdb = new SimpleDB();\n\n// We create a new table\nconst fires = sdb.newTable(\"fires\");\n// We fetch the wildfires data. It's a csv.\nawait fires.loadData(\n  \"data/firesCanada2023.csv\",\n);\n\n// We summarize to count the number of fires\n// and sum up the area burnt in each province.\nawait fires.summarize({\n  values: \"hectares\",\n  categories: \"province\",\n  summaries: [\"count\", \"sum\"],\n  decimals: 0,\n});\n// We rename columns.\nawait fires.renameColumns({\n  count: \"nbFires\",\n  sum: \"burntArea\",\n});\n// We want the province with\n// the greatest burnt area first.\nawait fires.sort({ burntArea: \"desc\" });\n\n// We log the results. By default, the method\n// logs the first 10 rows, but there is 13\n// rows in our data. We also log the data types.\nawait fires.logTable({ nbRowsToLog: 13, types: true });\n\n// And we can write the data to a parquet, json or csv file.\nawait fires.writeData(\"./fires.parquet\");\n\n// We close everything.\nawait sdb.done();\n```\n\nReturn your response as a JSON object with the following structure:\n{\n  \"data\": [\n    { \"question\": \"question1\", \"answer\": \"answer1\" },\n    { \"question\": \"question2\", \"answer\": \"answer2\" },\n    ...\n  ]\n}\n\nHere's the documentation section:\n\n\n#### `getExtensions`\n\nReturns a list of installed DuckDB extensions.\n\n##### Signature\n\n```typescript\nasync getExtensions(): Promise<Record<string, string | number | boolean | Date | null>[]>;\n```\n\n##### Returns\n\nA promise that resolves to an array of objects, each representing an installed\nextension.\n\n##### Examples\n\n```ts\n// Get a list of all installed extensions\nconst extensions = await sdb.getExtensions();\nconsole.log(extensions); // Output: [{ extension_name: \"spatial\", loaded: true, ... }]\n```"
  },
  {
    "model": "qwen3:30b",
    "prompt": "Your task is to generate a set of up to 10 relevant questions and answers based on the provided section of documentation. The questions should be those a junior developer or data analyst might have.\n\nFor each question, you must provide a code example as the answer. You can add comments to the code to explain the steps. A brief, one-sentence explanation may be included in a comment if the code alone is not a sufficient answer.\n\nThe questions must be directly related to the documentation section provided below and must not ask about topics outside its scope. The answer should be grounded in the documentation provided. Do not make assumptions.\n\nWrite simple and straightforward code examples. Don't create functions to encapsulate your code.\n\nYour answers should always be wrapped in triple backticks (```ts at the beginning and ``` at the end) for code blocks.\n\nIf the documentation section is about SimpleDB, make sure to wrap your answer with:\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\nconst sdb = new SimpleDB();\n[PUT THE CODE EXAMPLE HERE. IF THERE IS NO CODE TO ADD, JUST ADD A COMMENT SAYING \"Do your magic here!\"]\nawait sdb.done();\n```\n\nIf the documentation section is about SimpleTable, make sure to wrap your answer with:\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\nconst sdb = new SimpleDB();\nconst table = sdb.newTable();\nawait table.loadData(\"path/to/your/data.csv\"); // Remove this line if not needed or change the file extension if relevant\n[PUT THE CODE EXAMPLE HERE. IF THERE IS NO CODE TO ADD, JUST ADD A COMMENT SAYING \"Do your magic here!\"]\nawait sdb.done();\n```\n\nIf you need inspiration, here is a comprehensive example with comments.\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\n\n// We start a SimpleDB instance.\nconst sdb = new SimpleDB();\n\n// We create a new table\nconst fires = sdb.newTable(\"fires\");\n// We fetch the wildfires data. It's a csv.\nawait fires.loadData(\n  \"data/firesCanada2023.csv\",\n);\n\n// We summarize to count the number of fires\n// and sum up the area burnt in each province.\nawait fires.summarize({\n  values: \"hectares\",\n  categories: \"province\",\n  summaries: [\"count\", \"sum\"],\n  decimals: 0,\n});\n// We rename columns.\nawait fires.renameColumns({\n  count: \"nbFires\",\n  sum: \"burntArea\",\n});\n// We want the province with\n// the greatest burnt area first.\nawait fires.sort({ burntArea: \"desc\" });\n\n// We log the results. By default, the method\n// logs the first 10 rows, but there is 13\n// rows in our data. We also log the data types.\nawait fires.logTable({ nbRowsToLog: 13, types: true });\n\n// And we can write the data to a parquet, json or csv file.\nawait fires.writeData(\"./fires.parquet\");\n\n// We close everything.\nawait sdb.done();\n```\n\nReturn your response as a JSON object with the following structure:\n{\n  \"data\": [\n    { \"question\": \"question1\", \"answer\": \"answer1\" },\n    { \"question\": \"question2\", \"answer\": \"answer2\" },\n    ...\n  ]\n}\n\nHere's the documentation section:\n\n\n#### `customQuery`\n\nExecutes a custom SQL query directly against the DuckDB instance.\n\nIf you want to force the returned data to match the types of the columns, you\ncan use the `types` option.\n\n##### Signature\n\n```typescript\nasync customQuery(query: string, options?: { returnDataFrom?: \"query\" | \"none\"; table?: string; types?: Record<string, string> }): Promise<Record<string, string | number | boolean | Date | null>[] | null>;\n```\n\n##### Parameters\n\n- **`query`**: - The SQL query string to execute.\n- **`options`**: - Configuration options for the query.\n- **`options.returnDataFrom`**: - Specifies whether to return data from the\n  query. Can be `\"query\"` to return data or `\"none\"` (default) to not return\n  data.\n- **`options.table`**: - The name of the table associated with the query,\n  primarily used for debugging and logging.\n- **`options.types`**: - An optional object specifying data types for the query\n  parameters.\n\n##### Returns\n\nA promise that resolves to the query result as an array of objects if\n`returnDataFrom` is `\"query\"`, otherwise `null`.\n\n##### Examples\n\n```ts\n// Execute a query without returning data\nawait sdb.customQuery(\n  \"CREATE TABLE young_employees AS SELECT * FROM employees WHERE age > 30\",\n);\n```\n\n```ts\n// Execute a query and return the results\nconst youngEmployees = await sdb.customQuery(\n  \"SELECT * FROM employees WHERE age < 30\",\n  { returnDataFrom: \"query\" },\n);\nconsole.log(youngEmployees);\n```"
  },
  {
    "model": "qwen3:30b",
    "prompt": "Your task is to generate a set of up to 10 relevant questions and answers based on the provided section of documentation. The questions should be those a junior developer or data analyst might have.\n\nFor each question, you must provide a code example as the answer. You can add comments to the code to explain the steps. A brief, one-sentence explanation may be included in a comment if the code alone is not a sufficient answer.\n\nThe questions must be directly related to the documentation section provided below and must not ask about topics outside its scope. The answer should be grounded in the documentation provided. Do not make assumptions.\n\nWrite simple and straightforward code examples. Don't create functions to encapsulate your code.\n\nYour answers should always be wrapped in triple backticks (```ts at the beginning and ``` at the end) for code blocks.\n\nIf the documentation section is about SimpleDB, make sure to wrap your answer with:\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\nconst sdb = new SimpleDB();\n[PUT THE CODE EXAMPLE HERE. IF THERE IS NO CODE TO ADD, JUST ADD A COMMENT SAYING \"Do your magic here!\"]\nawait sdb.done();\n```\n\nIf the documentation section is about SimpleTable, make sure to wrap your answer with:\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\nconst sdb = new SimpleDB();\nconst table = sdb.newTable();\nawait table.loadData(\"path/to/your/data.csv\"); // Remove this line if not needed or change the file extension if relevant\n[PUT THE CODE EXAMPLE HERE. IF THERE IS NO CODE TO ADD, JUST ADD A COMMENT SAYING \"Do your magic here!\"]\nawait sdb.done();\n```\n\nIf you need inspiration, here is a comprehensive example with comments.\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\n\n// We start a SimpleDB instance.\nconst sdb = new SimpleDB();\n\n// We create a new table\nconst fires = sdb.newTable(\"fires\");\n// We fetch the wildfires data. It's a csv.\nawait fires.loadData(\n  \"data/firesCanada2023.csv\",\n);\n\n// We summarize to count the number of fires\n// and sum up the area burnt in each province.\nawait fires.summarize({\n  values: \"hectares\",\n  categories: \"province\",\n  summaries: [\"count\", \"sum\"],\n  decimals: 0,\n});\n// We rename columns.\nawait fires.renameColumns({\n  count: \"nbFires\",\n  sum: \"burntArea\",\n});\n// We want the province with\n// the greatest burnt area first.\nawait fires.sort({ burntArea: \"desc\" });\n\n// We log the results. By default, the method\n// logs the first 10 rows, but there is 13\n// rows in our data. We also log the data types.\nawait fires.logTable({ nbRowsToLog: 13, types: true });\n\n// And we can write the data to a parquet, json or csv file.\nawait fires.writeData(\"./fires.parquet\");\n\n// We close everything.\nawait sdb.done();\n```\n\nReturn your response as a JSON object with the following structure:\n{\n  \"data\": [\n    { \"question\": \"question1\", \"answer\": \"answer1\" },\n    { \"question\": \"question2\", \"answer\": \"answer2\" },\n    ...\n  ]\n}\n\nHere's the documentation section:\n\n\n#### `loadDB`\n\nLoads a database from a specified file into the current SimpleDB instance.\nSupported file types are `.db` (DuckDB) and `.sqlite` (SQLite).\n\n##### Signature\n\n```typescript\nasync loadDB(file: string, options?: { name?: string; detach?: boolean }): Promise<void>;\n```\n\n##### Parameters\n\n- **`file`**: - The absolute path to the database file (e.g.,\n  \"./my_database.db\").\n- **`options`**: - Configuration options for loading the database.\n- **`options.name`**: - The name to assign to the loaded database within the\n  DuckDB instance. Defaults to the file name without extension.\n- **`options.detach`**: - If `true` (default), the database is detached after\n  loading its contents into memory. If `false`, the database remains attached.\n\n##### Returns\n\nA promise that resolves when the database has been loaded.\n\n##### Examples\n\n```ts\n// Load a DuckDB database file\nawait sdb.loadDB(\"./my_database.db\");\n```\n\n```ts\n// Load a SQLite database file and keep it attached\nawait sdb.loadDB(\"./my_database.sqlite\", { detach: false });\n```\n\n```ts\n// Load a database with a custom name\nawait sdb.loadDB(\"./archive.db\", { name: \"archive_db\" });\n```"
  },
  {
    "model": "qwen3:30b",
    "prompt": "Your task is to generate a set of up to 10 relevant questions and answers based on the provided section of documentation. The questions should be those a junior developer or data analyst might have.\n\nFor each question, you must provide a code example as the answer. You can add comments to the code to explain the steps. A brief, one-sentence explanation may be included in a comment if the code alone is not a sufficient answer.\n\nThe questions must be directly related to the documentation section provided below and must not ask about topics outside its scope. The answer should be grounded in the documentation provided. Do not make assumptions.\n\nWrite simple and straightforward code examples. Don't create functions to encapsulate your code.\n\nYour answers should always be wrapped in triple backticks (```ts at the beginning and ``` at the end) for code blocks.\n\nIf the documentation section is about SimpleDB, make sure to wrap your answer with:\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\nconst sdb = new SimpleDB();\n[PUT THE CODE EXAMPLE HERE. IF THERE IS NO CODE TO ADD, JUST ADD A COMMENT SAYING \"Do your magic here!\"]\nawait sdb.done();\n```\n\nIf the documentation section is about SimpleTable, make sure to wrap your answer with:\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\nconst sdb = new SimpleDB();\nconst table = sdb.newTable();\nawait table.loadData(\"path/to/your/data.csv\"); // Remove this line if not needed or change the file extension if relevant\n[PUT THE CODE EXAMPLE HERE. IF THERE IS NO CODE TO ADD, JUST ADD A COMMENT SAYING \"Do your magic here!\"]\nawait sdb.done();\n```\n\nIf you need inspiration, here is a comprehensive example with comments.\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\n\n// We start a SimpleDB instance.\nconst sdb = new SimpleDB();\n\n// We create a new table\nconst fires = sdb.newTable(\"fires\");\n// We fetch the wildfires data. It's a csv.\nawait fires.loadData(\n  \"data/firesCanada2023.csv\",\n);\n\n// We summarize to count the number of fires\n// and sum up the area burnt in each province.\nawait fires.summarize({\n  values: \"hectares\",\n  categories: \"province\",\n  summaries: [\"count\", \"sum\"],\n  decimals: 0,\n});\n// We rename columns.\nawait fires.renameColumns({\n  count: \"nbFires\",\n  sum: \"burntArea\",\n});\n// We want the province with\n// the greatest burnt area first.\nawait fires.sort({ burntArea: \"desc\" });\n\n// We log the results. By default, the method\n// logs the first 10 rows, but there is 13\n// rows in our data. We also log the data types.\nawait fires.logTable({ nbRowsToLog: 13, types: true });\n\n// And we can write the data to a parquet, json or csv file.\nawait fires.writeData(\"./fires.parquet\");\n\n// We close everything.\nawait sdb.done();\n```\n\nReturn your response as a JSON object with the following structure:\n{\n  \"data\": [\n    { \"question\": \"question1\", \"answer\": \"answer1\" },\n    { \"question\": \"question2\", \"answer\": \"answer2\" },\n    ...\n  ]\n}\n\nHere's the documentation section:\n\n\n#### `writeDB`\n\nWrites the current state of the database to a specified file. Supported output\nfile types are `.db` (DuckDB) and `.sqlite` (SQLite).\n\n##### Signature\n\n```typescript\nasync writeDB(file: string, options?: { noMetaData?: boolean }): Promise<void>;\n```\n\n##### Parameters\n\n- **`file`**: - The absolute path to the output file (e.g.,\n  \"./my_exported_database.db\").\n- **`options`**: - Configuration options for writing the database.\n- **`options.noMetaData`**: - If `true`, metadata files (projections, indexes)\n  are not created alongside the database file. Defaults to `false`.\n\n##### Returns\n\nA promise that resolves when the database has been written to the file.\n\n##### Examples\n\n```ts\n// Write the current database to a DuckDB file\nawait sdb.writeDB(\"./my_exported_database.db\");\n```\n\n```ts\n// Write the current database to a SQLite file without metadata\nawait sdb.writeDB(\"./my_exported_database.sqlite\", { noMetaData: true });\n```"
  },
  {
    "model": "qwen3:30b",
    "prompt": "Your task is to generate a set of up to 10 relevant questions and answers based on the provided section of documentation. The questions should be those a junior developer or data analyst might have.\n\nFor each question, you must provide a code example as the answer. You can add comments to the code to explain the steps. A brief, one-sentence explanation may be included in a comment if the code alone is not a sufficient answer.\n\nThe questions must be directly related to the documentation section provided below and must not ask about topics outside its scope. The answer should be grounded in the documentation provided. Do not make assumptions.\n\nWrite simple and straightforward code examples. Don't create functions to encapsulate your code.\n\nYour answers should always be wrapped in triple backticks (```ts at the beginning and ``` at the end) for code blocks.\n\nIf the documentation section is about SimpleDB, make sure to wrap your answer with:\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\nconst sdb = new SimpleDB();\n[PUT THE CODE EXAMPLE HERE. IF THERE IS NO CODE TO ADD, JUST ADD A COMMENT SAYING \"Do your magic here!\"]\nawait sdb.done();\n```\n\nIf the documentation section is about SimpleTable, make sure to wrap your answer with:\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\nconst sdb = new SimpleDB();\nconst table = sdb.newTable();\nawait table.loadData(\"path/to/your/data.csv\"); // Remove this line if not needed or change the file extension if relevant\n[PUT THE CODE EXAMPLE HERE. IF THERE IS NO CODE TO ADD, JUST ADD A COMMENT SAYING \"Do your magic here!\"]\nawait sdb.done();\n```\n\nIf you need inspiration, here is a comprehensive example with comments.\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\n\n// We start a SimpleDB instance.\nconst sdb = new SimpleDB();\n\n// We create a new table\nconst fires = sdb.newTable(\"fires\");\n// We fetch the wildfires data. It's a csv.\nawait fires.loadData(\n  \"data/firesCanada2023.csv\",\n);\n\n// We summarize to count the number of fires\n// and sum up the area burnt in each province.\nawait fires.summarize({\n  values: \"hectares\",\n  categories: \"province\",\n  summaries: [\"count\", \"sum\"],\n  decimals: 0,\n});\n// We rename columns.\nawait fires.renameColumns({\n  count: \"nbFires\",\n  sum: \"burntArea\",\n});\n// We want the province with\n// the greatest burnt area first.\nawait fires.sort({ burntArea: \"desc\" });\n\n// We log the results. By default, the method\n// logs the first 10 rows, but there is 13\n// rows in our data. We also log the data types.\nawait fires.logTable({ nbRowsToLog: 13, types: true });\n\n// And we can write the data to a parquet, json or csv file.\nawait fires.writeData(\"./fires.parquet\");\n\n// We close everything.\nawait sdb.done();\n```\n\nReturn your response as a JSON object with the following structure:\n{\n  \"data\": [\n    { \"question\": \"question1\", \"answer\": \"answer1\" },\n    { \"question\": \"question2\", \"answer\": \"answer2\" },\n    ...\n  ]\n}\n\nHere's the documentation section:\n\n\n#### `done`\n\nFrees up memory by closing the database connection and instance, and cleans up\nthe cache. If the database is file-based, it also compacts the database file to\noptimize storage.\n\n##### Signature\n\n```typescript\nasync done(): Promise<SimpleDB>;\n```\n\n##### Returns\n\nA promise that resolves to the SimpleDB instance after cleanup.\n\n##### Examples\n\n```ts\n// Close the database and clean up resources\nawait sdb.done();\n```\n\n### Examples\n\n```ts\n// Create an in-memory database instance\nconst sdb = new SimpleDB();\n// Create a new table named \"employees\"\nconst employees = sdb.newTable(\"employees\");\n// Load data from a CSV file into the \"employees\" table\nawait employees.loadData(\"./employees.csv\");\n// Log the first few rows of the \"employees\" table to the console\nawait employees.logTable();\n// Close the database connection and clean up resources\nawait sdb.done();\n```\n\n```ts\n// Create a persistent database instance, saving data to a file\n// To load an existing database, use the `loadDB` method instead\nconst sdb = new SimpleDB({ file: \"./my_database.db\" });\n// Perform database operations...\n// Close the database connection, which saves changes to the specified file\nawait sdb.done();\n```\n\n```ts\n// Create a database instance with custom options\nconst sdb = new SimpleDB({\n  debug: true, // Enable debugging output\n  nbRowsToLog: 20, // Set the number of rows to log by default\n});\n```"
  },
  {
    "model": "qwen3:30b",
    "prompt": "Your task is to generate a set of up to 10 relevant questions and answers based on the provided section of documentation. The questions should be those a junior developer or data analyst might have.\n\nFor each question, you must provide a code example as the answer. You can add comments to the code to explain the steps. A brief, one-sentence explanation may be included in a comment if the code alone is not a sufficient answer.\n\nThe questions must be directly related to the documentation section provided below and must not ask about topics outside its scope. The answer should be grounded in the documentation provided. Do not make assumptions.\n\nWrite simple and straightforward code examples. Don't create functions to encapsulate your code.\n\nYour answers should always be wrapped in triple backticks (```ts at the beginning and ``` at the end) for code blocks.\n\nIf the documentation section is about SimpleDB, make sure to wrap your answer with:\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\nconst sdb = new SimpleDB();\n[PUT THE CODE EXAMPLE HERE. IF THERE IS NO CODE TO ADD, JUST ADD A COMMENT SAYING \"Do your magic here!\"]\nawait sdb.done();\n```\n\nIf the documentation section is about SimpleTable, make sure to wrap your answer with:\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\nconst sdb = new SimpleDB();\nconst table = sdb.newTable();\nawait table.loadData(\"path/to/your/data.csv\"); // Remove this line if not needed or change the file extension if relevant\n[PUT THE CODE EXAMPLE HERE. IF THERE IS NO CODE TO ADD, JUST ADD A COMMENT SAYING \"Do your magic here!\"]\nawait sdb.done();\n```\n\nIf you need inspiration, here is a comprehensive example with comments.\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\n\n// We start a SimpleDB instance.\nconst sdb = new SimpleDB();\n\n// We create a new table\nconst fires = sdb.newTable(\"fires\");\n// We fetch the wildfires data. It's a csv.\nawait fires.loadData(\n  \"data/firesCanada2023.csv\",\n);\n\n// We summarize to count the number of fires\n// and sum up the area burnt in each province.\nawait fires.summarize({\n  values: \"hectares\",\n  categories: \"province\",\n  summaries: [\"count\", \"sum\"],\n  decimals: 0,\n});\n// We rename columns.\nawait fires.renameColumns({\n  count: \"nbFires\",\n  sum: \"burntArea\",\n});\n// We want the province with\n// the greatest burnt area first.\nawait fires.sort({ burntArea: \"desc\" });\n\n// We log the results. By default, the method\n// logs the first 10 rows, but there is 13\n// rows in our data. We also log the data types.\nawait fires.logTable({ nbRowsToLog: 13, types: true });\n\n// And we can write the data to a parquet, json or csv file.\nawait fires.writeData(\"./fires.parquet\");\n\n// We close everything.\nawait sdb.done();\n```\n\nReturn your response as a JSON object with the following structure:\n{\n  \"data\": [\n    { \"question\": \"question1\", \"answer\": \"answer1\" },\n    { \"question\": \"question2\", \"answer\": \"answer2\" },\n    ...\n  ]\n}\n\nHere's the documentation section:\n\n\n#### `renameTable`\n\nRenames the current table.\n\n##### Signature\n\n```typescript\nasync renameTable(name: string): Promise<void>;\n```\n\n##### Parameters\n\n- **`name`**: - The new name for the table.\n\n##### Returns\n\nA promise that resolves when the table has been renamed.\n\n##### Examples\n\n```ts\n// Rename the table to \"new_employees\"\nawait table.renameTable(\"new_employees\");\n```"
  },
  {
    "model": "qwen3:30b",
    "prompt": "Your task is to generate a set of up to 10 relevant questions and answers based on the provided section of documentation. The questions should be those a junior developer or data analyst might have.\n\nFor each question, you must provide a code example as the answer. You can add comments to the code to explain the steps. A brief, one-sentence explanation may be included in a comment if the code alone is not a sufficient answer.\n\nThe questions must be directly related to the documentation section provided below and must not ask about topics outside its scope. The answer should be grounded in the documentation provided. Do not make assumptions.\n\nWrite simple and straightforward code examples. Don't create functions to encapsulate your code.\n\nYour answers should always be wrapped in triple backticks (```ts at the beginning and ``` at the end) for code blocks.\n\nIf the documentation section is about SimpleDB, make sure to wrap your answer with:\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\nconst sdb = new SimpleDB();\n[PUT THE CODE EXAMPLE HERE. IF THERE IS NO CODE TO ADD, JUST ADD A COMMENT SAYING \"Do your magic here!\"]\nawait sdb.done();\n```\n\nIf the documentation section is about SimpleTable, make sure to wrap your answer with:\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\nconst sdb = new SimpleDB();\nconst table = sdb.newTable();\nawait table.loadData(\"path/to/your/data.csv\"); // Remove this line if not needed or change the file extension if relevant\n[PUT THE CODE EXAMPLE HERE. IF THERE IS NO CODE TO ADD, JUST ADD A COMMENT SAYING \"Do your magic here!\"]\nawait sdb.done();\n```\n\nIf you need inspiration, here is a comprehensive example with comments.\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\n\n// We start a SimpleDB instance.\nconst sdb = new SimpleDB();\n\n// We create a new table\nconst fires = sdb.newTable(\"fires\");\n// We fetch the wildfires data. It's a csv.\nawait fires.loadData(\n  \"data/firesCanada2023.csv\",\n);\n\n// We summarize to count the number of fires\n// and sum up the area burnt in each province.\nawait fires.summarize({\n  values: \"hectares\",\n  categories: \"province\",\n  summaries: [\"count\", \"sum\"],\n  decimals: 0,\n});\n// We rename columns.\nawait fires.renameColumns({\n  count: \"nbFires\",\n  sum: \"burntArea\",\n});\n// We want the province with\n// the greatest burnt area first.\nawait fires.sort({ burntArea: \"desc\" });\n\n// We log the results. By default, the method\n// logs the first 10 rows, but there is 13\n// rows in our data. We also log the data types.\nawait fires.logTable({ nbRowsToLog: 13, types: true });\n\n// And we can write the data to a parquet, json or csv file.\nawait fires.writeData(\"./fires.parquet\");\n\n// We close everything.\nawait sdb.done();\n```\n\nReturn your response as a JSON object with the following structure:\n{\n  \"data\": [\n    { \"question\": \"question1\", \"answer\": \"answer1\" },\n    { \"question\": \"question2\", \"answer\": \"answer2\" },\n    ...\n  ]\n}\n\nHere's the documentation section:\n\n\n#### `setTypes`\n\nSets the data types for columns in a new table. If the table already exists, it\nwill be replaced. To convert the types of an existing table, use the\n`.convert()` method instead.\n\n##### Signature\n\n```typescript\nasync setTypes(types: Record<string, \"integer\" | \"float\" | \"number\" | \"string\" | \"date\" | \"time\" | \"datetime\" | \"datetimeTz\" | \"bigint\" | \"double\" | \"varchar\" | \"timestamp\" | \"timestamp with time zone\" | \"boolean\" | \"geometry\">): Promise<void>;\n```\n\n##### Parameters\n\n- **`types`**: - An object specifying the column names and their target data\n  types (JavaScript or SQL types).\n\n##### Returns\n\nA promise that resolves when the types have been set.\n\n##### Examples\n\n```ts\n// Set types for a new table\nawait table.setTypes({\n  name: \"string\",\n  salary: \"integer\",\n  raise: \"float\",\n});\n```"
  },
  {
    "model": "qwen3:30b",
    "prompt": "Your task is to generate a set of up to 10 relevant questions and answers based on the provided section of documentation. The questions should be those a junior developer or data analyst might have.\n\nFor each question, you must provide a code example as the answer. You can add comments to the code to explain the steps. A brief, one-sentence explanation may be included in a comment if the code alone is not a sufficient answer.\n\nThe questions must be directly related to the documentation section provided below and must not ask about topics outside its scope. The answer should be grounded in the documentation provided. Do not make assumptions.\n\nWrite simple and straightforward code examples. Don't create functions to encapsulate your code.\n\nYour answers should always be wrapped in triple backticks (```ts at the beginning and ``` at the end) for code blocks.\n\nIf the documentation section is about SimpleDB, make sure to wrap your answer with:\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\nconst sdb = new SimpleDB();\n[PUT THE CODE EXAMPLE HERE. IF THERE IS NO CODE TO ADD, JUST ADD A COMMENT SAYING \"Do your magic here!\"]\nawait sdb.done();\n```\n\nIf the documentation section is about SimpleTable, make sure to wrap your answer with:\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\nconst sdb = new SimpleDB();\nconst table = sdb.newTable();\nawait table.loadData(\"path/to/your/data.csv\"); // Remove this line if not needed or change the file extension if relevant\n[PUT THE CODE EXAMPLE HERE. IF THERE IS NO CODE TO ADD, JUST ADD A COMMENT SAYING \"Do your magic here!\"]\nawait sdb.done();\n```\n\nIf you need inspiration, here is a comprehensive example with comments.\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\n\n// We start a SimpleDB instance.\nconst sdb = new SimpleDB();\n\n// We create a new table\nconst fires = sdb.newTable(\"fires\");\n// We fetch the wildfires data. It's a csv.\nawait fires.loadData(\n  \"data/firesCanada2023.csv\",\n);\n\n// We summarize to count the number of fires\n// and sum up the area burnt in each province.\nawait fires.summarize({\n  values: \"hectares\",\n  categories: \"province\",\n  summaries: [\"count\", \"sum\"],\n  decimals: 0,\n});\n// We rename columns.\nawait fires.renameColumns({\n  count: \"nbFires\",\n  sum: \"burntArea\",\n});\n// We want the province with\n// the greatest burnt area first.\nawait fires.sort({ burntArea: \"desc\" });\n\n// We log the results. By default, the method\n// logs the first 10 rows, but there is 13\n// rows in our data. We also log the data types.\nawait fires.logTable({ nbRowsToLog: 13, types: true });\n\n// And we can write the data to a parquet, json or csv file.\nawait fires.writeData(\"./fires.parquet\");\n\n// We close everything.\nawait sdb.done();\n```\n\nReturn your response as a JSON object with the following structure:\n{\n  \"data\": [\n    { \"question\": \"question1\", \"answer\": \"answer1\" },\n    { \"question\": \"question2\", \"answer\": \"answer2\" },\n    ...\n  ]\n}\n\nHere's the documentation section:\n\n\n#### `loadData`\n\nLoads data from one or more local or remote files into the table. Supported file\nformats include CSV, JSON, Parquet, and Excel.\n\n##### Signature\n\n```typescript\nasync loadData(files: string | string[], options?: { fileType?: \"csv\" | \"dsv\" | \"json\" | \"parquet\" | \"excel\"; autoDetect?: boolean; limit?: number; fileName?: boolean; unifyColumns?: boolean; columnTypes?: Record<string, string>; header?: boolean; allText?: boolean; delim?: string; skip?: number; nullPadding?: boolean; ignoreErrors?: boolean; compression?: \"none\" | \"gzip\" | \"zstd\"; encoding?: string; strict?: boolean; jsonFormat?: \"unstructured\" | \"newlineDelimited\" | \"array\"; records?: boolean; sheet?: string }): Promise<SimpleTable>;\n```\n\n##### Parameters\n\n- **`files`**: - The path(s) or URL(s) of the file(s) containing the data to be\n  loaded.\n- **`options`**: - An optional object with configuration options:\n- **`options.fileType`**: - The type of file to load (\"csv\", \"dsv\", \"json\",\n  \"parquet\", \"excel\"). Defaults to being inferred from the file extension.\n- **`options.autoDetect`**: - A boolean indicating whether to automatically\n  detect the data format. Defaults to `true`.\n- **`options.limit`**: - A number indicating the maximum number of rows to load.\n  Defaults to all rows.\n- **`options.fileName`**: - A boolean indicating whether to include the file\n  name as a new column in the loaded data. Defaults to `false`.\n- **`options.unifyColumns`**: - A boolean indicating whether to unify columns\n  across multiple files when their structures differ. Missing columns will be\n  filled with `NULL` values. Defaults to `false`.\n- **`options.columnTypes`**: - An object mapping column names to their expected\n  data types. By default, types are inferred.\n- **`options.header`**: - A boolean indicating whether the file has a header\n  row. Applicable to CSV files. Defaults to `true`.\n- **`options.allText`**: - A boolean indicating whether all columns should be\n  treated as text. Applicable to CSV files. Defaults to `false`.\n- **`options.delim`**: - The delimiter used in the file. Applicable to CSV and\n  DSV files. By default, the delimiter is inferred.\n- **`options.skip`**: - The number of lines to skip at the beginning of the\n  file. Applicable to CSV files. Defaults to `0`.\n- **`options.nullPadding`**: - If `true`, when a row has fewer columns than\n  expected, the remaining columns on the right will be padded with `NULL`\n  values. Defaults to `false`.\n- **`options.ignoreErrors`**: - If `true`, parsing errors encountered will be\n  ignored, and rows with errors will be skipped. Defaults to `false`.\n- **`options.compression`**: - The compression type of the file. Applicable to\n  CSV files. Defaults to `none`.\n- **`options.strict`**: - If `true`, an error will be thrown when encountering\n  any issues. If `false`, structurally incorrect files will be parsed\n  tentatively. Defaults to `true`.\n- **`options.encoding`**: - The encoding of the file. Applicable to CSV files.\n  Defaults to `utf-8`.\n- **`options.jsonFormat`**: - The format of JSON files (\"unstructured\",\n  \"newlineDelimited\", \"array\"). By default, the format is inferred.\n- **`options.records`**: - A boolean indicating whether each line in a\n  newline-delimited JSON file represents a record. Applicable to JSON files. By\n  default, it's inferred.\n- **`options.sheet`**: - A string indicating a specific sheet to import from an\n  Excel file. By default, the first sheet is imported.\n\n##### Returns\n\nA promise that resolves to the SimpleTable instance after the data has been\nloaded.\n\n##### Examples\n\n```ts\n// Load data from a single local CSV file\nawait table.loadData(\"./some-data.csv\");\n```\n\n```ts\n// Load data from a remote Parquet file\nawait table.loadData(\"https://some-website.com/some-data.parquet\");\n```\n\n```ts\n// Load data from multiple local JSON files\nawait table.loadData([\n  \"./some-data1.json\",\n  \"./some-data2.json\",\n  \"./some-data3.json\",\n]);\n```\n\n```ts\n// Load data from multiple remote Parquet files with column unification\nawait table.loadData([\n  \"https://some-website.com/some-data1.parquet\",\n  \"https://some-website.com/some-data2.parquet\",\n  \"https://some-website.com/some-data3.parquet\",\n], { unifyColumns: true });\n```"
  },
  {
    "model": "qwen3:30b",
    "prompt": "Your task is to generate a set of up to 10 relevant questions and answers based on the provided section of documentation. The questions should be those a junior developer or data analyst might have.\n\nFor each question, you must provide a code example as the answer. You can add comments to the code to explain the steps. A brief, one-sentence explanation may be included in a comment if the code alone is not a sufficient answer.\n\nThe questions must be directly related to the documentation section provided below and must not ask about topics outside its scope. The answer should be grounded in the documentation provided. Do not make assumptions.\n\nWrite simple and straightforward code examples. Don't create functions to encapsulate your code.\n\nYour answers should always be wrapped in triple backticks (```ts at the beginning and ``` at the end) for code blocks.\n\nIf the documentation section is about SimpleDB, make sure to wrap your answer with:\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\nconst sdb = new SimpleDB();\n[PUT THE CODE EXAMPLE HERE. IF THERE IS NO CODE TO ADD, JUST ADD A COMMENT SAYING \"Do your magic here!\"]\nawait sdb.done();\n```\n\nIf the documentation section is about SimpleTable, make sure to wrap your answer with:\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\nconst sdb = new SimpleDB();\nconst table = sdb.newTable();\nawait table.loadData(\"path/to/your/data.csv\"); // Remove this line if not needed or change the file extension if relevant\n[PUT THE CODE EXAMPLE HERE. IF THERE IS NO CODE TO ADD, JUST ADD A COMMENT SAYING \"Do your magic here!\"]\nawait sdb.done();\n```\n\nIf you need inspiration, here is a comprehensive example with comments.\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\n\n// We start a SimpleDB instance.\nconst sdb = new SimpleDB();\n\n// We create a new table\nconst fires = sdb.newTable(\"fires\");\n// We fetch the wildfires data. It's a csv.\nawait fires.loadData(\n  \"data/firesCanada2023.csv\",\n);\n\n// We summarize to count the number of fires\n// and sum up the area burnt in each province.\nawait fires.summarize({\n  values: \"hectares\",\n  categories: \"province\",\n  summaries: [\"count\", \"sum\"],\n  decimals: 0,\n});\n// We rename columns.\nawait fires.renameColumns({\n  count: \"nbFires\",\n  sum: \"burntArea\",\n});\n// We want the province with\n// the greatest burnt area first.\nawait fires.sort({ burntArea: \"desc\" });\n\n// We log the results. By default, the method\n// logs the first 10 rows, but there is 13\n// rows in our data. We also log the data types.\nawait fires.logTable({ nbRowsToLog: 13, types: true });\n\n// And we can write the data to a parquet, json or csv file.\nawait fires.writeData(\"./fires.parquet\");\n\n// We close everything.\nawait sdb.done();\n```\n\nReturn your response as a JSON object with the following structure:\n{\n  \"data\": [\n    { \"question\": \"question1\", \"answer\": \"answer1\" },\n    { \"question\": \"question2\", \"answer\": \"answer2\" },\n    ...\n  ]\n}\n\nHere's the documentation section:\n\n\n#### `loadGeoData`\n\nLoads geospatial data from an external file or URL into the table. The\ncoordinates of files or URLs ending with `.json` or `.geojson` are automatically\nflipped to `[latitude, longitude]` axis order.\n\n##### Signature\n\n```typescript\nasync loadGeoData(file: string, options?: { toWGS84?: boolean; from?: string }): Promise<SimpleTable>;\n```\n\n##### Parameters\n\n- **`file`**: - The URL or absolute path to the external file containing the\n  geospatial data.\n- **`options`**: - An optional object with configuration options:\n- **`options.toWGS84`**: - If `true`, the method will attempt to reproject the\n  data to WGS84 with `[latitude, longitude]` axis order. If the file is `.json`\n  or `.geojson`, coordinates are automatically flipped, and this option has no\n  additional effect. Defaults to `false`.\n- **`options.from`**: - An optional string specifying the original projection of\n  the data, if the method is unable to detect it automatically.\n\n##### Returns\n\nA promise that resolves to the SimpleTable instance after the geospatial data\nhas been loaded.\n\n##### Examples\n\n```ts\n// Load geospatial data from a URL\nawait table.loadGeoData(\"https://some-website.com/some-data.geojson\");\n```\n\n```ts\n// Load geospatial data from a local file\nawait table.loadGeoData(\"./some-data.geojson\");\n```\n\n```ts\n// Load geospatial data from a shapefile and reproject to WGS84\nawait table.loadGeoData(\"./some-data.shp.zip\", { toWGS84: true });\n```"
  },
  {
    "model": "qwen3:30b",
    "prompt": "Your task is to generate a set of up to 10 relevant questions and answers based on the provided section of documentation. The questions should be those a junior developer or data analyst might have.\n\nFor each question, you must provide a code example as the answer. You can add comments to the code to explain the steps. A brief, one-sentence explanation may be included in a comment if the code alone is not a sufficient answer.\n\nThe questions must be directly related to the documentation section provided below and must not ask about topics outside its scope. The answer should be grounded in the documentation provided. Do not make assumptions.\n\nWrite simple and straightforward code examples. Don't create functions to encapsulate your code.\n\nYour answers should always be wrapped in triple backticks (```ts at the beginning and ``` at the end) for code blocks.\n\nIf the documentation section is about SimpleDB, make sure to wrap your answer with:\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\nconst sdb = new SimpleDB();\n[PUT THE CODE EXAMPLE HERE. IF THERE IS NO CODE TO ADD, JUST ADD A COMMENT SAYING \"Do your magic here!\"]\nawait sdb.done();\n```\n\nIf the documentation section is about SimpleTable, make sure to wrap your answer with:\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\nconst sdb = new SimpleDB();\nconst table = sdb.newTable();\nawait table.loadData(\"path/to/your/data.csv\"); // Remove this line if not needed or change the file extension if relevant\n[PUT THE CODE EXAMPLE HERE. IF THERE IS NO CODE TO ADD, JUST ADD A COMMENT SAYING \"Do your magic here!\"]\nawait sdb.done();\n```\n\nIf you need inspiration, here is a comprehensive example with comments.\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\n\n// We start a SimpleDB instance.\nconst sdb = new SimpleDB();\n\n// We create a new table\nconst fires = sdb.newTable(\"fires\");\n// We fetch the wildfires data. It's a csv.\nawait fires.loadData(\n  \"data/firesCanada2023.csv\",\n);\n\n// We summarize to count the number of fires\n// and sum up the area burnt in each province.\nawait fires.summarize({\n  values: \"hectares\",\n  categories: \"province\",\n  summaries: [\"count\", \"sum\"],\n  decimals: 0,\n});\n// We rename columns.\nawait fires.renameColumns({\n  count: \"nbFires\",\n  sum: \"burntArea\",\n});\n// We want the province with\n// the greatest burnt area first.\nawait fires.sort({ burntArea: \"desc\" });\n\n// We log the results. By default, the method\n// logs the first 10 rows, but there is 13\n// rows in our data. We also log the data types.\nawait fires.logTable({ nbRowsToLog: 13, types: true });\n\n// And we can write the data to a parquet, json or csv file.\nawait fires.writeData(\"./fires.parquet\");\n\n// We close everything.\nawait sdb.done();\n```\n\nReturn your response as a JSON object with the following structure:\n{\n  \"data\": [\n    { \"question\": \"question1\", \"answer\": \"answer1\" },\n    { \"question\": \"question2\", \"answer\": \"answer2\" },\n    ...\n  ]\n}\n\nHere's the documentation section:\n\n\n#### `aiRowByRow`\n\nApplies a prompt to the value of each row in a specified column, storing the\nAI's response in a new column. This method automatically appends instructions to\nyour prompt; set `verbose` to `true` to see the full prompt.\n\nThis method supports Google Gemini, Vertex AI, and local models running with\nOllama. Credentials and model selection are determined by environment variables\n(`AI_KEY`, `AI_PROJECT`, `AI_LOCATION`, `AI_MODEL`) or directly via `options`,\nwith `options` taking precedence.\n\nFor Ollama, set the `OLLAMA` environment variable to `true`, ensure Ollama is\nrunning, and set `AI_MODEL` to your desired model name. You can also pass your\ninstance of Ollama to the `ollama` option.\n\nTo manage rate limits, use `batchSize` to process multiple rows per request and\n`rateLimitPerMinute` to introduce delays between requests. For higher rate\nlimits (business/professional accounts), `concurrent` allows parallel requests.\n\nThe `cache` option enables local caching of results in `.journalism-cache` (from\nthe `askAI` function in the\n[journalism library](https://github.com/nshiab/journalism)). Remember to add\n`.journalism-cache` to your `.gitignore`.\n\nIf the AI returns fewer items than expected in a batch, or if a custom `test`\nfunction fails, the `retry` option (a number greater than 0) will reattempt the\nrequest.\n\nTemperature is set to 0 for reproducibility, though consistency cannot be\nguaranteed.\n\nThis method does not support tables containing geometries.\n\n##### Signature\n\n```typescript\nasync aiRowByRow(column: string, newColumn: string, prompt: string, options?: { batchSize?: number; concurrent?: number; cache?: boolean; test?: (dataPoint: unknown) => any; retry?: number; model?: string; apiKey?: string; vertex?: boolean; project?: string; location?: string; ollama?: boolean | Ollama; verbose?: boolean; rateLimitPerMinute?: number; clean?: (response: string) => any; contextWindow?: number; thinkingBudget?: number; extraInstructions?: string }): Promise<void>;\n```\n\n##### Parameters\n\n- **`column`**: - The name of the column to be used as input for the AI prompt.\n- **`newColumn`**: - The name of the new column where the AI's response will be\n  stored.\n- **`prompt`**: - The input string to guide the AI's response.\n- **`options`**: - Configuration options for the AI request.\n- **`options.batchSize`**: - The number of rows to process in each batch.\n  Defaults to `1`.\n- **`options.concurrent`**: - The number of concurrent requests to send.\n  Defaults to `1`.\n- **`options.cache`**: - If `true`, the results will be cached locally. Defaults\n  to `false`.\n- **`options.test`**: - A function to validate the returned data point. If it\n  throws an error, the request will be retried (if `retry` is set). Defaults to\n  `undefined`.\n- **`options.retry`**: - The number of times to retry the request in case of\n  failure. Defaults to `0`.\n- **`options.rateLimitPerMinute`**: - The rate limit for AI requests in requests\n  per minute. The method will wait between requests if necessary. Defaults to\n  `undefined` (no limit).\n- **`options.model`**: - The AI model to use. Defaults to the `AI_MODEL`\n  environment variable.\n- **`options.apiKey`**: - The API key for the AI service. Defaults to the\n  `AI_KEY` environment variable.\n- **`options.vertex`**: - If `true`, uses Vertex AI. Automatically set to `true`\n  if `AI_PROJECT` and `AI_LOCATION` are set in the environment. Defaults to\n  `false`.\n- **`options.project`**: - The Google Cloud project ID for Vertex AI. Defaults\n  to the `AI_PROJECT` environment variable.\n- **`options.location`**: - The Google Cloud location for Vertex AI. Defaults to\n  the `AI_LOCATION` environment variable.\n- **`options.ollama`**: - If `true`, uses Ollama. Defaults to the `OLLAMA`\n  environment variable. If you want your Ollama instance to be used, you can\n  pass it here too.\n- **`options.verbose`**: - If `true`, logs additional debugging information,\n  including the full prompt sent to the AI. Defaults to `false`.\n- **`options.clean`**: - A function to clean the AI's response before JSON\n  parsing, testing, caching, and storing. Defaults to `undefined`.\n- **`options.contextWindow`**: - An option to specify the context window size\n  for Ollama models. By default, Ollama sets this depending on the model, which\n  can be lower than the actual maximum context window size of the model.\n- **`options.thinkingBudget`**: - Sets the reasoning token budget: 0 to disable\n  (default, though some models may reason regardless), -1 for a dynamic budget,\n  or > 0 for a fixed budget. For Ollama models, any non-zero value simply\n  enables reasoning, ignoring the specific budget amount.\n- **`options.extraInstructions`**: - Additional instructions to append to the\n  prompt, providing more context or guidance for the AI.\n\n##### Returns\n\nA promise that resolves when the AI processing is complete.\n\n##### Examples\n\n```ts\n// New table with a \"name\" column.\nawait table.loadArray([\n  { name: \"Marie\" },\n  { name: \"John\" },\n  { name: \"Alex\" },\n]);\n\n// Ask the AI to categorize names into a new \"gender\" column.\nawait table.aiRowByRow(\n  \"name\",\n  \"gender\",\n  `Guess whether it's a \"Man\" or a \"Woman\". If it could be both, return \"Neutral\".`,\n  {\n    cache: true, // Cache results locally\n    batchSize: 10, // Process 10 rows at once\n    test: (dataPoint: unknown) => { // Validate AI's response\n      if (\n        typeof dataPoint !== \"string\" ||\n        ![\"Man\", \"Woman\", \"Neutral\"].includes(dataPoint)\n      ) {\n        throw new Error(`Invalid response: ${dataPoint}`);\n      }\n    },\n    retry: 3, // Retry up to 3 times on failure\n    rateLimitPerMinute: 15, // Limit requests to 15 per minute\n    verbose: true, // Log detailed information\n  },\n);\n\n// Example results:\n// [\n//   { name: \"Marie\", gender: \"Woman\" },\n//   { name: \"John\", gender: \"Man\" },\n//   { name: \"Alex\", gender: \"Neutral\" },\n// ]\n```"
  },
  {
    "model": "qwen3:30b",
    "prompt": "Your task is to generate a set of up to 10 relevant questions and answers based on the provided section of documentation. The questions should be those a junior developer or data analyst might have.\n\nFor each question, you must provide a code example as the answer. You can add comments to the code to explain the steps. A brief, one-sentence explanation may be included in a comment if the code alone is not a sufficient answer.\n\nThe questions must be directly related to the documentation section provided below and must not ask about topics outside its scope. The answer should be grounded in the documentation provided. Do not make assumptions.\n\nWrite simple and straightforward code examples. Don't create functions to encapsulate your code.\n\nYour answers should always be wrapped in triple backticks (```ts at the beginning and ``` at the end) for code blocks.\n\nIf the documentation section is about SimpleDB, make sure to wrap your answer with:\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\nconst sdb = new SimpleDB();\n[PUT THE CODE EXAMPLE HERE. IF THERE IS NO CODE TO ADD, JUST ADD A COMMENT SAYING \"Do your magic here!\"]\nawait sdb.done();\n```\n\nIf the documentation section is about SimpleTable, make sure to wrap your answer with:\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\nconst sdb = new SimpleDB();\nconst table = sdb.newTable();\nawait table.loadData(\"path/to/your/data.csv\"); // Remove this line if not needed or change the file extension if relevant\n[PUT THE CODE EXAMPLE HERE. IF THERE IS NO CODE TO ADD, JUST ADD A COMMENT SAYING \"Do your magic here!\"]\nawait sdb.done();\n```\n\nIf you need inspiration, here is a comprehensive example with comments.\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\n\n// We start a SimpleDB instance.\nconst sdb = new SimpleDB();\n\n// We create a new table\nconst fires = sdb.newTable(\"fires\");\n// We fetch the wildfires data. It's a csv.\nawait fires.loadData(\n  \"data/firesCanada2023.csv\",\n);\n\n// We summarize to count the number of fires\n// and sum up the area burnt in each province.\nawait fires.summarize({\n  values: \"hectares\",\n  categories: \"province\",\n  summaries: [\"count\", \"sum\"],\n  decimals: 0,\n});\n// We rename columns.\nawait fires.renameColumns({\n  count: \"nbFires\",\n  sum: \"burntArea\",\n});\n// We want the province with\n// the greatest burnt area first.\nawait fires.sort({ burntArea: \"desc\" });\n\n// We log the results. By default, the method\n// logs the first 10 rows, but there is 13\n// rows in our data. We also log the data types.\nawait fires.logTable({ nbRowsToLog: 13, types: true });\n\n// And we can write the data to a parquet, json or csv file.\nawait fires.writeData(\"./fires.parquet\");\n\n// We close everything.\nawait sdb.done();\n```\n\nReturn your response as a JSON object with the following structure:\n{\n  \"data\": [\n    { \"question\": \"question1\", \"answer\": \"answer1\" },\n    { \"question\": \"question2\", \"answer\": \"answer2\" },\n    ...\n  ]\n}\n\nHere's the documentation section:\n\n\n#### `aiEmbeddings`\n\nGenerates embeddings for a specified text column and stores the results in a new\ncolumn.\n\nThis method supports Google Gemini, Vertex AI, and local models running with\nOllama. Credentials and model selection are determined by environment variables\n(`AI_KEY`, `AI_PROJECT`, `AI_LOCATION`, `AI_EMBEDDINGS_MODEL`) or directly via\n`options`, with `options` taking precedence.\n\nFor Ollama, set the `OLLAMA` environment variable to `true`, ensure Ollama is\nrunning, and set `AI_EMBEDDINGS_MODEL` to your desired model name. You can also\npass your instance of Ollama to the `ollama` option.\n\nTo manage rate limits, use `rateLimitPerMinute` to introduce delays between\nrequests. For higher rate limits (business/professional accounts), `concurrent`\nallows parallel requests.\n\nThe `cache` option enables local caching of results in `.journalism-cache` (from\nthe `getEmbedding` function in the\n[journalism library](https://github.com/nshiab/journalism)). Remember to add\n`.journalism-cache` to your `.gitignore`.\n\nIf `createIndex` is `true`, an index will be created on the new column using the\n[duckdb-vss extension](https://github.com/duckdb/duckdb-vss). This is useful for\nspeeding up the `aiVectorSimilarity` method.\n\nThis method does not support tables containing geometries.\n\n##### Signature\n\n```typescript\nasync aiEmbeddings(column: string, newColumn: string, options?: { createIndex?: boolean; concurrent?: number; cache?: boolean; model?: string; apiKey?: string; vertex?: boolean; project?: string; location?: string; ollama?: boolean | Ollama; verbose?: boolean; rateLimitPerMinute?: number; contextWindow?: number }): Promise<void>;\n```\n\n##### Parameters\n\n- **`column`**: - The name of the column to be used as input for generating\n  embeddings.\n- **`newColumn`**: - The name of the new column where the generated embeddings\n  will be stored.\n- **`options`**: - Configuration options for the AI request.\n- **`options.createIndex`**: - If `true`, an index will be created on the new\n  column. Useful for speeding up the `aiVectorSimilarity` method. Defaults to\n  `false`.\n- **`options.concurrent`**: - The number of concurrent requests to send.\n  Defaults to `1`.\n- **`options.cache`**: - If `true`, the results will be cached locally. Defaults\n  to `false`.\n- **`options.rateLimitPerMinute`**: - The rate limit for AI requests in requests\n  per minute. The method will wait between requests if necessary. Defaults to\n  `undefined` (no limit).\n- **`options.model`**: - The AI model to use. Defaults to the\n  `AI_EMBEDDINGS_MODEL` environment variable.\n- **`options.apiKey`**: - The API key for the AI service. Defaults to the\n  `AI_KEY` environment variable.\n- **`options.vertex`**: - If `true`, uses Vertex AI. Automatically set to `true`\n  if `AI_PROJECT` and `AI_LOCATION` are set in the environment. Defaults to\n  `false`.\n- **`options.project`**: - The Google Cloud project ID for Vertex AI. Defaults\n  to the `AI_PROJECT` environment variable.\n- **`options.location`**: - The Google Cloud location for Vertex AI. Defaults to\n  the `AI_LOCATION` environment variable.\n- **`options.ollama`**: - If `true`, uses Ollama. Defaults to the `OLLAMA`\n  environment variable. If you want your Ollama instance to be used, you can\n  pass it here too.\n- **`options.contextWindow`**: - An option to specify the context window size\n  for Ollama models. By default, Ollama sets this depending on the model, which\n  can be lower than the actual maximum context window size of the model.\n- **`options.verbose`**: - If `true`, logs additional debugging information.\n  Defaults to `false`.\n\n##### Returns\n\nA promise that resolves when the embeddings have been generated and stored.\n\n##### Examples\n\n```ts\n// New table with a \"food\" column.\nawait table.loadArray([\n  { food: \"pizza\" },\n  { food: \"sushi\" },\n  { food: \"burger\" },\n  { food: \"pasta\" },\n  { food: \"salad\" },\n  { food: \"tacos\" },\n]);\n\n// Generate embeddings for the \"food\" column and store them in a new \"embeddings\" column.\nawait table.aiEmbeddings(\"food\", \"embeddings\", {\n  cache: true, // Cache results locally\n  rateLimitPerMinute: 15, // Limit requests to 15 per minute\n  createIndex: true, // Create an index on the new column for faster similarity searches\n  verbose: true, // Log detailed information\n});\n```"
  },
  {
    "model": "qwen3:30b",
    "prompt": "Your task is to generate a set of up to 10 relevant questions and answers based on the provided section of documentation. The questions should be those a junior developer or data analyst might have.\n\nFor each question, you must provide a code example as the answer. You can add comments to the code to explain the steps. A brief, one-sentence explanation may be included in a comment if the code alone is not a sufficient answer.\n\nThe questions must be directly related to the documentation section provided below and must not ask about topics outside its scope. The answer should be grounded in the documentation provided. Do not make assumptions.\n\nWrite simple and straightforward code examples. Don't create functions to encapsulate your code.\n\nYour answers should always be wrapped in triple backticks (```ts at the beginning and ``` at the end) for code blocks.\n\nIf the documentation section is about SimpleDB, make sure to wrap your answer with:\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\nconst sdb = new SimpleDB();\n[PUT THE CODE EXAMPLE HERE. IF THERE IS NO CODE TO ADD, JUST ADD A COMMENT SAYING \"Do your magic here!\"]\nawait sdb.done();\n```\n\nIf the documentation section is about SimpleTable, make sure to wrap your answer with:\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\nconst sdb = new SimpleDB();\nconst table = sdb.newTable();\nawait table.loadData(\"path/to/your/data.csv\"); // Remove this line if not needed or change the file extension if relevant\n[PUT THE CODE EXAMPLE HERE. IF THERE IS NO CODE TO ADD, JUST ADD A COMMENT SAYING \"Do your magic here!\"]\nawait sdb.done();\n```\n\nIf you need inspiration, here is a comprehensive example with comments.\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\n\n// We start a SimpleDB instance.\nconst sdb = new SimpleDB();\n\n// We create a new table\nconst fires = sdb.newTable(\"fires\");\n// We fetch the wildfires data. It's a csv.\nawait fires.loadData(\n  \"data/firesCanada2023.csv\",\n);\n\n// We summarize to count the number of fires\n// and sum up the area burnt in each province.\nawait fires.summarize({\n  values: \"hectares\",\n  categories: \"province\",\n  summaries: [\"count\", \"sum\"],\n  decimals: 0,\n});\n// We rename columns.\nawait fires.renameColumns({\n  count: \"nbFires\",\n  sum: \"burntArea\",\n});\n// We want the province with\n// the greatest burnt area first.\nawait fires.sort({ burntArea: \"desc\" });\n\n// We log the results. By default, the method\n// logs the first 10 rows, but there is 13\n// rows in our data. We also log the data types.\nawait fires.logTable({ nbRowsToLog: 13, types: true });\n\n// And we can write the data to a parquet, json or csv file.\nawait fires.writeData(\"./fires.parquet\");\n\n// We close everything.\nawait sdb.done();\n```\n\nReturn your response as a JSON object with the following structure:\n{\n  \"data\": [\n    { \"question\": \"question1\", \"answer\": \"answer1\" },\n    { \"question\": \"question2\", \"answer\": \"answer2\" },\n    ...\n  ]\n}\n\nHere's the documentation section:\n\n\n#### `aiVectorSimilarity`\n\nCreates an embedding from a specified text and returns the most similar text\ncontent based on their embeddings. This method is useful for semantic search and\ntext similarity tasks, computing cosine distance and sorting results by\nsimilarity.\n\nTo create the embedding, this method supports Google Gemini, Vertex AI, and\nlocal models running with Ollama. Credentials and model selection are determined\nby environment variables (`AI_KEY`, `AI_PROJECT`, `AI_LOCATION`,\n`AI_EMBEDDINGS_MODEL`) or directly via `options`, with `options` taking\nprecedence.\n\nFor Ollama, set the `OLLAMA` environment variable to `true`, ensure Ollama is\nrunning, and set `AI_EMBEDDINGS_MODEL` to your desired model name. You can also\npass your instance of Ollama to the `ollama` option.\n\nThe `cache` option enables local caching of the specified text's embedding in\n`.journalism-cache` (from the `getEmbedding` function in the\n[journalism library](https://github.com/nshiab/journalism)). Remember to add\n`.journalism-cache` to your `.gitignore`.\n\nIf `createIndex` is `true`, an index will be created on the embeddings column\nusing the [duckdb-vss extension](https://github.com/duckdb/duckdb-vss) to speed\nup processing. If the index already exists, it will not be recreated.\n\n##### Signature\n\n```typescript\nasync aiVectorSimilarity(text: string, column: string, nbResults: number, options?: { createIndex?: boolean; outputTable?: string; cache?: boolean; model?: string; apiKey?: string; vertex?: boolean; project?: string; location?: string; ollama?: boolean | Ollama; contextWindow?: number; verbose?: boolean }): Promise<SimpleTable>;\n```\n\n##### Parameters\n\n- **`text`**: - The text for which to generate an embedding and find similar\n  content.\n- **`column`**: - The name of the column containing the embeddings to be used\n  for the similarity search.\n- **`nbResults`**: - The number of most similar results to return.\n- **`options`**: - An optional object with configuration options:\n- **`options.createIndex`**: - If `true`, an index will be created on the\n  embeddings column. Defaults to `false`.\n- **`options.outputTable`**: - The name of the output table where the results\n  will be stored. If not provided, the current table will be modified. Defaults\n  to `undefined`.\n- **`options.cache`**: - If `true`, the embedding of the input `text` will be\n  cached locally. Defaults to `false`.\n- **`options.model`**: - The AI model to use for generating the embedding.\n  Defaults to the `AI_EMBEDDINGS_MODEL` environment variable.\n- **`options.apiKey`**: - The API key for the AI service. Defaults to the\n  `AI_KEY` environment variable.\n- **`options.vertex`**: - If `true`, uses Vertex AI. Automatically set to `true`\n  if `AI_PROJECT` and `AI_LOCATION` are set in the environment. Defaults to\n  `false`.\n- **`options.project`**: - The Google Cloud project ID for Vertex AI. Defaults\n  to the `AI_PROJECT` environment variable.\n- **`options.location`**: - The Google Cloud location for Vertex AI. Defaults to\n  the `AI_LOCATION` environment variable.\n- **`options.ollama`**: - If `true`, uses Ollama. Defaults to the `OLLAMA`\n  environment variable. If you want your Ollama instance to be used, you can\n  pass it here too.\n- **`options.verbose`**: - If `true`, logs additional debugging information.\n  Defaults to `false`.\n- **`options.contextWindow`**: - An option to specify the context window size\n  for Ollama models. By default, Ollama sets this depending on the model, which\n  can be lower than the actual maximum context window size of the model.\n\n##### Returns\n\nA promise that resolves to the SimpleTable instance containing the similarity\nsearch results.\n\n##### Examples\n\n```ts\n// New table with a \"food\" column.\nawait table.loadArray([\n  { food: \"pizza\" },\n  { food: \"sushi\" },\n  { food: \"burger\" },\n  { food: \"pasta\" },\n  { food: \"salad\" },\n  { food: \"tacos\" },\n]);\n\n// Generate embeddings for the \"food\" column.\nawait table.aiEmbeddings(\"food\", \"embeddings\", { cache: true });\n\n// Find the 3 most similar foods to \"italian food\" based on embeddings.\nconst similarFoods = await table.aiVectorSimilarity(\n  \"italian food\",\n  \"embeddings\",\n  3,\n  {\n    createIndex: true, // Create an index on the embeddings column for faster searches\n    cache: true, // Cache the embedding of \"italian food\"\n  },\n);\n\n// Log the results\nawait similarFoods.logTable();\n```"
  },
  {
    "model": "qwen3:30b",
    "prompt": "Your task is to generate a set of up to 10 relevant questions and answers based on the provided section of documentation. The questions should be those a junior developer or data analyst might have.\n\nFor each question, you must provide a code example as the answer. You can add comments to the code to explain the steps. A brief, one-sentence explanation may be included in a comment if the code alone is not a sufficient answer.\n\nThe questions must be directly related to the documentation section provided below and must not ask about topics outside its scope. The answer should be grounded in the documentation provided. Do not make assumptions.\n\nWrite simple and straightforward code examples. Don't create functions to encapsulate your code.\n\nYour answers should always be wrapped in triple backticks (```ts at the beginning and ``` at the end) for code blocks.\n\nIf the documentation section is about SimpleDB, make sure to wrap your answer with:\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\nconst sdb = new SimpleDB();\n[PUT THE CODE EXAMPLE HERE. IF THERE IS NO CODE TO ADD, JUST ADD A COMMENT SAYING \"Do your magic here!\"]\nawait sdb.done();\n```\n\nIf the documentation section is about SimpleTable, make sure to wrap your answer with:\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\nconst sdb = new SimpleDB();\nconst table = sdb.newTable();\nawait table.loadData(\"path/to/your/data.csv\"); // Remove this line if not needed or change the file extension if relevant\n[PUT THE CODE EXAMPLE HERE. IF THERE IS NO CODE TO ADD, JUST ADD A COMMENT SAYING \"Do your magic here!\"]\nawait sdb.done();\n```\n\nIf you need inspiration, here is a comprehensive example with comments.\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\n\n// We start a SimpleDB instance.\nconst sdb = new SimpleDB();\n\n// We create a new table\nconst fires = sdb.newTable(\"fires\");\n// We fetch the wildfires data. It's a csv.\nawait fires.loadData(\n  \"data/firesCanada2023.csv\",\n);\n\n// We summarize to count the number of fires\n// and sum up the area burnt in each province.\nawait fires.summarize({\n  values: \"hectares\",\n  categories: \"province\",\n  summaries: [\"count\", \"sum\"],\n  decimals: 0,\n});\n// We rename columns.\nawait fires.renameColumns({\n  count: \"nbFires\",\n  sum: \"burntArea\",\n});\n// We want the province with\n// the greatest burnt area first.\nawait fires.sort({ burntArea: \"desc\" });\n\n// We log the results. By default, the method\n// logs the first 10 rows, but there is 13\n// rows in our data. We also log the data types.\nawait fires.logTable({ nbRowsToLog: 13, types: true });\n\n// And we can write the data to a parquet, json or csv file.\nawait fires.writeData(\"./fires.parquet\");\n\n// We close everything.\nawait sdb.done();\n```\n\nReturn your response as a JSON object with the following structure:\n{\n  \"data\": [\n    { \"question\": \"question1\", \"answer\": \"answer1\" },\n    { \"question\": \"question2\", \"answer\": \"answer2\" },\n    ...\n  ]\n}\n\nHere's the documentation section:\n\n\n#### `aiQuery`\n\nGenerates and executes a SQL query based on a prompt. Additional instructions,\nsuch as column types, are automatically added to your prompt. Set `verbose` to\n`true` to see the full prompt.\n\nThis method supports Google Gemini, Vertex AI, and local models running with\nOllama. Credentials and model selection are determined by environment variables\n(`AI_KEY`, `AI_PROJECT`, `AI_LOCATION`, `AI_MODEL`) or directly via `options`,\nwith `options` taking precedence.\n\nFor Ollama, set the `OLLAMA` environment variable to `true`, ensure Ollama is\nrunning, and set `AI_MODEL` to your desired model name. You can also pass your\ninstance of Ollama to the `ollama` option.\n\nTemperature is set to 0 to aim for reproducible results. For future consistency,\nit's recommended to copy the generated query and execute it manually using\n`await sdb.customQuery(query)` or to cache the query using the `cache` option.\n\nWhen `cache` is `true`, the generated query will be cached locally in\n`.journalism-cache` (from the `askAI` function in the\n[journalism library](https://github.com/nshiab/journalism)), saving resources\nand time. Remember to add `.journalism-cache` to your `.gitignore`.\n\n##### Signature\n\n```typescript\nasync aiQuery(prompt: string, options?: { cache?: boolean; model?: string; apiKey?: string; vertex?: boolean; project?: string; location?: string; ollama?: boolean | Ollama; contextWindow?: number; thinkingBudget?: number; verbose?: boolean }): Promise<void>;\n```\n\n##### Parameters\n\n- **`prompt`**: - The input string to guide the AI in generating the SQL query.\n- **`options`**: - Configuration options for the AI request.\n- **`options.cache`**: - If `true`, the generated query will be cached locally.\n  Defaults to `false`.\n- **`options.model`**: - The AI model to use. Defaults to the `AI_MODEL`\n  environment variable.\n- **`options.apiKey`**: - The API key for the AI service. Defaults to the\n  `AI_KEY` environment variable.\n- **`options.vertex`**: - If `true`, uses Vertex AI. Automatically set to `true`\n  if `AI_PROJECT` and `AI_LOCATION` are set in the environment. Defaults to\n  `false`.\n- **`options.project`**: - The Google Cloud project ID for Vertex AI. Defaults\n  to the `AI_PROJECT` environment variable.\n- **`options.location`**: - The Google Cloud location for Vertex AI. Defaults to\n  the `AI_LOCATION` environment variable.\n- **`options.ollama`**: - If `true`, uses Ollama. Defaults to the `OLLAMA`\n  environment variable. If you want your Ollama instance to be used, you can\n  pass it here too.\n- **`options.contextWindow`**: - An option to specify the context window size\n  for Ollama models. By default, Ollama sets this depending on the model, which\n  can be lower than the actual maximum context window size of the model.\n- **`options.thinkingBudget`**: - Sets the reasoning token budget: 0 to disable\n  (default, though some models may reason regardless), -1 for a dynamic budget,\n  or > 0 for a fixed budget. For Ollama models, any non-zero value simply\n  enables reasoning, ignoring the specific budget amount.\n- **`options.verbose`**: - If `true`, logs additional debugging information,\n  including the full prompt sent to the AI. Defaults to `false`.\n\n##### Returns\n\nA promise that resolves when the AI query has been executed.\n\n##### Examples\n\n```ts\n// The AI will generate a query that will be executed, and\n// the result will replace the existing table.\n// If run again, it will use the previous query from the cache.\n// Don't forget to add .journalism-cache to your .gitignore file!\nawait table.aiQuery(\n  \"Give me the average salary by department\",\n  { cache: true, verbose: true },\n);\n```"
  },
  {
    "model": "qwen3:30b",
    "prompt": "Your task is to generate a set of up to 10 relevant questions and answers based on the provided section of documentation. The questions should be those a junior developer or data analyst might have.\n\nFor each question, you must provide a code example as the answer. You can add comments to the code to explain the steps. A brief, one-sentence explanation may be included in a comment if the code alone is not a sufficient answer.\n\nThe questions must be directly related to the documentation section provided below and must not ask about topics outside its scope. The answer should be grounded in the documentation provided. Do not make assumptions.\n\nWrite simple and straightforward code examples. Don't create functions to encapsulate your code.\n\nYour answers should always be wrapped in triple backticks (```ts at the beginning and ``` at the end) for code blocks.\n\nIf the documentation section is about SimpleDB, make sure to wrap your answer with:\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\nconst sdb = new SimpleDB();\n[PUT THE CODE EXAMPLE HERE. IF THERE IS NO CODE TO ADD, JUST ADD A COMMENT SAYING \"Do your magic here!\"]\nawait sdb.done();\n```\n\nIf the documentation section is about SimpleTable, make sure to wrap your answer with:\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\nconst sdb = new SimpleDB();\nconst table = sdb.newTable();\nawait table.loadData(\"path/to/your/data.csv\"); // Remove this line if not needed or change the file extension if relevant\n[PUT THE CODE EXAMPLE HERE. IF THERE IS NO CODE TO ADD, JUST ADD A COMMENT SAYING \"Do your magic here!\"]\nawait sdb.done();\n```\n\nIf you need inspiration, here is a comprehensive example with comments.\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\n\n// We start a SimpleDB instance.\nconst sdb = new SimpleDB();\n\n// We create a new table\nconst fires = sdb.newTable(\"fires\");\n// We fetch the wildfires data. It's a csv.\nawait fires.loadData(\n  \"data/firesCanada2023.csv\",\n);\n\n// We summarize to count the number of fires\n// and sum up the area burnt in each province.\nawait fires.summarize({\n  values: \"hectares\",\n  categories: \"province\",\n  summaries: [\"count\", \"sum\"],\n  decimals: 0,\n});\n// We rename columns.\nawait fires.renameColumns({\n  count: \"nbFires\",\n  sum: \"burntArea\",\n});\n// We want the province with\n// the greatest burnt area first.\nawait fires.sort({ burntArea: \"desc\" });\n\n// We log the results. By default, the method\n// logs the first 10 rows, but there is 13\n// rows in our data. We also log the data types.\nawait fires.logTable({ nbRowsToLog: 13, types: true });\n\n// And we can write the data to a parquet, json or csv file.\nawait fires.writeData(\"./fires.parquet\");\n\n// We close everything.\nawait sdb.done();\n```\n\nReturn your response as a JSON object with the following structure:\n{\n  \"data\": [\n    { \"question\": \"question1\", \"answer\": \"answer1\" },\n    { \"question\": \"question2\", \"answer\": \"answer2\" },\n    ...\n  ]\n}\n\nHere's the documentation section:\n\n\n#### `fill`\n\nFills `NULL` values in specified columns with the last non-`NULL` value from the\npreceding row.\n\n##### Signature\n\n```typescript\nasync fill(columns: string | string[]): Promise<void>;\n```\n\n##### Parameters\n\n- **`columns`**: - The column(s) for which to fill `NULL` values.\n\n##### Returns\n\nA promise that resolves when the `NULL` values have been filled.\n\n##### Examples\n\n```ts\n// Fill NULL values in 'column1' with the previous non-NULL value\nawait table.fill(\"column1\");\n```\n\n```ts\n// Fill NULL values in multiple columns\nawait table.fill([\"columnA\", \"columnB\"]);\n```"
  },
  {
    "model": "qwen3:30b",
    "prompt": "Your task is to generate a set of up to 10 relevant questions and answers based on the provided section of documentation. The questions should be those a junior developer or data analyst might have.\n\nFor each question, you must provide a code example as the answer. You can add comments to the code to explain the steps. A brief, one-sentence explanation may be included in a comment if the code alone is not a sufficient answer.\n\nThe questions must be directly related to the documentation section provided below and must not ask about topics outside its scope. The answer should be grounded in the documentation provided. Do not make assumptions.\n\nWrite simple and straightforward code examples. Don't create functions to encapsulate your code.\n\nYour answers should always be wrapped in triple backticks (```ts at the beginning and ``` at the end) for code blocks.\n\nIf the documentation section is about SimpleDB, make sure to wrap your answer with:\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\nconst sdb = new SimpleDB();\n[PUT THE CODE EXAMPLE HERE. IF THERE IS NO CODE TO ADD, JUST ADD A COMMENT SAYING \"Do your magic here!\"]\nawait sdb.done();\n```\n\nIf the documentation section is about SimpleTable, make sure to wrap your answer with:\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\nconst sdb = new SimpleDB();\nconst table = sdb.newTable();\nawait table.loadData(\"path/to/your/data.csv\"); // Remove this line if not needed or change the file extension if relevant\n[PUT THE CODE EXAMPLE HERE. IF THERE IS NO CODE TO ADD, JUST ADD A COMMENT SAYING \"Do your magic here!\"]\nawait sdb.done();\n```\n\nIf you need inspiration, here is a comprehensive example with comments.\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\n\n// We start a SimpleDB instance.\nconst sdb = new SimpleDB();\n\n// We create a new table\nconst fires = sdb.newTable(\"fires\");\n// We fetch the wildfires data. It's a csv.\nawait fires.loadData(\n  \"data/firesCanada2023.csv\",\n);\n\n// We summarize to count the number of fires\n// and sum up the area burnt in each province.\nawait fires.summarize({\n  values: \"hectares\",\n  categories: \"province\",\n  summaries: [\"count\", \"sum\"],\n  decimals: 0,\n});\n// We rename columns.\nawait fires.renameColumns({\n  count: \"nbFires\",\n  sum: \"burntArea\",\n});\n// We want the province with\n// the greatest burnt area first.\nawait fires.sort({ burntArea: \"desc\" });\n\n// We log the results. By default, the method\n// logs the first 10 rows, but there is 13\n// rows in our data. We also log the data types.\nawait fires.logTable({ nbRowsToLog: 13, types: true });\n\n// And we can write the data to a parquet, json or csv file.\nawait fires.writeData(\"./fires.parquet\");\n\n// We close everything.\nawait sdb.done();\n```\n\nReturn your response as a JSON object with the following structure:\n{\n  \"data\": [\n    { \"question\": \"question1\", \"answer\": \"answer1\" },\n    { \"question\": \"question2\", \"answer\": \"answer2\" },\n    ...\n  ]\n}\n\nHere's the documentation section:\n\n\n#### `sort`\n\nSorts the rows of the table based on specified column(s) and order(s). If no\ncolumns are specified, all columns are sorted from left to right in ascending\norder.\n\n##### Signature\n\n```typescript\nasync sort(order?: Record<string, \"asc\" | \"desc\"> | null, options?: { lang?: Record<string, string> }): Promise<void>;\n```\n\n##### Parameters\n\n- **`order`**: - An object mapping column names to their sorting order: `\"asc\"`\n  for ascending or `\"desc\"` for descending. If `null`, all columns are sorted\n  ascendingly.\n- **`options`**: - An optional object with configuration options:\n- **`options.lang`**: - An object mapping column names to language codes for\n  collation (e.g., `{ column1: \"fr\" }`). See DuckDB Collations documentation for\n  more details: https://duckdb.org/docs/sql/expressions/collations.\n\n##### Returns\n\nA promise that resolves when the table has been sorted.\n\n##### Examples\n\n```ts\n// Sort all columns from left to right in ascending order\nawait table.sort();\n```\n\n```ts\n// Sort 'column1' in ascending order\nawait table.sort({ column1: \"asc\" });\n```\n\n```ts\n// Sort 'column1' ascendingly, then 'column2' descendingly\nawait table.sort({ column1: \"asc\", column2: \"desc\" });\n```\n\n```ts\n// Sort 'column1' considering French accents\nawait table.sort({ column1: \"asc\" }, { lang: { column1: \"fr\" } });\n```"
  },
  {
    "model": "qwen3:30b",
    "prompt": "Your task is to generate a set of up to 10 relevant questions and answers based on the provided section of documentation. The questions should be those a junior developer or data analyst might have.\n\nFor each question, you must provide a code example as the answer. You can add comments to the code to explain the steps. A brief, one-sentence explanation may be included in a comment if the code alone is not a sufficient answer.\n\nThe questions must be directly related to the documentation section provided below and must not ask about topics outside its scope. The answer should be grounded in the documentation provided. Do not make assumptions.\n\nWrite simple and straightforward code examples. Don't create functions to encapsulate your code.\n\nYour answers should always be wrapped in triple backticks (```ts at the beginning and ``` at the end) for code blocks.\n\nIf the documentation section is about SimpleDB, make sure to wrap your answer with:\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\nconst sdb = new SimpleDB();\n[PUT THE CODE EXAMPLE HERE. IF THERE IS NO CODE TO ADD, JUST ADD A COMMENT SAYING \"Do your magic here!\"]\nawait sdb.done();\n```\n\nIf the documentation section is about SimpleTable, make sure to wrap your answer with:\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\nconst sdb = new SimpleDB();\nconst table = sdb.newTable();\nawait table.loadData(\"path/to/your/data.csv\"); // Remove this line if not needed or change the file extension if relevant\n[PUT THE CODE EXAMPLE HERE. IF THERE IS NO CODE TO ADD, JUST ADD A COMMENT SAYING \"Do your magic here!\"]\nawait sdb.done();\n```\n\nIf you need inspiration, here is a comprehensive example with comments.\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\n\n// We start a SimpleDB instance.\nconst sdb = new SimpleDB();\n\n// We create a new table\nconst fires = sdb.newTable(\"fires\");\n// We fetch the wildfires data. It's a csv.\nawait fires.loadData(\n  \"data/firesCanada2023.csv\",\n);\n\n// We summarize to count the number of fires\n// and sum up the area burnt in each province.\nawait fires.summarize({\n  values: \"hectares\",\n  categories: \"province\",\n  summaries: [\"count\", \"sum\"],\n  decimals: 0,\n});\n// We rename columns.\nawait fires.renameColumns({\n  count: \"nbFires\",\n  sum: \"burntArea\",\n});\n// We want the province with\n// the greatest burnt area first.\nawait fires.sort({ burntArea: \"desc\" });\n\n// We log the results. By default, the method\n// logs the first 10 rows, but there is 13\n// rows in our data. We also log the data types.\nawait fires.logTable({ nbRowsToLog: 13, types: true });\n\n// And we can write the data to a parquet, json or csv file.\nawait fires.writeData(\"./fires.parquet\");\n\n// We close everything.\nawait sdb.done();\n```\n\nReturn your response as a JSON object with the following structure:\n{\n  \"data\": [\n    { \"question\": \"question1\", \"answer\": \"answer1\" },\n    { \"question\": \"question2\", \"answer\": \"answer2\" },\n    ...\n  ]\n}\n\nHere's the documentation section:\n\n\n#### `selectColumns`\n\nSelects specific columns in the table, removing all others.\n\n##### Signature\n\n```typescript\nasync selectColumns(columns: string | string[]): Promise<void>;\n```\n\n##### Parameters\n\n- **`columns`**: - The name or an array of names of the columns to be selected.\n\n##### Returns\n\nA promise that resolves when the columns have been selected.\n\n##### Examples\n\n```ts\n// Select only the 'firstName' and 'lastName' columns, removing all other columns.\nawait table.selectColumns([\"firstName\", \"lastName\"]);\n```\n\n```ts\n// Select only the 'productName' column.\nawait table.selectColumns(\"productName\");\n```"
  },
  {
    "model": "qwen3:30b",
    "prompt": "Your task is to generate a set of up to 10 relevant questions and answers based on the provided section of documentation. The questions should be those a junior developer or data analyst might have.\n\nFor each question, you must provide a code example as the answer. You can add comments to the code to explain the steps. A brief, one-sentence explanation may be included in a comment if the code alone is not a sufficient answer.\n\nThe questions must be directly related to the documentation section provided below and must not ask about topics outside its scope. The answer should be grounded in the documentation provided. Do not make assumptions.\n\nWrite simple and straightforward code examples. Don't create functions to encapsulate your code.\n\nYour answers should always be wrapped in triple backticks (```ts at the beginning and ``` at the end) for code blocks.\n\nIf the documentation section is about SimpleDB, make sure to wrap your answer with:\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\nconst sdb = new SimpleDB();\n[PUT THE CODE EXAMPLE HERE. IF THERE IS NO CODE TO ADD, JUST ADD A COMMENT SAYING \"Do your magic here!\"]\nawait sdb.done();\n```\n\nIf the documentation section is about SimpleTable, make sure to wrap your answer with:\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\nconst sdb = new SimpleDB();\nconst table = sdb.newTable();\nawait table.loadData(\"path/to/your/data.csv\"); // Remove this line if not needed or change the file extension if relevant\n[PUT THE CODE EXAMPLE HERE. IF THERE IS NO CODE TO ADD, JUST ADD A COMMENT SAYING \"Do your magic here!\"]\nawait sdb.done();\n```\n\nIf you need inspiration, here is a comprehensive example with comments.\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\n\n// We start a SimpleDB instance.\nconst sdb = new SimpleDB();\n\n// We create a new table\nconst fires = sdb.newTable(\"fires\");\n// We fetch the wildfires data. It's a csv.\nawait fires.loadData(\n  \"data/firesCanada2023.csv\",\n);\n\n// We summarize to count the number of fires\n// and sum up the area burnt in each province.\nawait fires.summarize({\n  values: \"hectares\",\n  categories: \"province\",\n  summaries: [\"count\", \"sum\"],\n  decimals: 0,\n});\n// We rename columns.\nawait fires.renameColumns({\n  count: \"nbFires\",\n  sum: \"burntArea\",\n});\n// We want the province with\n// the greatest burnt area first.\nawait fires.sort({ burntArea: \"desc\" });\n\n// We log the results. By default, the method\n// logs the first 10 rows, but there is 13\n// rows in our data. We also log the data types.\nawait fires.logTable({ nbRowsToLog: 13, types: true });\n\n// And we can write the data to a parquet, json or csv file.\nawait fires.writeData(\"./fires.parquet\");\n\n// We close everything.\nawait sdb.done();\n```\n\nReturn your response as a JSON object with the following structure:\n{\n  \"data\": [\n    { \"question\": \"question1\", \"answer\": \"answer1\" },\n    { \"question\": \"question2\", \"answer\": \"answer2\" },\n    ...\n  ]\n}\n\nHere's the documentation section:\n\n\n#### `hasColumn`\n\nChecks if a column with the specified name exists in the table.\n\n##### Signature\n\n```typescript\nasync hasColumn(column: string): Promise<boolean>;\n```\n\n##### Parameters\n\n- **`column`**: - The name of the column to check.\n\n##### Returns\n\nA promise that resolves to `true` if the column exists, `false` otherwise.\n\n##### Examples\n\n```ts\n// Check if the table has a column named \"age\"\nconst hasAgeColumn = await table.hasColumn(\"age\");\nconsole.log(hasAgeColumn); // Output: true or false\n```"
  },
  {
    "model": "qwen3:30b",
    "prompt": "Your task is to generate a set of up to 10 relevant questions and answers based on the provided section of documentation. The questions should be those a junior developer or data analyst might have.\n\nFor each question, you must provide a code example as the answer. You can add comments to the code to explain the steps. A brief, one-sentence explanation may be included in a comment if the code alone is not a sufficient answer.\n\nThe questions must be directly related to the documentation section provided below and must not ask about topics outside its scope. The answer should be grounded in the documentation provided. Do not make assumptions.\n\nWrite simple and straightforward code examples. Don't create functions to encapsulate your code.\n\nYour answers should always be wrapped in triple backticks (```ts at the beginning and ``` at the end) for code blocks.\n\nIf the documentation section is about SimpleDB, make sure to wrap your answer with:\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\nconst sdb = new SimpleDB();\n[PUT THE CODE EXAMPLE HERE. IF THERE IS NO CODE TO ADD, JUST ADD A COMMENT SAYING \"Do your magic here!\"]\nawait sdb.done();\n```\n\nIf the documentation section is about SimpleTable, make sure to wrap your answer with:\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\nconst sdb = new SimpleDB();\nconst table = sdb.newTable();\nawait table.loadData(\"path/to/your/data.csv\"); // Remove this line if not needed or change the file extension if relevant\n[PUT THE CODE EXAMPLE HERE. IF THERE IS NO CODE TO ADD, JUST ADD A COMMENT SAYING \"Do your magic here!\"]\nawait sdb.done();\n```\n\nIf you need inspiration, here is a comprehensive example with comments.\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\n\n// We start a SimpleDB instance.\nconst sdb = new SimpleDB();\n\n// We create a new table\nconst fires = sdb.newTable(\"fires\");\n// We fetch the wildfires data. It's a csv.\nawait fires.loadData(\n  \"data/firesCanada2023.csv\",\n);\n\n// We summarize to count the number of fires\n// and sum up the area burnt in each province.\nawait fires.summarize({\n  values: \"hectares\",\n  categories: \"province\",\n  summaries: [\"count\", \"sum\"],\n  decimals: 0,\n});\n// We rename columns.\nawait fires.renameColumns({\n  count: \"nbFires\",\n  sum: \"burntArea\",\n});\n// We want the province with\n// the greatest burnt area first.\nawait fires.sort({ burntArea: \"desc\" });\n\n// We log the results. By default, the method\n// logs the first 10 rows, but there is 13\n// rows in our data. We also log the data types.\nawait fires.logTable({ nbRowsToLog: 13, types: true });\n\n// And we can write the data to a parquet, json or csv file.\nawait fires.writeData(\"./fires.parquet\");\n\n// We close everything.\nawait sdb.done();\n```\n\nReturn your response as a JSON object with the following structure:\n{\n  \"data\": [\n    { \"question\": \"question1\", \"answer\": \"answer1\" },\n    { \"question\": \"question2\", \"answer\": \"answer2\" },\n    ...\n  ]\n}\n\nHere's the documentation section:\n\n\n#### `removeDuplicates`\n\nRemoves duplicate rows from this table, keeping only unique rows. Note that the\nresulting data order might differ from the original.\n\n##### Signature\n\n```typescript\nasync removeDuplicates(options?: { on?: string | string[] }): Promise<void>;\n```\n\n##### Parameters\n\n- **`options`**: - An optional object with configuration options:\n- **`options.on`**: - A column name or an array of column names to consider when\n  identifying duplicates. If specified, duplicates are determined based only on\n  the values in these columns. If omitted, all columns are considered.\n\n##### Returns\n\nA promise that resolves when the duplicate rows have been removed.\n\n##### Examples\n\n```ts\n// Remove duplicate rows based on all columns\nawait table.removeDuplicates();\n```\n\n```ts\n// Remove duplicate rows based only on the 'email' column\nawait table.removeDuplicates({ on: \"email\" });\n```\n\n```ts\n// Remove duplicate rows based on 'firstName' and 'lastName' columns\nawait table.removeDuplicates({ on: [\"firstName\", \"lastName\"] });\n```"
  },
  {
    "model": "qwen3:30b",
    "prompt": "Your task is to generate a set of up to 10 relevant questions and answers based on the provided section of documentation. The questions should be those a junior developer or data analyst might have.\n\nFor each question, you must provide a code example as the answer. You can add comments to the code to explain the steps. A brief, one-sentence explanation may be included in a comment if the code alone is not a sufficient answer.\n\nThe questions must be directly related to the documentation section provided below and must not ask about topics outside its scope. The answer should be grounded in the documentation provided. Do not make assumptions.\n\nWrite simple and straightforward code examples. Don't create functions to encapsulate your code.\n\nYour answers should always be wrapped in triple backticks (```ts at the beginning and ``` at the end) for code blocks.\n\nIf the documentation section is about SimpleDB, make sure to wrap your answer with:\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\nconst sdb = new SimpleDB();\n[PUT THE CODE EXAMPLE HERE. IF THERE IS NO CODE TO ADD, JUST ADD A COMMENT SAYING \"Do your magic here!\"]\nawait sdb.done();\n```\n\nIf the documentation section is about SimpleTable, make sure to wrap your answer with:\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\nconst sdb = new SimpleDB();\nconst table = sdb.newTable();\nawait table.loadData(\"path/to/your/data.csv\"); // Remove this line if not needed or change the file extension if relevant\n[PUT THE CODE EXAMPLE HERE. IF THERE IS NO CODE TO ADD, JUST ADD A COMMENT SAYING \"Do your magic here!\"]\nawait sdb.done();\n```\n\nIf you need inspiration, here is a comprehensive example with comments.\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\n\n// We start a SimpleDB instance.\nconst sdb = new SimpleDB();\n\n// We create a new table\nconst fires = sdb.newTable(\"fires\");\n// We fetch the wildfires data. It's a csv.\nawait fires.loadData(\n  \"data/firesCanada2023.csv\",\n);\n\n// We summarize to count the number of fires\n// and sum up the area burnt in each province.\nawait fires.summarize({\n  values: \"hectares\",\n  categories: \"province\",\n  summaries: [\"count\", \"sum\"],\n  decimals: 0,\n});\n// We rename columns.\nawait fires.renameColumns({\n  count: \"nbFires\",\n  sum: \"burntArea\",\n});\n// We want the province with\n// the greatest burnt area first.\nawait fires.sort({ burntArea: \"desc\" });\n\n// We log the results. By default, the method\n// logs the first 10 rows, but there is 13\n// rows in our data. We also log the data types.\nawait fires.logTable({ nbRowsToLog: 13, types: true });\n\n// And we can write the data to a parquet, json or csv file.\nawait fires.writeData(\"./fires.parquet\");\n\n// We close everything.\nawait sdb.done();\n```\n\nReturn your response as a JSON object with the following structure:\n{\n  \"data\": [\n    { \"question\": \"question1\", \"answer\": \"answer1\" },\n    { \"question\": \"question2\", \"answer\": \"answer2\" },\n    ...\n  ]\n}\n\nHere's the documentation section:\n\n\n#### `removeMissing`\n\nRemoves rows with missing values from this table. By default, missing values\ninclude SQL `NULL`, as well as string representations like `\"NULL\"`, `\"null\"`,\n`\"NaN\"`, `\"undefined\"`, and empty strings `\"\"`.\n\n##### Signature\n\n```typescript\nasync removeMissing(options?: { columns?: string | string[]; missingValues?: (string | number)[]; invert?: boolean }): Promise<void>;\n```\n\n##### Parameters\n\n- **`options`**: - An optional object with configuration options:\n- **`options.columns`**: - A string or an array of strings specifying the\n  columns to consider for missing values. If omitted, all columns are\n  considered.\n- **`options.missingValues`**: - An array of values to be treated as missing\n  values instead of the default ones. Defaults to\n  `[\"undefined\", \"NaN\", \"null\", \"NULL\", \"\"]`.\n- **`options.invert`**: - A boolean indicating whether to invert the condition.\n  If `true`, only rows containing missing values will be kept. Defaults to\n  `false`.\n\n##### Returns\n\nA promise that resolves when the rows with missing values have been removed.\n\n##### Examples\n\n```ts\n// Remove rows with missing values in any column\nawait table.removeMissing();\n```\n\n```ts\n// Remove rows with missing values only in 'firstName' or 'lastName' columns\nawait table.removeMissing({ columns: [\"firstName\", \"lastName\"] });\n```\n\n```ts\n// Keep only rows with missing values in any column\nawait table.removeMissing({ invert: true });\n```\n\n```ts\n// Remove rows where 'age' is missing or is equal to -1\nawait table.removeMissing({ columns: \"age\", missingValues: [-1] });\n```"
  },
  {
    "model": "qwen3:30b",
    "prompt": "Your task is to generate a set of up to 10 relevant questions and answers based on the provided section of documentation. The questions should be those a junior developer or data analyst might have.\n\nFor each question, you must provide a code example as the answer. You can add comments to the code to explain the steps. A brief, one-sentence explanation may be included in a comment if the code alone is not a sufficient answer.\n\nThe questions must be directly related to the documentation section provided below and must not ask about topics outside its scope. The answer should be grounded in the documentation provided. Do not make assumptions.\n\nWrite simple and straightforward code examples. Don't create functions to encapsulate your code.\n\nYour answers should always be wrapped in triple backticks (```ts at the beginning and ``` at the end) for code blocks.\n\nIf the documentation section is about SimpleDB, make sure to wrap your answer with:\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\nconst sdb = new SimpleDB();\n[PUT THE CODE EXAMPLE HERE. IF THERE IS NO CODE TO ADD, JUST ADD A COMMENT SAYING \"Do your magic here!\"]\nawait sdb.done();\n```\n\nIf the documentation section is about SimpleTable, make sure to wrap your answer with:\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\nconst sdb = new SimpleDB();\nconst table = sdb.newTable();\nawait table.loadData(\"path/to/your/data.csv\"); // Remove this line if not needed or change the file extension if relevant\n[PUT THE CODE EXAMPLE HERE. IF THERE IS NO CODE TO ADD, JUST ADD A COMMENT SAYING \"Do your magic here!\"]\nawait sdb.done();\n```\n\nIf you need inspiration, here is a comprehensive example with comments.\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\n\n// We start a SimpleDB instance.\nconst sdb = new SimpleDB();\n\n// We create a new table\nconst fires = sdb.newTable(\"fires\");\n// We fetch the wildfires data. It's a csv.\nawait fires.loadData(\n  \"data/firesCanada2023.csv\",\n);\n\n// We summarize to count the number of fires\n// and sum up the area burnt in each province.\nawait fires.summarize({\n  values: \"hectares\",\n  categories: \"province\",\n  summaries: [\"count\", \"sum\"],\n  decimals: 0,\n});\n// We rename columns.\nawait fires.renameColumns({\n  count: \"nbFires\",\n  sum: \"burntArea\",\n});\n// We want the province with\n// the greatest burnt area first.\nawait fires.sort({ burntArea: \"desc\" });\n\n// We log the results. By default, the method\n// logs the first 10 rows, but there is 13\n// rows in our data. We also log the data types.\nawait fires.logTable({ nbRowsToLog: 13, types: true });\n\n// And we can write the data to a parquet, json or csv file.\nawait fires.writeData(\"./fires.parquet\");\n\n// We close everything.\nawait sdb.done();\n```\n\nReturn your response as a JSON object with the following structure:\n{\n  \"data\": [\n    { \"question\": \"question1\", \"answer\": \"answer1\" },\n    { \"question\": \"question2\", \"answer\": \"answer2\" },\n    ...\n  ]\n}\n\nHere's the documentation section:\n\n\n#### `trim`\n\nTrims specified characters from the beginning, end, or both sides of string\nvalues in the given columns.\n\n##### Signature\n\n```typescript\nasync trim(columns: string | string[], options?: { character?: string; method?: \"leftTrim\" | \"rightTrim\" | \"trim\" }): Promise<void>;\n```\n\n##### Parameters\n\n- **`columns`**: - The column name or an array of column names to trim.\n- **`options`**: - An optional object with configuration options:\n- **`options.character`**: - The string to trim. Defaults to whitespace\n  characters.\n- **`options.method`**: - The trimming method to apply: `\"leftTrim\"` (removes\n  from the beginning), `\"rightTrim\"` (removes from the end), or `\"trim\"`\n  (removes from both sides). Defaults to `\"trim\"`.\n\n##### Returns\n\nA promise that resolves when the trimming operation is complete.\n\n##### Examples\n\n```ts\n// Trim whitespace from 'column1'\nawait table.trim(\"column1\");\n```\n\n```ts\n// Trim leading and trailing asterisks from 'productCode'\nawait table.trim(\"productCode\", { character: \"*\" });\n```\n\n```ts\n// Right-trim whitespace from 'description' and 'notes' columns\nawait table.trim([\"description\", \"notes\"], { method: \"rightTrim\" });\n```"
  },
  {
    "model": "qwen3:30b",
    "prompt": "Your task is to generate a set of up to 10 relevant questions and answers based on the provided section of documentation. The questions should be those a junior developer or data analyst might have.\n\nFor each question, you must provide a code example as the answer. You can add comments to the code to explain the steps. A brief, one-sentence explanation may be included in a comment if the code alone is not a sufficient answer.\n\nThe questions must be directly related to the documentation section provided below and must not ask about topics outside its scope. The answer should be grounded in the documentation provided. Do not make assumptions.\n\nWrite simple and straightforward code examples. Don't create functions to encapsulate your code.\n\nYour answers should always be wrapped in triple backticks (```ts at the beginning and ``` at the end) for code blocks.\n\nIf the documentation section is about SimpleDB, make sure to wrap your answer with:\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\nconst sdb = new SimpleDB();\n[PUT THE CODE EXAMPLE HERE. IF THERE IS NO CODE TO ADD, JUST ADD A COMMENT SAYING \"Do your magic here!\"]\nawait sdb.done();\n```\n\nIf the documentation section is about SimpleTable, make sure to wrap your answer with:\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\nconst sdb = new SimpleDB();\nconst table = sdb.newTable();\nawait table.loadData(\"path/to/your/data.csv\"); // Remove this line if not needed or change the file extension if relevant\n[PUT THE CODE EXAMPLE HERE. IF THERE IS NO CODE TO ADD, JUST ADD A COMMENT SAYING \"Do your magic here!\"]\nawait sdb.done();\n```\n\nIf you need inspiration, here is a comprehensive example with comments.\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\n\n// We start a SimpleDB instance.\nconst sdb = new SimpleDB();\n\n// We create a new table\nconst fires = sdb.newTable(\"fires\");\n// We fetch the wildfires data. It's a csv.\nawait fires.loadData(\n  \"data/firesCanada2023.csv\",\n);\n\n// We summarize to count the number of fires\n// and sum up the area burnt in each province.\nawait fires.summarize({\n  values: \"hectares\",\n  categories: \"province\",\n  summaries: [\"count\", \"sum\"],\n  decimals: 0,\n});\n// We rename columns.\nawait fires.renameColumns({\n  count: \"nbFires\",\n  sum: \"burntArea\",\n});\n// We want the province with\n// the greatest burnt area first.\nawait fires.sort({ burntArea: \"desc\" });\n\n// We log the results. By default, the method\n// logs the first 10 rows, but there is 13\n// rows in our data. We also log the data types.\nawait fires.logTable({ nbRowsToLog: 13, types: true });\n\n// And we can write the data to a parquet, json or csv file.\nawait fires.writeData(\"./fires.parquet\");\n\n// We close everything.\nawait sdb.done();\n```\n\nReturn your response as a JSON object with the following structure:\n{\n  \"data\": [\n    { \"question\": \"question1\", \"answer\": \"answer1\" },\n    { \"question\": \"question2\", \"answer\": \"answer2\" },\n    ...\n  ]\n}\n\nHere's the documentation section:\n\n\n#### `filter`\n\nFilters rows from this table based on SQL conditions. Note that it's often\nfaster to use the `removeRows` method for simple removals. You can also use\nJavaScript syntax for conditions (e.g., `&&`, `||`, `===`, `!==`).\n\n##### Signature\n\n```typescript\nasync filter(conditions: string): Promise<void>;\n```\n\n##### Parameters\n\n- **`conditions`**: - The filtering conditions specified as a SQL `WHERE` clause\n  (e.g., `\"column1 > 10 AND column2 = 'value'\"`).\n\n##### Returns\n\nA promise that resolves when the rows have been filtered.\n\n##### Examples\n\n```ts\n// Keep only rows where the 'fruit' column is not 'apple'\nawait table.filter(`fruit != 'apple'`);\n```\n\n```ts\n// Keep rows where 'price' is greater than 100 AND 'quantity' is greater than 0\nawait table.filter(`price > 100 && quantity > 0`); // Using JS syntax\n```\n\n```ts\n// Keep rows where 'category' is 'Electronics' OR 'Appliances'\nawait table.filter(`category === 'Electronics' || category === 'Appliances'`); // Using JS syntax\n```\n\n```ts\n// Keep rows where 'lastPurchaseDate' is on or after '2023-01-01'\nawait table.filter(`lastPurchaseDate >= '2023-01-01'`);\n```"
  },
  {
    "model": "qwen3:30b",
    "prompt": "Your task is to generate a set of up to 10 relevant questions and answers based on the provided section of documentation. The questions should be those a junior developer or data analyst might have.\n\nFor each question, you must provide a code example as the answer. You can add comments to the code to explain the steps. A brief, one-sentence explanation may be included in a comment if the code alone is not a sufficient answer.\n\nThe questions must be directly related to the documentation section provided below and must not ask about topics outside its scope. The answer should be grounded in the documentation provided. Do not make assumptions.\n\nWrite simple and straightforward code examples. Don't create functions to encapsulate your code.\n\nYour answers should always be wrapped in triple backticks (```ts at the beginning and ``` at the end) for code blocks.\n\nIf the documentation section is about SimpleDB, make sure to wrap your answer with:\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\nconst sdb = new SimpleDB();\n[PUT THE CODE EXAMPLE HERE. IF THERE IS NO CODE TO ADD, JUST ADD A COMMENT SAYING \"Do your magic here!\"]\nawait sdb.done();\n```\n\nIf the documentation section is about SimpleTable, make sure to wrap your answer with:\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\nconst sdb = new SimpleDB();\nconst table = sdb.newTable();\nawait table.loadData(\"path/to/your/data.csv\"); // Remove this line if not needed or change the file extension if relevant\n[PUT THE CODE EXAMPLE HERE. IF THERE IS NO CODE TO ADD, JUST ADD A COMMENT SAYING \"Do your magic here!\"]\nawait sdb.done();\n```\n\nIf you need inspiration, here is a comprehensive example with comments.\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\n\n// We start a SimpleDB instance.\nconst sdb = new SimpleDB();\n\n// We create a new table\nconst fires = sdb.newTable(\"fires\");\n// We fetch the wildfires data. It's a csv.\nawait fires.loadData(\n  \"data/firesCanada2023.csv\",\n);\n\n// We summarize to count the number of fires\n// and sum up the area burnt in each province.\nawait fires.summarize({\n  values: \"hectares\",\n  categories: \"province\",\n  summaries: [\"count\", \"sum\"],\n  decimals: 0,\n});\n// We rename columns.\nawait fires.renameColumns({\n  count: \"nbFires\",\n  sum: \"burntArea\",\n});\n// We want the province with\n// the greatest burnt area first.\nawait fires.sort({ burntArea: \"desc\" });\n\n// We log the results. By default, the method\n// logs the first 10 rows, but there is 13\n// rows in our data. We also log the data types.\nawait fires.logTable({ nbRowsToLog: 13, types: true });\n\n// And we can write the data to a parquet, json or csv file.\nawait fires.writeData(\"./fires.parquet\");\n\n// We close everything.\nawait sdb.done();\n```\n\nReturn your response as a JSON object with the following structure:\n{\n  \"data\": [\n    { \"question\": \"question1\", \"answer\": \"answer1\" },\n    { \"question\": \"question2\", \"answer\": \"answer2\" },\n    ...\n  ]\n}\n\nHere's the documentation section:\n\n\n#### `remove`\n\nRemoves rows from this table that have specific values in specified columns.\n\n##### Signature\n\n```typescript\nasync remove(columnsAndValues: Record<string, (number | string | Date | boolean | null)[] | (number | string | Date | boolean | null)>): Promise<void>;\n```\n\n##### Parameters\n\n- **`columnsAndValues`**: - An object where keys are column names and values are\n  the specific values (or an array of values) to remove from those columns.\n\n##### Returns\n\nA promise that resolves when the rows have been removed.\n\n##### Examples\n\n```ts\n// Remove rows where 'job' is 'accountant' or 'developer', AND 'city' is 'Montreal'\nawait table.remove({ job: [\"accountant\", \"developer\"], city: \"Montreal\" });\n```\n\n```ts\n// Remove rows where 'status' is 'inactive'\nawait table.remove({ status: \"inactive\" });\n```"
  },
  {
    "model": "qwen3:30b",
    "prompt": "Your task is to generate a set of up to 10 relevant questions and answers based on the provided section of documentation. The questions should be those a junior developer or data analyst might have.\n\nFor each question, you must provide a code example as the answer. You can add comments to the code to explain the steps. A brief, one-sentence explanation may be included in a comment if the code alone is not a sufficient answer.\n\nThe questions must be directly related to the documentation section provided below and must not ask about topics outside its scope. The answer should be grounded in the documentation provided. Do not make assumptions.\n\nWrite simple and straightforward code examples. Don't create functions to encapsulate your code.\n\nYour answers should always be wrapped in triple backticks (```ts at the beginning and ``` at the end) for code blocks.\n\nIf the documentation section is about SimpleDB, make sure to wrap your answer with:\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\nconst sdb = new SimpleDB();\n[PUT THE CODE EXAMPLE HERE. IF THERE IS NO CODE TO ADD, JUST ADD A COMMENT SAYING \"Do your magic here!\"]\nawait sdb.done();\n```\n\nIf the documentation section is about SimpleTable, make sure to wrap your answer with:\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\nconst sdb = new SimpleDB();\nconst table = sdb.newTable();\nawait table.loadData(\"path/to/your/data.csv\"); // Remove this line if not needed or change the file extension if relevant\n[PUT THE CODE EXAMPLE HERE. IF THERE IS NO CODE TO ADD, JUST ADD A COMMENT SAYING \"Do your magic here!\"]\nawait sdb.done();\n```\n\nIf you need inspiration, here is a comprehensive example with comments.\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\n\n// We start a SimpleDB instance.\nconst sdb = new SimpleDB();\n\n// We create a new table\nconst fires = sdb.newTable(\"fires\");\n// We fetch the wildfires data. It's a csv.\nawait fires.loadData(\n  \"data/firesCanada2023.csv\",\n);\n\n// We summarize to count the number of fires\n// and sum up the area burnt in each province.\nawait fires.summarize({\n  values: \"hectares\",\n  categories: \"province\",\n  summaries: [\"count\", \"sum\"],\n  decimals: 0,\n});\n// We rename columns.\nawait fires.renameColumns({\n  count: \"nbFires\",\n  sum: \"burntArea\",\n});\n// We want the province with\n// the greatest burnt area first.\nawait fires.sort({ burntArea: \"desc\" });\n\n// We log the results. By default, the method\n// logs the first 10 rows, but there is 13\n// rows in our data. We also log the data types.\nawait fires.logTable({ nbRowsToLog: 13, types: true });\n\n// And we can write the data to a parquet, json or csv file.\nawait fires.writeData(\"./fires.parquet\");\n\n// We close everything.\nawait sdb.done();\n```\n\nReturn your response as a JSON object with the following structure:\n{\n  \"data\": [\n    { \"question\": \"question1\", \"answer\": \"answer1\" },\n    { \"question\": \"question2\", \"answer\": \"answer2\" },\n    ...\n  ]\n}\n\nHere's the documentation section:\n\n\n#### `removeRows`\n\nRemoves rows from this table based on SQL conditions. This method is similar to\n`filter()`, but removes rows instead of keeping them. You can also use\nJavaScript syntax for conditions (e.g., `&&`, `||`, `===`, `!==`).\n\n##### Signature\n\n```typescript\nasync removeRows(conditions: string): Promise<void>;\n```\n\n##### Parameters\n\n- **`conditions`**: - The filtering conditions specified as a SQL `WHERE` clause\n  (e.g., `\"fruit = 'apple'\"`).\n\n##### Returns\n\nA promise that resolves when the rows have been removed.\n\n##### Examples\n\n```ts\n// Remove rows where the 'fruit' column is 'apple'\nawait table.removeRows(`fruit = 'apple'`);\n```\n\n```ts\n// Remove rows where 'quantity' is less than 5\nawait table.removeRows(`quantity < 5`);\n```\n\n```ts\n// Remove rows where 'price' is less than 100 AND 'quantity' is 0\nawait table.removeRows(`price < 100 && quantity === 0`); // Using JS syntax\n```\n\n```ts\n// Remove rows where 'category' is 'Electronics' OR 'Appliances'\nawait table.removeRows(\n  `category === 'Electronics' || category === 'Appliances'`,\n); // Using JS syntax\n```"
  },
  {
    "model": "qwen3:30b",
    "prompt": "Your task is to generate a set of up to 10 relevant questions and answers based on the provided section of documentation. The questions should be those a junior developer or data analyst might have.\n\nFor each question, you must provide a code example as the answer. You can add comments to the code to explain the steps. A brief, one-sentence explanation may be included in a comment if the code alone is not a sufficient answer.\n\nThe questions must be directly related to the documentation section provided below and must not ask about topics outside its scope. The answer should be grounded in the documentation provided. Do not make assumptions.\n\nWrite simple and straightforward code examples. Don't create functions to encapsulate your code.\n\nYour answers should always be wrapped in triple backticks (```ts at the beginning and ``` at the end) for code blocks.\n\nIf the documentation section is about SimpleDB, make sure to wrap your answer with:\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\nconst sdb = new SimpleDB();\n[PUT THE CODE EXAMPLE HERE. IF THERE IS NO CODE TO ADD, JUST ADD A COMMENT SAYING \"Do your magic here!\"]\nawait sdb.done();\n```\n\nIf the documentation section is about SimpleTable, make sure to wrap your answer with:\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\nconst sdb = new SimpleDB();\nconst table = sdb.newTable();\nawait table.loadData(\"path/to/your/data.csv\"); // Remove this line if not needed or change the file extension if relevant\n[PUT THE CODE EXAMPLE HERE. IF THERE IS NO CODE TO ADD, JUST ADD A COMMENT SAYING \"Do your magic here!\"]\nawait sdb.done();\n```\n\nIf you need inspiration, here is a comprehensive example with comments.\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\n\n// We start a SimpleDB instance.\nconst sdb = new SimpleDB();\n\n// We create a new table\nconst fires = sdb.newTable(\"fires\");\n// We fetch the wildfires data. It's a csv.\nawait fires.loadData(\n  \"data/firesCanada2023.csv\",\n);\n\n// We summarize to count the number of fires\n// and sum up the area burnt in each province.\nawait fires.summarize({\n  values: \"hectares\",\n  categories: \"province\",\n  summaries: [\"count\", \"sum\"],\n  decimals: 0,\n});\n// We rename columns.\nawait fires.renameColumns({\n  count: \"nbFires\",\n  sum: \"burntArea\",\n});\n// We want the province with\n// the greatest burnt area first.\nawait fires.sort({ burntArea: \"desc\" });\n\n// We log the results. By default, the method\n// logs the first 10 rows, but there is 13\n// rows in our data. We also log the data types.\nawait fires.logTable({ nbRowsToLog: 13, types: true });\n\n// And we can write the data to a parquet, json or csv file.\nawait fires.writeData(\"./fires.parquet\");\n\n// We close everything.\nawait sdb.done();\n```\n\nReturn your response as a JSON object with the following structure:\n{\n  \"data\": [\n    { \"question\": \"question1\", \"answer\": \"answer1\" },\n    { \"question\": \"question2\", \"answer\": \"answer2\" },\n    ...\n  ]\n}\n\nHere's the documentation section:\n\n\n#### `renameColumns`\n\nRenames one or more columns in the table.\n\n##### Signature\n\n```typescript\nasync renameColumns(names: Record<string, string>): Promise<void>;\n```\n\n##### Parameters\n\n- **`names`**: - An object mapping old column names to their new column names\n  (e.g., `{ \"oldName\": \"newName\", \"anotherOld\": \"anotherNew\" }`).\n\n##### Returns\n\nA promise that resolves when the columns have been renamed.\n\n##### Examples\n\n```ts\n// Rename \"How old?\" to \"age\" and \"Man or woman?\" to \"sex\"\nawait table.renameColumns({ \"How old?\": \"age\", \"Man or woman?\": \"sex\" });\n```\n\n```ts\n// Rename a single column\nawait table.renameColumns({ \"product_id\": \"productId\" });\n```"
  },
  {
    "model": "qwen3:30b",
    "prompt": "Your task is to generate a set of up to 10 relevant questions and answers based on the provided section of documentation. The questions should be those a junior developer or data analyst might have.\n\nFor each question, you must provide a code example as the answer. You can add comments to the code to explain the steps. A brief, one-sentence explanation may be included in a comment if the code alone is not a sufficient answer.\n\nThe questions must be directly related to the documentation section provided below and must not ask about topics outside its scope. The answer should be grounded in the documentation provided. Do not make assumptions.\n\nWrite simple and straightforward code examples. Don't create functions to encapsulate your code.\n\nYour answers should always be wrapped in triple backticks (```ts at the beginning and ``` at the end) for code blocks.\n\nIf the documentation section is about SimpleDB, make sure to wrap your answer with:\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\nconst sdb = new SimpleDB();\n[PUT THE CODE EXAMPLE HERE. IF THERE IS NO CODE TO ADD, JUST ADD A COMMENT SAYING \"Do your magic here!\"]\nawait sdb.done();\n```\n\nIf the documentation section is about SimpleTable, make sure to wrap your answer with:\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\nconst sdb = new SimpleDB();\nconst table = sdb.newTable();\nawait table.loadData(\"path/to/your/data.csv\"); // Remove this line if not needed or change the file extension if relevant\n[PUT THE CODE EXAMPLE HERE. IF THERE IS NO CODE TO ADD, JUST ADD A COMMENT SAYING \"Do your magic here!\"]\nawait sdb.done();\n```\n\nIf you need inspiration, here is a comprehensive example with comments.\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\n\n// We start a SimpleDB instance.\nconst sdb = new SimpleDB();\n\n// We create a new table\nconst fires = sdb.newTable(\"fires\");\n// We fetch the wildfires data. It's a csv.\nawait fires.loadData(\n  \"data/firesCanada2023.csv\",\n);\n\n// We summarize to count the number of fires\n// and sum up the area burnt in each province.\nawait fires.summarize({\n  values: \"hectares\",\n  categories: \"province\",\n  summaries: [\"count\", \"sum\"],\n  decimals: 0,\n});\n// We rename columns.\nawait fires.renameColumns({\n  count: \"nbFires\",\n  sum: \"burntArea\",\n});\n// We want the province with\n// the greatest burnt area first.\nawait fires.sort({ burntArea: \"desc\" });\n\n// We log the results. By default, the method\n// logs the first 10 rows, but there is 13\n// rows in our data. We also log the data types.\nawait fires.logTable({ nbRowsToLog: 13, types: true });\n\n// And we can write the data to a parquet, json or csv file.\nawait fires.writeData(\"./fires.parquet\");\n\n// We close everything.\nawait sdb.done();\n```\n\nReturn your response as a JSON object with the following structure:\n{\n  \"data\": [\n    { \"question\": \"question1\", \"answer\": \"answer1\" },\n    { \"question\": \"question2\", \"answer\": \"answer2\" },\n    ...\n  ]\n}\n\nHere's the documentation section:\n\n\n#### `cleanColumnNames`\n\nCleans column names by removing non-alphanumeric characters and formatting them\nto camel case.\n\n##### Signature\n\n```typescript\nasync cleanColumnNames(): Promise<void>;\n```\n\n##### Returns\n\nA promise that resolves when the column names have been cleaned.\n\n##### Examples\n\n```ts\n// Clean all column names in the table\n// e.g., \"First Name\" becomes \"firstName\", \"Product ID\" becomes \"productId\"\nawait table.cleanColumnNames();\n```"
  },
  {
    "model": "qwen3:30b",
    "prompt": "Your task is to generate a set of up to 10 relevant questions and answers based on the provided section of documentation. The questions should be those a junior developer or data analyst might have.\n\nFor each question, you must provide a code example as the answer. You can add comments to the code to explain the steps. A brief, one-sentence explanation may be included in a comment if the code alone is not a sufficient answer.\n\nThe questions must be directly related to the documentation section provided below and must not ask about topics outside its scope. The answer should be grounded in the documentation provided. Do not make assumptions.\n\nWrite simple and straightforward code examples. Don't create functions to encapsulate your code.\n\nYour answers should always be wrapped in triple backticks (```ts at the beginning and ``` at the end) for code blocks.\n\nIf the documentation section is about SimpleDB, make sure to wrap your answer with:\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\nconst sdb = new SimpleDB();\n[PUT THE CODE EXAMPLE HERE. IF THERE IS NO CODE TO ADD, JUST ADD A COMMENT SAYING \"Do your magic here!\"]\nawait sdb.done();\n```\n\nIf the documentation section is about SimpleTable, make sure to wrap your answer with:\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\nconst sdb = new SimpleDB();\nconst table = sdb.newTable();\nawait table.loadData(\"path/to/your/data.csv\"); // Remove this line if not needed or change the file extension if relevant\n[PUT THE CODE EXAMPLE HERE. IF THERE IS NO CODE TO ADD, JUST ADD A COMMENT SAYING \"Do your magic here!\"]\nawait sdb.done();\n```\n\nIf you need inspiration, here is a comprehensive example with comments.\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\n\n// We start a SimpleDB instance.\nconst sdb = new SimpleDB();\n\n// We create a new table\nconst fires = sdb.newTable(\"fires\");\n// We fetch the wildfires data. It's a csv.\nawait fires.loadData(\n  \"data/firesCanada2023.csv\",\n);\n\n// We summarize to count the number of fires\n// and sum up the area burnt in each province.\nawait fires.summarize({\n  values: \"hectares\",\n  categories: \"province\",\n  summaries: [\"count\", \"sum\"],\n  decimals: 0,\n});\n// We rename columns.\nawait fires.renameColumns({\n  count: \"nbFires\",\n  sum: \"burntArea\",\n});\n// We want the province with\n// the greatest burnt area first.\nawait fires.sort({ burntArea: \"desc\" });\n\n// We log the results. By default, the method\n// logs the first 10 rows, but there is 13\n// rows in our data. We also log the data types.\nawait fires.logTable({ nbRowsToLog: 13, types: true });\n\n// And we can write the data to a parquet, json or csv file.\nawait fires.writeData(\"./fires.parquet\");\n\n// We close everything.\nawait sdb.done();\n```\n\nReturn your response as a JSON object with the following structure:\n{\n  \"data\": [\n    { \"question\": \"question1\", \"answer\": \"answer1\" },\n    { \"question\": \"question2\", \"answer\": \"answer2\" },\n    ...\n  ]\n}\n\nHere's the documentation section:\n\n\n#### `longer`\n\nRestructures this table by stacking (unpivoting) columns. This is useful for\ntidying up data from a wide format to a long format.\n\nFor example, given a table showing employee counts per department per year:\n\n| Department | 2021 | 2022 | 2023 |\n| :--------- | :--- | :--- | :--- |\n| Accounting | 10   | 9    | 15   |\n| Sales      | 52   | 75   | 98   |\n\nWe can restructure it by putting all year columns into a new column named `Year`\nand their corresponding employee counts into a new column named `Employees`.\n\n##### Signature\n\n```typescript\nasync longer(columns: string[], columnsTo: string, valuesTo: string): Promise<void>;\n```\n\n##### Parameters\n\n- **`columns`**: - An array of strings representing the names of the columns to\n  be stacked (unpivoted).\n- **`columnsTo`**: - The name of the new column that will contain the original\n  column names (e.g., \"Year\").\n- **`valuesTo`**: - The name of the new column that will contain the values from\n  the stacked columns (e.g., \"Employees\").\n\n##### Returns\n\nA promise that resolves when the table has been restructured.\n\n##### Examples\n\n```ts\n// Restructure the table by stacking year columns into 'year' and 'employees'\nawait table.longer([\"2021\", \"2022\", \"2023\"], \"year\", \"employees\");\n```\n\nThe table will then look like this:\n\n| Department | Year | Employees |\n| :--------- | :--- | :-------- |\n| Accounting | 2021 | 10        |\n| Accounting | 2022 | 9         |\n| Accounting | 2023 | 15        |\n| Sales      | 2021 | 52        |\n| Sales      | 2022 | 75        |\n| Sales      | 2023 | 98        |"
  },
  {
    "model": "qwen3:30b",
    "prompt": "Your task is to generate a set of up to 10 relevant questions and answers based on the provided section of documentation. The questions should be those a junior developer or data analyst might have.\n\nFor each question, you must provide a code example as the answer. You can add comments to the code to explain the steps. A brief, one-sentence explanation may be included in a comment if the code alone is not a sufficient answer.\n\nThe questions must be directly related to the documentation section provided below and must not ask about topics outside its scope. The answer should be grounded in the documentation provided. Do not make assumptions.\n\nWrite simple and straightforward code examples. Don't create functions to encapsulate your code.\n\nYour answers should always be wrapped in triple backticks (```ts at the beginning and ``` at the end) for code blocks.\n\nIf the documentation section is about SimpleDB, make sure to wrap your answer with:\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\nconst sdb = new SimpleDB();\n[PUT THE CODE EXAMPLE HERE. IF THERE IS NO CODE TO ADD, JUST ADD A COMMENT SAYING \"Do your magic here!\"]\nawait sdb.done();\n```\n\nIf the documentation section is about SimpleTable, make sure to wrap your answer with:\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\nconst sdb = new SimpleDB();\nconst table = sdb.newTable();\nawait table.loadData(\"path/to/your/data.csv\"); // Remove this line if not needed or change the file extension if relevant\n[PUT THE CODE EXAMPLE HERE. IF THERE IS NO CODE TO ADD, JUST ADD A COMMENT SAYING \"Do your magic here!\"]\nawait sdb.done();\n```\n\nIf you need inspiration, here is a comprehensive example with comments.\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\n\n// We start a SimpleDB instance.\nconst sdb = new SimpleDB();\n\n// We create a new table\nconst fires = sdb.newTable(\"fires\");\n// We fetch the wildfires data. It's a csv.\nawait fires.loadData(\n  \"data/firesCanada2023.csv\",\n);\n\n// We summarize to count the number of fires\n// and sum up the area burnt in each province.\nawait fires.summarize({\n  values: \"hectares\",\n  categories: \"province\",\n  summaries: [\"count\", \"sum\"],\n  decimals: 0,\n});\n// We rename columns.\nawait fires.renameColumns({\n  count: \"nbFires\",\n  sum: \"burntArea\",\n});\n// We want the province with\n// the greatest burnt area first.\nawait fires.sort({ burntArea: \"desc\" });\n\n// We log the results. By default, the method\n// logs the first 10 rows, but there is 13\n// rows in our data. We also log the data types.\nawait fires.logTable({ nbRowsToLog: 13, types: true });\n\n// And we can write the data to a parquet, json or csv file.\nawait fires.writeData(\"./fires.parquet\");\n\n// We close everything.\nawait sdb.done();\n```\n\nReturn your response as a JSON object with the following structure:\n{\n  \"data\": [\n    { \"question\": \"question1\", \"answer\": \"answer1\" },\n    { \"question\": \"question2\", \"answer\": \"answer2\" },\n    ...\n  ]\n}\n\nHere's the documentation section:\n\n\n#### `wider`\n\nRestructures this table by unstacking (pivoting) values, transforming data from\na long format to a wide format.\n\nFor example, given a table showing employee counts per department per year:\n\n| Department | Year | Employees |\n| :--------- | :--- | :-------- |\n| Accounting | 2021 | 10        |\n| Accounting | 2022 | 9         |\n| Accounting | 2023 | 15        |\n| Sales      | 2021 | 52        |\n| Sales      | 2022 | 75        |\n| Sales      | 2023 | 98        |\n\nWe can restructure it by creating new columns for each year, with the associated\nemployee counts as values.\n\n##### Signature\n\n```typescript\nasync wider(columnsFrom: string, valuesFrom: string): Promise<void>;\n```\n\n##### Parameters\n\n- **`columnsFrom`**: - The name of the column containing the values that will be\n  transformed into new column headers (e.g., \"Year\").\n- **`valuesFrom`**: - The name of the column containing the values to be spread\n  across the new columns (e.g., \"Employees\").\n\n##### Returns\n\nA promise that resolves when the table has been restructured.\n\n##### Examples\n\n```ts\n// Restructure the table by pivoting 'Year' into new columns with 'Employees' as values\nawait table.wider(\"Year\", \"Employees\");\n```\n\nThe table will then look like this:\n\n| Department | 2021 | 2022 | 2023 |\n| :--------- | :--- | :--- | :--- |\n| Accounting | 10   | 9    | 15   |\n| Sales      | 52   | 75   | 98   |"
  },
  {
    "model": "qwen3:30b",
    "prompt": "Your task is to generate a set of up to 10 relevant questions and answers based on the provided section of documentation. The questions should be those a junior developer or data analyst might have.\n\nFor each question, you must provide a code example as the answer. You can add comments to the code to explain the steps. A brief, one-sentence explanation may be included in a comment if the code alone is not a sufficient answer.\n\nThe questions must be directly related to the documentation section provided below and must not ask about topics outside its scope. The answer should be grounded in the documentation provided. Do not make assumptions.\n\nWrite simple and straightforward code examples. Don't create functions to encapsulate your code.\n\nYour answers should always be wrapped in triple backticks (```ts at the beginning and ``` at the end) for code blocks.\n\nIf the documentation section is about SimpleDB, make sure to wrap your answer with:\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\nconst sdb = new SimpleDB();\n[PUT THE CODE EXAMPLE HERE. IF THERE IS NO CODE TO ADD, JUST ADD A COMMENT SAYING \"Do your magic here!\"]\nawait sdb.done();\n```\n\nIf the documentation section is about SimpleTable, make sure to wrap your answer with:\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\nconst sdb = new SimpleDB();\nconst table = sdb.newTable();\nawait table.loadData(\"path/to/your/data.csv\"); // Remove this line if not needed or change the file extension if relevant\n[PUT THE CODE EXAMPLE HERE. IF THERE IS NO CODE TO ADD, JUST ADD A COMMENT SAYING \"Do your magic here!\"]\nawait sdb.done();\n```\n\nIf you need inspiration, here is a comprehensive example with comments.\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\n\n// We start a SimpleDB instance.\nconst sdb = new SimpleDB();\n\n// We create a new table\nconst fires = sdb.newTable(\"fires\");\n// We fetch the wildfires data. It's a csv.\nawait fires.loadData(\n  \"data/firesCanada2023.csv\",\n);\n\n// We summarize to count the number of fires\n// and sum up the area burnt in each province.\nawait fires.summarize({\n  values: \"hectares\",\n  categories: \"province\",\n  summaries: [\"count\", \"sum\"],\n  decimals: 0,\n});\n// We rename columns.\nawait fires.renameColumns({\n  count: \"nbFires\",\n  sum: \"burntArea\",\n});\n// We want the province with\n// the greatest burnt area first.\nawait fires.sort({ burntArea: \"desc\" });\n\n// We log the results. By default, the method\n// logs the first 10 rows, but there is 13\n// rows in our data. We also log the data types.\nawait fires.logTable({ nbRowsToLog: 13, types: true });\n\n// And we can write the data to a parquet, json or csv file.\nawait fires.writeData(\"./fires.parquet\");\n\n// We close everything.\nawait sdb.done();\n```\n\nReturn your response as a JSON object with the following structure:\n{\n  \"data\": [\n    { \"question\": \"question1\", \"answer\": \"answer1\" },\n    { \"question\": \"question2\", \"answer\": \"answer2\" },\n    ...\n  ]\n}\n\nHere's the documentation section:\n\n\n#### `removeTable`\n\nRemoves the table from the database. After this operation, invoking methods on\nthis SimpleTable instance will result in an error.\n\n##### Signature\n\n```typescript\nasync removeTable(): Promise<void>;\n```\n\n##### Returns\n\nA promise that resolves when the table has been removed.\n\n##### Examples\n\n```ts\n// Remove the current table from the database\nawait table.removeTable();\n```"
  },
  {
    "model": "qwen3:30b",
    "prompt": "Your task is to generate a set of up to 10 relevant questions and answers based on the provided section of documentation. The questions should be those a junior developer or data analyst might have.\n\nFor each question, you must provide a code example as the answer. You can add comments to the code to explain the steps. A brief, one-sentence explanation may be included in a comment if the code alone is not a sufficient answer.\n\nThe questions must be directly related to the documentation section provided below and must not ask about topics outside its scope. The answer should be grounded in the documentation provided. Do not make assumptions.\n\nWrite simple and straightforward code examples. Don't create functions to encapsulate your code.\n\nYour answers should always be wrapped in triple backticks (```ts at the beginning and ``` at the end) for code blocks.\n\nIf the documentation section is about SimpleDB, make sure to wrap your answer with:\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\nconst sdb = new SimpleDB();\n[PUT THE CODE EXAMPLE HERE. IF THERE IS NO CODE TO ADD, JUST ADD A COMMENT SAYING \"Do your magic here!\"]\nawait sdb.done();\n```\n\nIf the documentation section is about SimpleTable, make sure to wrap your answer with:\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\nconst sdb = new SimpleDB();\nconst table = sdb.newTable();\nawait table.loadData(\"path/to/your/data.csv\"); // Remove this line if not needed or change the file extension if relevant\n[PUT THE CODE EXAMPLE HERE. IF THERE IS NO CODE TO ADD, JUST ADD A COMMENT SAYING \"Do your magic here!\"]\nawait sdb.done();\n```\n\nIf you need inspiration, here is a comprehensive example with comments.\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\n\n// We start a SimpleDB instance.\nconst sdb = new SimpleDB();\n\n// We create a new table\nconst fires = sdb.newTable(\"fires\");\n// We fetch the wildfires data. It's a csv.\nawait fires.loadData(\n  \"data/firesCanada2023.csv\",\n);\n\n// We summarize to count the number of fires\n// and sum up the area burnt in each province.\nawait fires.summarize({\n  values: \"hectares\",\n  categories: \"province\",\n  summaries: [\"count\", \"sum\"],\n  decimals: 0,\n});\n// We rename columns.\nawait fires.renameColumns({\n  count: \"nbFires\",\n  sum: \"burntArea\",\n});\n// We want the province with\n// the greatest burnt area first.\nawait fires.sort({ burntArea: \"desc\" });\n\n// We log the results. By default, the method\n// logs the first 10 rows, but there is 13\n// rows in our data. We also log the data types.\nawait fires.logTable({ nbRowsToLog: 13, types: true });\n\n// And we can write the data to a parquet, json or csv file.\nawait fires.writeData(\"./fires.parquet\");\n\n// We close everything.\nawait sdb.done();\n```\n\nReturn your response as a JSON object with the following structure:\n{\n  \"data\": [\n    { \"question\": \"question1\", \"answer\": \"answer1\" },\n    { \"question\": \"question2\", \"answer\": \"answer2\" },\n    ...\n  ]\n}\n\nHere's the documentation section:\n\n\n#### `join`\n\nMerges the data of this table (considered the left table) with another table\n(the right table) based on a common column or multiple columns. Note that the\norder of rows in the returned data is not guaranteed to be the same as in the\noriginal tables. This operation might create temporary files in a `.tmp` folder;\nconsider adding `.tmp` to your `.gitignore`.\n\n##### Signature\n\n```typescript\nasync join(rightTable: SimpleTable, options?: { commonColumn?: string | string[]; type?: \"inner\" | \"left\" | \"right\" | \"full\"; outputTable?: string | boolean }): Promise<SimpleTable>;\n```\n\n##### Parameters\n\n- **`rightTable`**: - The SimpleTable instance to be joined with this table.\n- **`options`**: - An optional object with configuration options:\n- **`options.commonColumn`**: - The common column(s) used for the join\n  operation. If omitted, the method automatically searches for a column name\n  that exists in both tables. Can be a single string or an array of strings for\n  multiple join keys.\n- **`options.type`**: - The type of join operation to perform. Possible values\n  are `\"inner\"`, `\"left\"` (default), `\"right\"`, or `\"full\"`.\n- **`options.outputTable`**: - If `true`, the results will be stored in a new\n  table with a generated name. If a string, it will be used as the name for the\n  new table. If `false` or omitted, the current table will be overwritten.\n  Defaults to `false`.\n\n##### Returns\n\nA promise that resolves to the SimpleTable instance containing the joined data\n(either the modified current table or a new table).\n\n##### Examples\n\n```ts\n// Perform a left join with 'tableB' on a common column (auto-detected), overwriting tableA\nawait tableA.join(tableB);\n```\n\n```ts\n// Perform an inner join with 'tableB' on the 'id' column, storing results in a new table named 'tableC'\nconst tableC = await tableA.join(tableB, {\n  commonColumn: \"id\",\n  type: \"inner\",\n  outputTable: \"tableC\",\n});\n```\n\n```ts\n// Perform a join on multiple columns ('name' and 'category')\nawait tableA.join(tableB, { commonColumn: [\"name\", \"category\"] });\n```"
  },
  {
    "model": "qwen3:30b",
    "prompt": "Your task is to generate a set of up to 10 relevant questions and answers based on the provided section of documentation. The questions should be those a junior developer or data analyst might have.\n\nFor each question, you must provide a code example as the answer. You can add comments to the code to explain the steps. A brief, one-sentence explanation may be included in a comment if the code alone is not a sufficient answer.\n\nThe questions must be directly related to the documentation section provided below and must not ask about topics outside its scope. The answer should be grounded in the documentation provided. Do not make assumptions.\n\nWrite simple and straightforward code examples. Don't create functions to encapsulate your code.\n\nYour answers should always be wrapped in triple backticks (```ts at the beginning and ``` at the end) for code blocks.\n\nIf the documentation section is about SimpleDB, make sure to wrap your answer with:\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\nconst sdb = new SimpleDB();\n[PUT THE CODE EXAMPLE HERE. IF THERE IS NO CODE TO ADD, JUST ADD A COMMENT SAYING \"Do your magic here!\"]\nawait sdb.done();\n```\n\nIf the documentation section is about SimpleTable, make sure to wrap your answer with:\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\nconst sdb = new SimpleDB();\nconst table = sdb.newTable();\nawait table.loadData(\"path/to/your/data.csv\"); // Remove this line if not needed or change the file extension if relevant\n[PUT THE CODE EXAMPLE HERE. IF THERE IS NO CODE TO ADD, JUST ADD A COMMENT SAYING \"Do your magic here!\"]\nawait sdb.done();\n```\n\nIf you need inspiration, here is a comprehensive example with comments.\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\n\n// We start a SimpleDB instance.\nconst sdb = new SimpleDB();\n\n// We create a new table\nconst fires = sdb.newTable(\"fires\");\n// We fetch the wildfires data. It's a csv.\nawait fires.loadData(\n  \"data/firesCanada2023.csv\",\n);\n\n// We summarize to count the number of fires\n// and sum up the area burnt in each province.\nawait fires.summarize({\n  values: \"hectares\",\n  categories: \"province\",\n  summaries: [\"count\", \"sum\"],\n  decimals: 0,\n});\n// We rename columns.\nawait fires.renameColumns({\n  count: \"nbFires\",\n  sum: \"burntArea\",\n});\n// We want the province with\n// the greatest burnt area first.\nawait fires.sort({ burntArea: \"desc\" });\n\n// We log the results. By default, the method\n// logs the first 10 rows, but there is 13\n// rows in our data. We also log the data types.\nawait fires.logTable({ nbRowsToLog: 13, types: true });\n\n// And we can write the data to a parquet, json or csv file.\nawait fires.writeData(\"./fires.parquet\");\n\n// We close everything.\nawait sdb.done();\n```\n\nReturn your response as a JSON object with the following structure:\n{\n  \"data\": [\n    { \"question\": \"question1\", \"answer\": \"answer1\" },\n    { \"question\": \"question2\", \"answer\": \"answer2\" },\n    ...\n  ]\n}\n\nHere's the documentation section:\n\n\n#### `right`\n\nExtracts a specific number of characters from the end (right side) of string\nvalues in the specified column.\n\n##### Signature\n\n```typescript\nasync right(column: string, numberOfCharacters: number): Promise<void>;\n```\n\n##### Parameters\n\n- **`column`**: - The name of the column containing the strings to be modified.\n- **`numberOfCharacters`**: - The number of characters to extract from the right\n  side of each string.\n\n##### Returns\n\nA promise that resolves when the strings have been updated.\n\n##### Examples\n\n```ts\n// Replace strings in 'productCode' with their last two characters\n// e.g., \"ABC-123\" becomes \"23\"\nawait table.right(\"productCode\", 2);\n```"
  },
  {
    "model": "qwen3:30b",
    "prompt": "Your task is to generate a set of up to 10 relevant questions and answers based on the provided section of documentation. The questions should be those a junior developer or data analyst might have.\n\nFor each question, you must provide a code example as the answer. You can add comments to the code to explain the steps. A brief, one-sentence explanation may be included in a comment if the code alone is not a sufficient answer.\n\nThe questions must be directly related to the documentation section provided below and must not ask about topics outside its scope. The answer should be grounded in the documentation provided. Do not make assumptions.\n\nWrite simple and straightforward code examples. Don't create functions to encapsulate your code.\n\nYour answers should always be wrapped in triple backticks (```ts at the beginning and ``` at the end) for code blocks.\n\nIf the documentation section is about SimpleDB, make sure to wrap your answer with:\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\nconst sdb = new SimpleDB();\n[PUT THE CODE EXAMPLE HERE. IF THERE IS NO CODE TO ADD, JUST ADD A COMMENT SAYING \"Do your magic here!\"]\nawait sdb.done();\n```\n\nIf the documentation section is about SimpleTable, make sure to wrap your answer with:\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\nconst sdb = new SimpleDB();\nconst table = sdb.newTable();\nawait table.loadData(\"path/to/your/data.csv\"); // Remove this line if not needed or change the file extension if relevant\n[PUT THE CODE EXAMPLE HERE. IF THERE IS NO CODE TO ADD, JUST ADD A COMMENT SAYING \"Do your magic here!\"]\nawait sdb.done();\n```\n\nIf you need inspiration, here is a comprehensive example with comments.\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\n\n// We start a SimpleDB instance.\nconst sdb = new SimpleDB();\n\n// We create a new table\nconst fires = sdb.newTable(\"fires\");\n// We fetch the wildfires data. It's a csv.\nawait fires.loadData(\n  \"data/firesCanada2023.csv\",\n);\n\n// We summarize to count the number of fires\n// and sum up the area burnt in each province.\nawait fires.summarize({\n  values: \"hectares\",\n  categories: \"province\",\n  summaries: [\"count\", \"sum\"],\n  decimals: 0,\n});\n// We rename columns.\nawait fires.renameColumns({\n  count: \"nbFires\",\n  sum: \"burntArea\",\n});\n// We want the province with\n// the greatest burnt area first.\nawait fires.sort({ burntArea: \"desc\" });\n\n// We log the results. By default, the method\n// logs the first 10 rows, but there is 13\n// rows in our data. We also log the data types.\nawait fires.logTable({ nbRowsToLog: 13, types: true });\n\n// And we can write the data to a parquet, json or csv file.\nawait fires.writeData(\"./fires.parquet\");\n\n// We close everything.\nawait sdb.done();\n```\n\nReturn your response as a JSON object with the following structure:\n{\n  \"data\": [\n    { \"question\": \"question1\", \"answer\": \"answer1\" },\n    { \"question\": \"question2\", \"answer\": \"answer2\" },\n    ...\n  ]\n}\n\nHere's the documentation section:\n\n\n#### `concatenate`\n\nConcatenates values from specified columns into a new column.\n\n##### Signature\n\n```typescript\nasync concatenate(columns: string[], newColumn: string, options?: { separator?: string }): Promise<void>;\n```\n\n##### Parameters\n\n- **`columns`**: - An array of column names whose values will be concatenated.\n- **`newColumn`**: - The name of the new column to store the concatenated\n  values.\n- **`options`**: - An optional object with configuration options:\n- **`options.separator`**: - The string used to separate concatenated values.\n  Defaults to an empty string (`\"\"`).\n\n##### Returns\n\nA promise that resolves when the concatenation is complete.\n\n##### Examples\n\n```ts\n// Concatenate 'firstName' and 'lastName' into a new 'fullName' column\nawait table.concatenate([\"firstName\", \"lastName\"], \"fullName\");\n```\n\n```ts\n// Concatenate 'city' and 'country' into 'location', separated by a comma and space\nawait table.concatenate([\"city\", \"country\"], \"location\", { separator: \", \" });\n```"
  },
  {
    "model": "qwen3:30b",
    "prompt": "Your task is to generate a set of up to 10 relevant questions and answers based on the provided section of documentation. The questions should be those a junior developer or data analyst might have.\n\nFor each question, you must provide a code example as the answer. You can add comments to the code to explain the steps. A brief, one-sentence explanation may be included in a comment if the code alone is not a sufficient answer.\n\nThe questions must be directly related to the documentation section provided below and must not ask about topics outside its scope. The answer should be grounded in the documentation provided. Do not make assumptions.\n\nWrite simple and straightforward code examples. Don't create functions to encapsulate your code.\n\nYour answers should always be wrapped in triple backticks (```ts at the beginning and ``` at the end) for code blocks.\n\nIf the documentation section is about SimpleDB, make sure to wrap your answer with:\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\nconst sdb = new SimpleDB();\n[PUT THE CODE EXAMPLE HERE. IF THERE IS NO CODE TO ADD, JUST ADD A COMMENT SAYING \"Do your magic here!\"]\nawait sdb.done();\n```\n\nIf the documentation section is about SimpleTable, make sure to wrap your answer with:\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\nconst sdb = new SimpleDB();\nconst table = sdb.newTable();\nawait table.loadData(\"path/to/your/data.csv\"); // Remove this line if not needed or change the file extension if relevant\n[PUT THE CODE EXAMPLE HERE. IF THERE IS NO CODE TO ADD, JUST ADD A COMMENT SAYING \"Do your magic here!\"]\nawait sdb.done();\n```\n\nIf you need inspiration, here is a comprehensive example with comments.\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\n\n// We start a SimpleDB instance.\nconst sdb = new SimpleDB();\n\n// We create a new table\nconst fires = sdb.newTable(\"fires\");\n// We fetch the wildfires data. It's a csv.\nawait fires.loadData(\n  \"data/firesCanada2023.csv\",\n);\n\n// We summarize to count the number of fires\n// and sum up the area burnt in each province.\nawait fires.summarize({\n  values: \"hectares\",\n  categories: \"province\",\n  summaries: [\"count\", \"sum\"],\n  decimals: 0,\n});\n// We rename columns.\nawait fires.renameColumns({\n  count: \"nbFires\",\n  sum: \"burntArea\",\n});\n// We want the province with\n// the greatest burnt area first.\nawait fires.sort({ burntArea: \"desc\" });\n\n// We log the results. By default, the method\n// logs the first 10 rows, but there is 13\n// rows in our data. We also log the data types.\nawait fires.logTable({ nbRowsToLog: 13, types: true });\n\n// And we can write the data to a parquet, json or csv file.\nawait fires.writeData(\"./fires.parquet\");\n\n// We close everything.\nawait sdb.done();\n```\n\nReturn your response as a JSON object with the following structure:\n{\n  \"data\": [\n    { \"question\": \"question1\", \"answer\": \"answer1\" },\n    { \"question\": \"question2\", \"answer\": \"answer2\" },\n    ...\n  ]\n}\n\nHere's the documentation section:\n\n\n#### `updateColumn`\n\nUpdates values in a specified column using a SQL expression.\n\n##### Signature\n\n```typescript\nasync updateColumn(column: string, definition: string): Promise<void>;\n```\n\n##### Parameters\n\n- **`column`**: - The name of the column to be updated.\n- **`definition`**: - The SQL expression used to set the new values in the\n  column (e.g., `\"column1 * 2\"`, `\"UPPER(column_name)\"`).\n\n##### Returns\n\nA promise that resolves when the column has been updated.\n\n##### Examples\n\n```ts\n// Update 'column1' with the left 5 characters of 'column2'\nawait table.updateColumn(\"column1\", `LEFT(column2, 5)`);\n```\n\n```ts\n// Double the values in 'price' column\nawait table.updateColumn(\"price\", `price * 2`);\n```\n\n```ts\n// Set 'status' to 'active' where 'isActive' is true\nawait table.updateColumn(\n  \"status\",\n  `CASE WHEN isActive THEN 'active' ELSE 'inactive' END`,\n);\n```"
  },
  {
    "model": "qwen3:30b",
    "prompt": "Your task is to generate a set of up to 10 relevant questions and answers based on the provided section of documentation. The questions should be those a junior developer or data analyst might have.\n\nFor each question, you must provide a code example as the answer. You can add comments to the code to explain the steps. A brief, one-sentence explanation may be included in a comment if the code alone is not a sufficient answer.\n\nThe questions must be directly related to the documentation section provided below and must not ask about topics outside its scope. The answer should be grounded in the documentation provided. Do not make assumptions.\n\nWrite simple and straightforward code examples. Don't create functions to encapsulate your code.\n\nYour answers should always be wrapped in triple backticks (```ts at the beginning and ``` at the end) for code blocks.\n\nIf the documentation section is about SimpleDB, make sure to wrap your answer with:\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\nconst sdb = new SimpleDB();\n[PUT THE CODE EXAMPLE HERE. IF THERE IS NO CODE TO ADD, JUST ADD A COMMENT SAYING \"Do your magic here!\"]\nawait sdb.done();\n```\n\nIf the documentation section is about SimpleTable, make sure to wrap your answer with:\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\nconst sdb = new SimpleDB();\nconst table = sdb.newTable();\nawait table.loadData(\"path/to/your/data.csv\"); // Remove this line if not needed or change the file extension if relevant\n[PUT THE CODE EXAMPLE HERE. IF THERE IS NO CODE TO ADD, JUST ADD A COMMENT SAYING \"Do your magic here!\"]\nawait sdb.done();\n```\n\nIf you need inspiration, here is a comprehensive example with comments.\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\n\n// We start a SimpleDB instance.\nconst sdb = new SimpleDB();\n\n// We create a new table\nconst fires = sdb.newTable(\"fires\");\n// We fetch the wildfires data. It's a csv.\nawait fires.loadData(\n  \"data/firesCanada2023.csv\",\n);\n\n// We summarize to count the number of fires\n// and sum up the area burnt in each province.\nawait fires.summarize({\n  values: \"hectares\",\n  categories: \"province\",\n  summaries: [\"count\", \"sum\"],\n  decimals: 0,\n});\n// We rename columns.\nawait fires.renameColumns({\n  count: \"nbFires\",\n  sum: \"burntArea\",\n});\n// We want the province with\n// the greatest burnt area first.\nawait fires.sort({ burntArea: \"desc\" });\n\n// We log the results. By default, the method\n// logs the first 10 rows, but there is 13\n// rows in our data. We also log the data types.\nawait fires.logTable({ nbRowsToLog: 13, types: true });\n\n// And we can write the data to a parquet, json or csv file.\nawait fires.writeData(\"./fires.parquet\");\n\n// We close everything.\nawait sdb.done();\n```\n\nReturn your response as a JSON object with the following structure:\n{\n  \"data\": [\n    { \"question\": \"question1\", \"answer\": \"answer1\" },\n    { \"question\": \"question2\", \"answer\": \"answer2\" },\n    ...\n  ]\n}\n\nHere's the documentation section:\n\n\n#### `quantiles`\n\nAssigns quantiles to rows in a new column based on specified column values.\n\n##### Signature\n\n```typescript\nasync quantiles(values: string, nbQuantiles: number, newColumn: string, options?: { categories?: string | string[] }): Promise<void>;\n```\n\n##### Parameters\n\n- **`values`**: - The column containing values from which quantiles will be\n  assigned.\n- **`nbQuantiles`**: - The number of quantiles to divide the data into (e.g.,\n  `4` for quartiles, `10` for deciles).\n- **`newColumn`**: - The name of the new column where the assigned quantiles\n  will be stored.\n- **`options`**: - An optional object with configuration options:\n- **`options.categories`**: - The column name or an array of column names that\n  define categories for computing quantiles. Quantiles will be assigned\n  independently within each category.\n\n##### Returns\n\nA promise that resolves when the quantiles have been assigned.\n\n##### Examples\n\n```ts\n// Assigns a quantile from 1 to 10 for each row in a new 'quantiles' column, based on 'column1' values.\nawait table.quantiles(\"column1\", 10, \"quantiles\");\n```\n\n```ts\n// Assigns quantiles within 'column2' categories, based on 'column1' values.\nawait table.quantiles(\"column1\", 10, \"quantiles\", { categories: \"column2\" });\n```\n\n```ts\n// Assigns quartiles (4 quantiles) to 'sales' data, storing results in 'salesQuartile'\nawait table.quantiles(\"sales\", 4, \"salesQuartile\");\n```"
  },
  {
    "model": "qwen3:30b",
    "prompt": "Your task is to generate a set of up to 10 relevant questions and answers based on the provided section of documentation. The questions should be those a junior developer or data analyst might have.\n\nFor each question, you must provide a code example as the answer. You can add comments to the code to explain the steps. A brief, one-sentence explanation may be included in a comment if the code alone is not a sufficient answer.\n\nThe questions must be directly related to the documentation section provided below and must not ask about topics outside its scope. The answer should be grounded in the documentation provided. Do not make assumptions.\n\nWrite simple and straightforward code examples. Don't create functions to encapsulate your code.\n\nYour answers should always be wrapped in triple backticks (```ts at the beginning and ``` at the end) for code blocks.\n\nIf the documentation section is about SimpleDB, make sure to wrap your answer with:\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\nconst sdb = new SimpleDB();\n[PUT THE CODE EXAMPLE HERE. IF THERE IS NO CODE TO ADD, JUST ADD A COMMENT SAYING \"Do your magic here!\"]\nawait sdb.done();\n```\n\nIf the documentation section is about SimpleTable, make sure to wrap your answer with:\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\nconst sdb = new SimpleDB();\nconst table = sdb.newTable();\nawait table.loadData(\"path/to/your/data.csv\"); // Remove this line if not needed or change the file extension if relevant\n[PUT THE CODE EXAMPLE HERE. IF THERE IS NO CODE TO ADD, JUST ADD A COMMENT SAYING \"Do your magic here!\"]\nawait sdb.done();\n```\n\nIf you need inspiration, here is a comprehensive example with comments.\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\n\n// We start a SimpleDB instance.\nconst sdb = new SimpleDB();\n\n// We create a new table\nconst fires = sdb.newTable(\"fires\");\n// We fetch the wildfires data. It's a csv.\nawait fires.loadData(\n  \"data/firesCanada2023.csv\",\n);\n\n// We summarize to count the number of fires\n// and sum up the area burnt in each province.\nawait fires.summarize({\n  values: \"hectares\",\n  categories: \"province\",\n  summaries: [\"count\", \"sum\"],\n  decimals: 0,\n});\n// We rename columns.\nawait fires.renameColumns({\n  count: \"nbFires\",\n  sum: \"burntArea\",\n});\n// We want the province with\n// the greatest burnt area first.\nawait fires.sort({ burntArea: \"desc\" });\n\n// We log the results. By default, the method\n// logs the first 10 rows, but there is 13\n// rows in our data. We also log the data types.\nawait fires.logTable({ nbRowsToLog: 13, types: true });\n\n// And we can write the data to a parquet, json or csv file.\nawait fires.writeData(\"./fires.parquet\");\n\n// We close everything.\nawait sdb.done();\n```\n\nReturn your response as a JSON object with the following structure:\n{\n  \"data\": [\n    { \"question\": \"question1\", \"answer\": \"answer1\" },\n    { \"question\": \"question2\", \"answer\": \"answer2\" },\n    ...\n  ]\n}\n\nHere's the documentation section:\n\n\n#### `proportionsHorizontal`\n\nComputes proportions horizontally across specified columns for each row.\n\nFor example, given a table showing counts of men, women, and non-binary\nindividuals per year:\n\n| Year | Men | Women | NonBinary |\n| :--- | :-- | :---- | :-------- |\n| 2021 | 564 | 685   | 145       |\n| 2022 | 354 | 278   | 56        |\n| 2023 | 856 | 321   | 221       |\n\nThis method computes the proportion of men, women, and non-binary individuals on\neach row, adding new columns for these proportions.\n\n##### Signature\n\n```typescript\nasync proportionsHorizontal(columns: string[], options?: { suffix?: string; decimals?: number }): Promise<void>;\n```\n\n##### Parameters\n\n- **`columns`**: - An array of column names for which proportions will be\n  computed on each row.\n- **`options`**: - An optional object with configuration options:\n- **`options.suffix`**: - A string suffix to append to the names of the new\n  columns storing the computed proportions. Defaults to `\"Perc\"`.\n- **`options.decimals`**: - The number of decimal places to round the computed\n  proportions. Defaults to `undefined` (no rounding).\n\n##### Returns\n\nA promise that resolves when the horizontal proportions have been computed.\n\n##### Examples\n\n```ts\n// Compute horizontal proportions for 'Men', 'Women', and 'NonBinary' columns, rounded to 2 decimal places\nawait table.proportionsHorizontal([\"Men\", \"Women\", \"NonBinary\"], {\n  decimals: 2,\n});\n```\n\nThe table will then look like this:\n\n| Year | Men | Women | NonBinary | MenPerc | WomenPerc | NonBinaryPerc |\n| :--- | :-- | :---- | :-------- | :------ | :-------- | :------------ |\n| 2021 | 564 | 685   | 145       | 0.4     | 0.49      | 0.10          |\n| 2022 | 354 | 278   | 56        | 0.51    | 0.4       | 0.08          |\n| 2023 | 856 | 321   | 221       | 0.61    | 0.23      | 0.16          |\n\nBy default, the new columns will be named with a suffix of `\"Perc\"`. You can\ncustomize this suffix using the `suffix` option.\n\n```ts\n// Compute horizontal proportions with a custom suffix \"Prop\"\nawait table.proportionsHorizontal([\"Men\", \"Women\", \"NonBinary\"], {\n  suffix: \"Prop\",\n  decimals: 2,\n});\n```\n\nThe table will then look like this:\n\n| Year | Men | Women | NonBinary | MenProp | WomenProp | NonBinaryProp |\n| :--- | :-- | :---- | :-------- | :------ | :-------- | :------------ |\n| 2021 | 564 | 685   | 145       | 0.4     | 0.49      | 0.10          |\n| 2022 | 354 | 278   | 56        | 0.51    | 0.4       | 0.08          |\n| 2023 | 856 | 321   | 221       | 0.61    | 0.23      | 0.16          |"
  },
  {
    "model": "qwen3:30b",
    "prompt": "Your task is to generate a set of up to 10 relevant questions and answers based on the provided section of documentation. The questions should be those a junior developer or data analyst might have.\n\nFor each question, you must provide a code example as the answer. You can add comments to the code to explain the steps. A brief, one-sentence explanation may be included in a comment if the code alone is not a sufficient answer.\n\nThe questions must be directly related to the documentation section provided below and must not ask about topics outside its scope. The answer should be grounded in the documentation provided. Do not make assumptions.\n\nWrite simple and straightforward code examples. Don't create functions to encapsulate your code.\n\nYour answers should always be wrapped in triple backticks (```ts at the beginning and ``` at the end) for code blocks.\n\nIf the documentation section is about SimpleDB, make sure to wrap your answer with:\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\nconst sdb = new SimpleDB();\n[PUT THE CODE EXAMPLE HERE. IF THERE IS NO CODE TO ADD, JUST ADD A COMMENT SAYING \"Do your magic here!\"]\nawait sdb.done();\n```\n\nIf the documentation section is about SimpleTable, make sure to wrap your answer with:\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\nconst sdb = new SimpleDB();\nconst table = sdb.newTable();\nawait table.loadData(\"path/to/your/data.csv\"); // Remove this line if not needed or change the file extension if relevant\n[PUT THE CODE EXAMPLE HERE. IF THERE IS NO CODE TO ADD, JUST ADD A COMMENT SAYING \"Do your magic here!\"]\nawait sdb.done();\n```\n\nIf you need inspiration, here is a comprehensive example with comments.\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\n\n// We start a SimpleDB instance.\nconst sdb = new SimpleDB();\n\n// We create a new table\nconst fires = sdb.newTable(\"fires\");\n// We fetch the wildfires data. It's a csv.\nawait fires.loadData(\n  \"data/firesCanada2023.csv\",\n);\n\n// We summarize to count the number of fires\n// and sum up the area burnt in each province.\nawait fires.summarize({\n  values: \"hectares\",\n  categories: \"province\",\n  summaries: [\"count\", \"sum\"],\n  decimals: 0,\n});\n// We rename columns.\nawait fires.renameColumns({\n  count: \"nbFires\",\n  sum: \"burntArea\",\n});\n// We want the province with\n// the greatest burnt area first.\nawait fires.sort({ burntArea: \"desc\" });\n\n// We log the results. By default, the method\n// logs the first 10 rows, but there is 13\n// rows in our data. We also log the data types.\nawait fires.logTable({ nbRowsToLog: 13, types: true });\n\n// And we can write the data to a parquet, json or csv file.\nawait fires.writeData(\"./fires.parquet\");\n\n// We close everything.\nawait sdb.done();\n```\n\nReturn your response as a JSON object with the following structure:\n{\n  \"data\": [\n    { \"question\": \"question1\", \"answer\": \"answer1\" },\n    { \"question\": \"question2\", \"answer\": \"answer2\" },\n    ...\n  ]\n}\n\nHere's the documentation section:\n\n\n#### `summarize`\n\nCreates a summary table based on specified values, categories, and summary\noperations. This method allows you to aggregate data, calculate statistics\n(e.g., count, mean, sum), and group results by categorical columns.\n\n##### Signature\n\n```typescript\nasync summarize(options?: { values?: string | string[]; categories?: string | string[]; summaries?: (\"count\" | \"countUnique\" | \"countNull\" | \"min\" | \"max\" | \"mean\" | \"median\" | \"sum\" | \"skew\" | \"stdDev\" | \"var\") | (\"count\" | \"countUnique\" | \"countNull\" | \"min\" | \"max\" | \"mean\" | \"median\" | \"sum\" | \"skew\" | \"stdDev\" | \"var\")[] | Record<string, \"count\" | \"countUnique\" | \"countNull\" | \"min\" | \"max\" | \"mean\" | \"median\" | \"sum\" | \"skew\" | \"stdDev\" | \"var\">; decimals?: number; outputTable?: string | boolean; toMs?: boolean; noColumnValue?: boolean }): Promise<SimpleTable>;\n```\n\n##### Parameters\n\n- **`options`**: - An object with configuration options for summarization:\n- **`options.values`**: - The column name or an array of column names whose\n  values will be summarized. If omitted, all columns will be summarized.\n- **`options.categories`**: - The column name or an array of column names that\n  define categories for the summarization. Results will be grouped by these\n  categories.\n- **`options.summaries`**: - The summary operations to be performed. Can be a\n  single operation (e.g., `\"mean\"`), an array of operations (e.g.,\n  `[\"min\", \"max\"]`), or an object mapping new column names to operations (e.g.,\n  `{ avgSalary: \"mean\" }`). Supported operations include: `\"count\"`,\n  `\"countUnique\"`, `\"countNull\"`, `\"min\"`, `\"max\"`, `\"mean\"`, `\"median\"`,\n  `\"sum\"`, `\"skew\"`, `\"stdDev\"`, `\"var\"`.\n- **`options.decimals`**: - The number of decimal places to round the summarized\n  values. Defaults to `undefined` (no rounding).\n- **`options.outputTable`**: - If `true`, the results will be stored in a new\n  table with a generated name. If a string, it will be used as the name for the\n  new table. If `false` or omitted, the current table will be overwritten.\n  Defaults to `false`.\n- **`options.toMs`**: - If `true`, timestamps, dates, and times will be\n  converted to milliseconds before summarizing. This is useful when summarizing\n  mixed data types (numbers and dates) as values must be of the same type for\n  aggregation.\n- **`options.noColumnValue`**: - If `true`, the default `value` column will be\n  removed. This option only works when summarizing a single column without\n  categories. Defaults to `false`.\n\n##### Returns\n\nA promise that resolves to the SimpleTable instance containing the summarized\ndata (either the modified current table or a new table).\n\n##### Examples\n\n```ts\n// Summarize all columns with all available summary operations, overwriting the current table\nconst columns = await table.getColumns();\nawait table.summarize({ values: columns });\n```\n\n```ts\n// Summarize all columns and store the results in a new table with a generated name\nconst columns = await table.getColumns();\nconst summaryTable = await table.summarize({\n  values: columns,\n  outputTable: true,\n});\n```\n\n```ts\n// Summarize all columns and store the results in a new table named 'mySummary'\nconst columns = await table.getColumns();\nconst mySummaryTable = await table.summarize({\n  values: columns,\n  outputTable: \"mySummary\",\n});\n```\n\n```ts\n// Summarize a single column ('sales') with all available summary operations\nawait table.summarize({ values: \"sales\" });\n```\n\n```ts\n// Summarize multiple columns ('sales' and 'profit') with all available summary operations\nawait table.summarize({ values: [\"sales\", \"profit\"] });\n```\n\n```ts\n// Summarize 'sales' by 'region' (single category)\nawait table.summarize({ values: \"sales\", categories: \"region\" });\n```\n\n```ts\n// Summarize 'sales' by 'region' and 'product_type' (multiple categories)\nawait table.summarize({\n  values: \"sales\",\n  categories: [\"region\", \"product_type\"],\n});\n```\n\n```ts\n// Summarize 'sales' by 'region' with a specific summary operation (mean)\nawait table.summarize({\n  values: \"sales\",\n  categories: \"region\",\n  summaries: \"mean\",\n});\n```\n\n```ts\n// Summarize 'sales' by 'region' with specific summary operations (mean and sum)\nawait table.summarize({\n  values: \"sales\",\n  categories: \"region\",\n  summaries: [\"mean\", \"sum\"],\n});\n```\n\n```ts\n// Summarize 'sales' by 'region' with custom named summary operations\nawait table.summarize({\n  values: \"sales\",\n  categories: \"region\",\n  summaries: { averageSales: \"mean\", totalSales: \"sum\" },\n});\n```\n\n```ts\n// Summarize 'price' and 'cost', rounding aggregated values to 2 decimal places\nawait table.summarize({ values: [\"price\", \"cost\"], decimals: 2 });\n```\n\n```ts\n// Summarize 'timestamp_column' by converting to milliseconds first\nawait table.summarize({\n  values: \"timestamp_column\",\n  toMs: true,\n  summaries: \"mean\",\n});\n```\n\n```ts\n// Summarize a single column 'value_column' without the default 'value' column in the output\nawait table.summarize({ values: \"value_column\", noColumnValue: true });\n```"
  },
  {
    "model": "qwen3:30b",
    "prompt": "Your task is to generate a set of up to 10 relevant questions and answers based on the provided section of documentation. The questions should be those a junior developer or data analyst might have.\n\nFor each question, you must provide a code example as the answer. You can add comments to the code to explain the steps. A brief, one-sentence explanation may be included in a comment if the code alone is not a sufficient answer.\n\nThe questions must be directly related to the documentation section provided below and must not ask about topics outside its scope. The answer should be grounded in the documentation provided. Do not make assumptions.\n\nWrite simple and straightforward code examples. Don't create functions to encapsulate your code.\n\nYour answers should always be wrapped in triple backticks (```ts at the beginning and ``` at the end) for code blocks.\n\nIf the documentation section is about SimpleDB, make sure to wrap your answer with:\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\nconst sdb = new SimpleDB();\n[PUT THE CODE EXAMPLE HERE. IF THERE IS NO CODE TO ADD, JUST ADD A COMMENT SAYING \"Do your magic here!\"]\nawait sdb.done();\n```\n\nIf the documentation section is about SimpleTable, make sure to wrap your answer with:\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\nconst sdb = new SimpleDB();\nconst table = sdb.newTable();\nawait table.loadData(\"path/to/your/data.csv\"); // Remove this line if not needed or change the file extension if relevant\n[PUT THE CODE EXAMPLE HERE. IF THERE IS NO CODE TO ADD, JUST ADD A COMMENT SAYING \"Do your magic here!\"]\nawait sdb.done();\n```\n\nIf you need inspiration, here is a comprehensive example with comments.\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\n\n// We start a SimpleDB instance.\nconst sdb = new SimpleDB();\n\n// We create a new table\nconst fires = sdb.newTable(\"fires\");\n// We fetch the wildfires data. It's a csv.\nawait fires.loadData(\n  \"data/firesCanada2023.csv\",\n);\n\n// We summarize to count the number of fires\n// and sum up the area burnt in each province.\nawait fires.summarize({\n  values: \"hectares\",\n  categories: \"province\",\n  summaries: [\"count\", \"sum\"],\n  decimals: 0,\n});\n// We rename columns.\nawait fires.renameColumns({\n  count: \"nbFires\",\n  sum: \"burntArea\",\n});\n// We want the province with\n// the greatest burnt area first.\nawait fires.sort({ burntArea: \"desc\" });\n\n// We log the results. By default, the method\n// logs the first 10 rows, but there is 13\n// rows in our data. We also log the data types.\nawait fires.logTable({ nbRowsToLog: 13, types: true });\n\n// And we can write the data to a parquet, json or csv file.\nawait fires.writeData(\"./fires.parquet\");\n\n// We close everything.\nawait sdb.done();\n```\n\nReturn your response as a JSON object with the following structure:\n{\n  \"data\": [\n    { \"question\": \"question1\", \"answer\": \"answer1\" },\n    { \"question\": \"question2\", \"answer\": \"answer2\" },\n    ...\n  ]\n}\n\nHere's the documentation section:\n\n\n#### `linearRegressions`\n\nPerforms linear regression analysis. The results include the slope, the\ny-intercept, and the R-squared value. If no `x` and `y` columns are specified,\nthe method computes linear regression analysis for all numeric column\npermutations. Note that linear regression analysis is asymmetrical: the linear\nregression of `x` over `y` is not the same as `y` over `x`.\n\n##### Signature\n\n```typescript\nasync linearRegressions(options?: { x?: string; y?: string; categories?: string | string[]; decimals?: number; outputTable?: string | boolean }): Promise<SimpleTable>;\n```\n\n##### Parameters\n\n- **`options`**: - An optional object with configuration options:\n- **`options.x`**: - The name of the column for the independent variable\n  (x-values). If omitted, linear regressions will be computed for all numeric\n  columns as x.\n- **`options.y`**: - The name of the column for the dependent variable\n  (y-values). If omitted, linear regressions will be computed for all numeric\n  columns as y.\n- **`options.categories`**: - The column name or an array of column names that\n  define categories. Linear regression analysis will be performed independently\n  for each category.\n- **`options.decimals`**: - The number of decimal places to round the regression\n  values (slope, intercept, r-squared). Defaults to `undefined` (no rounding).\n- **`options.outputTable`**: - If `true`, the results will be stored in a new\n  table with a generated name. If a string, it will be used as the name for the\n  new table. If `false` or omitted, the current table will be overwritten.\n  Defaults to `false`.\n\n##### Returns\n\nA promise that resolves to the SimpleTable instance containing the linear\nregression results (either the modified current table or a new table).\n\n##### Examples\n\n```ts\n// Compute all linear regressions between all numeric columns, overwriting the current table\nawait table.linearRegressions();\n```\n\n```ts\n// Compute linear regressions with 'column1' as the independent variable and all other numeric columns as dependent variables\nawait table.linearRegressions({ x: \"column1\" });\n```\n\n```ts\n// Compute the linear regression of 'sales' (y) over 'advertising' (x)\nawait table.linearRegressions({ x: \"advertising\", y: \"sales\" });\n```\n\n```ts\n// Compute linear regressions within 'region' categories and store results in a new table\nconst regressionTable = await table.linearRegressions({\n  categories: \"region\",\n  outputTable: true,\n});\n```\n\n```ts\n// Compute linear regressions, rounded to 3 decimal places\nawait table.linearRegressions({ decimals: 3 });\n```"
  },
  {
    "model": "qwen3:30b",
    "prompt": "Your task is to generate a set of up to 10 relevant questions and answers based on the provided section of documentation. The questions should be those a junior developer or data analyst might have.\n\nFor each question, you must provide a code example as the answer. You can add comments to the code to explain the steps. A brief, one-sentence explanation may be included in a comment if the code alone is not a sufficient answer.\n\nThe questions must be directly related to the documentation section provided below and must not ask about topics outside its scope. The answer should be grounded in the documentation provided. Do not make assumptions.\n\nWrite simple and straightforward code examples. Don't create functions to encapsulate your code.\n\nYour answers should always be wrapped in triple backticks (```ts at the beginning and ``` at the end) for code blocks.\n\nIf the documentation section is about SimpleDB, make sure to wrap your answer with:\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\nconst sdb = new SimpleDB();\n[PUT THE CODE EXAMPLE HERE. IF THERE IS NO CODE TO ADD, JUST ADD A COMMENT SAYING \"Do your magic here!\"]\nawait sdb.done();\n```\n\nIf the documentation section is about SimpleTable, make sure to wrap your answer with:\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\nconst sdb = new SimpleDB();\nconst table = sdb.newTable();\nawait table.loadData(\"path/to/your/data.csv\"); // Remove this line if not needed or change the file extension if relevant\n[PUT THE CODE EXAMPLE HERE. IF THERE IS NO CODE TO ADD, JUST ADD A COMMENT SAYING \"Do your magic here!\"]\nawait sdb.done();\n```\n\nIf you need inspiration, here is a comprehensive example with comments.\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\n\n// We start a SimpleDB instance.\nconst sdb = new SimpleDB();\n\n// We create a new table\nconst fires = sdb.newTable(\"fires\");\n// We fetch the wildfires data. It's a csv.\nawait fires.loadData(\n  \"data/firesCanada2023.csv\",\n);\n\n// We summarize to count the number of fires\n// and sum up the area burnt in each province.\nawait fires.summarize({\n  values: \"hectares\",\n  categories: \"province\",\n  summaries: [\"count\", \"sum\"],\n  decimals: 0,\n});\n// We rename columns.\nawait fires.renameColumns({\n  count: \"nbFires\",\n  sum: \"burntArea\",\n});\n// We want the province with\n// the greatest burnt area first.\nawait fires.sort({ burntArea: \"desc\" });\n\n// We log the results. By default, the method\n// logs the first 10 rows, but there is 13\n// rows in our data. We also log the data types.\nawait fires.logTable({ nbRowsToLog: 13, types: true });\n\n// And we can write the data to a parquet, json or csv file.\nawait fires.writeData(\"./fires.parquet\");\n\n// We close everything.\nawait sdb.done();\n```\n\nReturn your response as a JSON object with the following structure:\n{\n  \"data\": [\n    { \"question\": \"question1\", \"answer\": \"answer1\" },\n    { \"question\": \"question2\", \"answer\": \"answer2\" },\n    ...\n  ]\n}\n\nHere's the documentation section:\n\n\n#### `zScore`\n\nComputes the Z-score for values in a specified column.\n\n##### Signature\n\n```typescript\nasync zScore(column: string, newColumn: string, options?: { categories?: string | string[]; decimals?: number }): Promise<void>;\n```\n\n##### Parameters\n\n- **`column`**: - The name of the column for which Z-scores will be calculated.\n- **`newColumn`**: - The name of the new column where the computed Z-scores will\n  be stored.\n- **`options`**: - An optional object with configuration options:\n- **`options.categories`**: - The column name or an array of column names that\n  define categories. Z-scores will be calculated independently within each\n  category.\n- **`options.decimals`**: - The number of decimal places to round the Z-score\n  values. Defaults to `undefined` (no rounding).\n\n##### Returns\n\nA promise that resolves when the Z-scores have been computed.\n\n##### Examples\n\n```ts\n// Calculate the Z-score for 'age' values and store results in a new 'ageZScore' column\nawait table.zScore(\"age\", \"ageZScore\");\n```\n\n```ts\n// Calculate Z-scores for 'salary' within 'department' categories\nawait table.zScore(\"salary\", \"salaryZScore\", { categories: \"department\" });\n```\n\n```ts\n// Calculate Z-scores for 'score', rounded to 2 decimal places\nawait table.zScore(\"score\", \"scoreZScore\", { decimals: 2 });\n```"
  },
  {
    "model": "qwen3:30b",
    "prompt": "Your task is to generate a set of up to 10 relevant questions and answers based on the provided section of documentation. The questions should be those a junior developer or data analyst might have.\n\nFor each question, you must provide a code example as the answer. You can add comments to the code to explain the steps. A brief, one-sentence explanation may be included in a comment if the code alone is not a sufficient answer.\n\nThe questions must be directly related to the documentation section provided below and must not ask about topics outside its scope. The answer should be grounded in the documentation provided. Do not make assumptions.\n\nWrite simple and straightforward code examples. Don't create functions to encapsulate your code.\n\nYour answers should always be wrapped in triple backticks (```ts at the beginning and ``` at the end) for code blocks.\n\nIf the documentation section is about SimpleDB, make sure to wrap your answer with:\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\nconst sdb = new SimpleDB();\n[PUT THE CODE EXAMPLE HERE. IF THERE IS NO CODE TO ADD, JUST ADD A COMMENT SAYING \"Do your magic here!\"]\nawait sdb.done();\n```\n\nIf the documentation section is about SimpleTable, make sure to wrap your answer with:\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\nconst sdb = new SimpleDB();\nconst table = sdb.newTable();\nawait table.loadData(\"path/to/your/data.csv\"); // Remove this line if not needed or change the file extension if relevant\n[PUT THE CODE EXAMPLE HERE. IF THERE IS NO CODE TO ADD, JUST ADD A COMMENT SAYING \"Do your magic here!\"]\nawait sdb.done();\n```\n\nIf you need inspiration, here is a comprehensive example with comments.\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\n\n// We start a SimpleDB instance.\nconst sdb = new SimpleDB();\n\n// We create a new table\nconst fires = sdb.newTable(\"fires\");\n// We fetch the wildfires data. It's a csv.\nawait fires.loadData(\n  \"data/firesCanada2023.csv\",\n);\n\n// We summarize to count the number of fires\n// and sum up the area burnt in each province.\nawait fires.summarize({\n  values: \"hectares\",\n  categories: \"province\",\n  summaries: [\"count\", \"sum\"],\n  decimals: 0,\n});\n// We rename columns.\nawait fires.renameColumns({\n  count: \"nbFires\",\n  sum: \"burntArea\",\n});\n// We want the province with\n// the greatest burnt area first.\nawait fires.sort({ burntArea: \"desc\" });\n\n// We log the results. By default, the method\n// logs the first 10 rows, but there is 13\n// rows in our data. We also log the data types.\nawait fires.logTable({ nbRowsToLog: 13, types: true });\n\n// And we can write the data to a parquet, json or csv file.\nawait fires.writeData(\"./fires.parquet\");\n\n// We close everything.\nawait sdb.done();\n```\n\nReturn your response as a JSON object with the following structure:\n{\n  \"data\": [\n    { \"question\": \"question1\", \"answer\": \"answer1\" },\n    { \"question\": \"question2\", \"answer\": \"answer2\" },\n    ...\n  ]\n}\n\nHere's the documentation section:\n\n\n#### `normalize`\n\nNormalizes the values in a column using min-max normalization.\n\n##### Signature\n\n```typescript\nasync normalize(column: string, newColumn: string, options?: { categories?: string | string[]; decimals?: number }): Promise<void>;\n```\n\n##### Parameters\n\n- **`column`**: - The name of the column in which values will be normalized.\n- **`newColumn`**: - The name of the new column where normalized values will be\n  stored.\n- **`options`**: - An optional object with configuration options:\n- **`options.categories`**: - The column name or an array of column names that\n  define categories for the normalization. Normalization will be performed\n  independently within each category.\n- **`options.decimals`**: - The number of decimal places to round the normalized\n  values. Defaults to `undefined` (no rounding).\n\n##### Returns\n\nA promise that resolves when the values have been normalized.\n\n##### Examples\n\n```ts\n// Normalize the values in 'column1' and store them in a new 'normalizedColumn1' column\nawait table.normalize(\"column1\", \"normalizedColumn1\");\n```\n\n```ts\n// Normalize 'value' within 'group' categories\nawait table.normalize(\"value\", \"normalizedValue\", { categories: \"group\" });\n```\n\n```ts\n// Normalize 'data' values, rounded to 2 decimal places\nawait table.normalize(\"data\", \"normalizedData\", { decimals: 2 });\n```"
  },
  {
    "model": "qwen3:30b",
    "prompt": "Your task is to generate a set of up to 10 relevant questions and answers based on the provided section of documentation. The questions should be those a junior developer or data analyst might have.\n\nFor each question, you must provide a code example as the answer. You can add comments to the code to explain the steps. A brief, one-sentence explanation may be included in a comment if the code alone is not a sufficient answer.\n\nThe questions must be directly related to the documentation section provided below and must not ask about topics outside its scope. The answer should be grounded in the documentation provided. Do not make assumptions.\n\nWrite simple and straightforward code examples. Don't create functions to encapsulate your code.\n\nYour answers should always be wrapped in triple backticks (```ts at the beginning and ``` at the end) for code blocks.\n\nIf the documentation section is about SimpleDB, make sure to wrap your answer with:\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\nconst sdb = new SimpleDB();\n[PUT THE CODE EXAMPLE HERE. IF THERE IS NO CODE TO ADD, JUST ADD A COMMENT SAYING \"Do your magic here!\"]\nawait sdb.done();\n```\n\nIf the documentation section is about SimpleTable, make sure to wrap your answer with:\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\nconst sdb = new SimpleDB();\nconst table = sdb.newTable();\nawait table.loadData(\"path/to/your/data.csv\"); // Remove this line if not needed or change the file extension if relevant\n[PUT THE CODE EXAMPLE HERE. IF THERE IS NO CODE TO ADD, JUST ADD A COMMENT SAYING \"Do your magic here!\"]\nawait sdb.done();\n```\n\nIf you need inspiration, here is a comprehensive example with comments.\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\n\n// We start a SimpleDB instance.\nconst sdb = new SimpleDB();\n\n// We create a new table\nconst fires = sdb.newTable(\"fires\");\n// We fetch the wildfires data. It's a csv.\nawait fires.loadData(\n  \"data/firesCanada2023.csv\",\n);\n\n// We summarize to count the number of fires\n// and sum up the area burnt in each province.\nawait fires.summarize({\n  values: \"hectares\",\n  categories: \"province\",\n  summaries: [\"count\", \"sum\"],\n  decimals: 0,\n});\n// We rename columns.\nawait fires.renameColumns({\n  count: \"nbFires\",\n  sum: \"burntArea\",\n});\n// We want the province with\n// the greatest burnt area first.\nawait fires.sort({ burntArea: \"desc\" });\n\n// We log the results. By default, the method\n// logs the first 10 rows, but there is 13\n// rows in our data. We also log the data types.\nawait fires.logTable({ nbRowsToLog: 13, types: true });\n\n// And we can write the data to a parquet, json or csv file.\nawait fires.writeData(\"./fires.parquet\");\n\n// We close everything.\nawait sdb.done();\n```\n\nReturn your response as a JSON object with the following structure:\n{\n  \"data\": [\n    { \"question\": \"question1\", \"answer\": \"answer1\" },\n    { \"question\": \"question2\", \"answer\": \"answer2\" },\n    ...\n  ]\n}\n\nHere's the documentation section:\n\n\n#### `updateWithJS`\n\nUpdates data in the table using a JavaScript function. The function receives the\nexisting rows as an array of objects and must return the modified rows as an\narray of objects. This method offers high flexibility for data manipulation but\ncan be slow for large tables as it involves transferring data between DuckDB and\nJavaScript. This method does not work with tables containing geometries.\n\n##### Signature\n\n```typescript\nasync updateWithJS(dataModifier: ((rows: Record<string, number | string | Date | boolean | null>[]) => any) | ((rows: Record<string, number | string | Date | boolean | null>[]) => any)): Promise<void>;\n```\n\n##### Parameters\n\n- **`dataModifier`**: - A synchronous or asynchronous function that takes the\n  existing rows (as an array of objects) and returns the modified rows (as an\n  array of objects).\n\n##### Returns\n\nA promise that resolves when the data has been updated.\n\n##### Examples\n\n```ts\n// Add 1 to values in 'column1'. If values are not numbers, they are replaced by null.\nawait table.updateWithJS((rows) => {\n  const modifiedRows = rows.map((d) => ({\n    ...d,\n    column1: typeof d.column1 === \"number\" ? d.column1 + 1 : null,\n  }));\n  return modifiedRows;\n});\n```\n\n```ts\n// Convert a date string to a Date object in 'dateColumn'\nawait table.updateWithJS((rows) => {\n  const modifiedRows = rows.map((d) => ({\n    ...d,\n    dateColumn: typeof d.dateColumn === \"string\"\n      ? new Date(d.dateColumn)\n      : d.dateColumn,\n  }));\n  return modifiedRows;\n});\n```"
  },
  {
    "model": "qwen3:30b",
    "prompt": "Your task is to generate a set of up to 10 relevant questions and answers based on the provided section of documentation. The questions should be those a junior developer or data analyst might have.\n\nFor each question, you must provide a code example as the answer. You can add comments to the code to explain the steps. A brief, one-sentence explanation may be included in a comment if the code alone is not a sufficient answer.\n\nThe questions must be directly related to the documentation section provided below and must not ask about topics outside its scope. The answer should be grounded in the documentation provided. Do not make assumptions.\n\nWrite simple and straightforward code examples. Don't create functions to encapsulate your code.\n\nYour answers should always be wrapped in triple backticks (```ts at the beginning and ``` at the end) for code blocks.\n\nIf the documentation section is about SimpleDB, make sure to wrap your answer with:\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\nconst sdb = new SimpleDB();\n[PUT THE CODE EXAMPLE HERE. IF THERE IS NO CODE TO ADD, JUST ADD A COMMENT SAYING \"Do your magic here!\"]\nawait sdb.done();\n```\n\nIf the documentation section is about SimpleTable, make sure to wrap your answer with:\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\nconst sdb = new SimpleDB();\nconst table = sdb.newTable();\nawait table.loadData(\"path/to/your/data.csv\"); // Remove this line if not needed or change the file extension if relevant\n[PUT THE CODE EXAMPLE HERE. IF THERE IS NO CODE TO ADD, JUST ADD A COMMENT SAYING \"Do your magic here!\"]\nawait sdb.done();\n```\n\nIf you need inspiration, here is a comprehensive example with comments.\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\n\n// We start a SimpleDB instance.\nconst sdb = new SimpleDB();\n\n// We create a new table\nconst fires = sdb.newTable(\"fires\");\n// We fetch the wildfires data. It's a csv.\nawait fires.loadData(\n  \"data/firesCanada2023.csv\",\n);\n\n// We summarize to count the number of fires\n// and sum up the area burnt in each province.\nawait fires.summarize({\n  values: \"hectares\",\n  categories: \"province\",\n  summaries: [\"count\", \"sum\"],\n  decimals: 0,\n});\n// We rename columns.\nawait fires.renameColumns({\n  count: \"nbFires\",\n  sum: \"burntArea\",\n});\n// We want the province with\n// the greatest burnt area first.\nawait fires.sort({ burntArea: \"desc\" });\n\n// We log the results. By default, the method\n// logs the first 10 rows, but there is 13\n// rows in our data. We also log the data types.\nawait fires.logTable({ nbRowsToLog: 13, types: true });\n\n// And we can write the data to a parquet, json or csv file.\nawait fires.writeData(\"./fires.parquet\");\n\n// We close everything.\nawait sdb.done();\n```\n\nReturn your response as a JSON object with the following structure:\n{\n  \"data\": [\n    { \"question\": \"question1\", \"answer\": \"answer1\" },\n    { \"question\": \"question2\", \"answer\": \"answer2\" },\n    ...\n  ]\n}\n\nHere's the documentation section:\n\n\n#### `getSchema`\n\nReturns the schema of the table, including column names and their data types.\n\n##### Signature\n\n```typescript\nasync getSchema(): Promise<Record<string, string | null>[]>;\n```\n\n##### Returns\n\nA promise that resolves to an array of objects, where each object represents a\ncolumn with its name and data type.\n\n##### Examples\n\n```ts\n// Get the schema of the table\nconst schema = await table.getSchema();\nconsole.table(schema); // Log the schema in a readable table format\n```"
  },
  {
    "model": "qwen3:30b",
    "prompt": "Your task is to generate a set of up to 10 relevant questions and answers based on the provided section of documentation. The questions should be those a junior developer or data analyst might have.\n\nFor each question, you must provide a code example as the answer. You can add comments to the code to explain the steps. A brief, one-sentence explanation may be included in a comment if the code alone is not a sufficient answer.\n\nThe questions must be directly related to the documentation section provided below and must not ask about topics outside its scope. The answer should be grounded in the documentation provided. Do not make assumptions.\n\nWrite simple and straightforward code examples. Don't create functions to encapsulate your code.\n\nYour answers should always be wrapped in triple backticks (```ts at the beginning and ``` at the end) for code blocks.\n\nIf the documentation section is about SimpleDB, make sure to wrap your answer with:\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\nconst sdb = new SimpleDB();\n[PUT THE CODE EXAMPLE HERE. IF THERE IS NO CODE TO ADD, JUST ADD A COMMENT SAYING \"Do your magic here!\"]\nawait sdb.done();\n```\n\nIf the documentation section is about SimpleTable, make sure to wrap your answer with:\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\nconst sdb = new SimpleDB();\nconst table = sdb.newTable();\nawait table.loadData(\"path/to/your/data.csv\"); // Remove this line if not needed or change the file extension if relevant\n[PUT THE CODE EXAMPLE HERE. IF THERE IS NO CODE TO ADD, JUST ADD A COMMENT SAYING \"Do your magic here!\"]\nawait sdb.done();\n```\n\nIf you need inspiration, here is a comprehensive example with comments.\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\n\n// We start a SimpleDB instance.\nconst sdb = new SimpleDB();\n\n// We create a new table\nconst fires = sdb.newTable(\"fires\");\n// We fetch the wildfires data. It's a csv.\nawait fires.loadData(\n  \"data/firesCanada2023.csv\",\n);\n\n// We summarize to count the number of fires\n// and sum up the area burnt in each province.\nawait fires.summarize({\n  values: \"hectares\",\n  categories: \"province\",\n  summaries: [\"count\", \"sum\"],\n  decimals: 0,\n});\n// We rename columns.\nawait fires.renameColumns({\n  count: \"nbFires\",\n  sum: \"burntArea\",\n});\n// We want the province with\n// the greatest burnt area first.\nawait fires.sort({ burntArea: \"desc\" });\n\n// We log the results. By default, the method\n// logs the first 10 rows, but there is 13\n// rows in our data. We also log the data types.\nawait fires.logTable({ nbRowsToLog: 13, types: true });\n\n// And we can write the data to a parquet, json or csv file.\nawait fires.writeData(\"./fires.parquet\");\n\n// We close everything.\nawait sdb.done();\n```\n\nReturn your response as a JSON object with the following structure:\n{\n  \"data\": [\n    { \"question\": \"question1\", \"answer\": \"answer1\" },\n    { \"question\": \"question2\", \"answer\": \"answer2\" },\n    ...\n  ]\n}\n\nHere's the documentation section:\n\n\n#### `getDescription`\n\nReturns descriptive statistical information about the columns, including details\nlike data types, number of null values, and distinct values.\n\n##### Signature\n\n```typescript\nasync getDescription(): Promise<Record<string, unknown>[]>;\n```\n\n##### Returns\n\nA promise that resolves to an array of objects, each representing descriptive\nstatistics for a column.\n\n##### Examples\n\n```ts\n// Get and log descriptive information about the table's columns\nconst description = await table.getDescription();\nconsole.table(description);\n```"
  },
  {
    "model": "qwen3:30b",
    "prompt": "Your task is to generate a set of up to 10 relevant questions and answers based on the provided section of documentation. The questions should be those a junior developer or data analyst might have.\n\nFor each question, you must provide a code example as the answer. You can add comments to the code to explain the steps. A brief, one-sentence explanation may be included in a comment if the code alone is not a sufficient answer.\n\nThe questions must be directly related to the documentation section provided below and must not ask about topics outside its scope. The answer should be grounded in the documentation provided. Do not make assumptions.\n\nWrite simple and straightforward code examples. Don't create functions to encapsulate your code.\n\nYour answers should always be wrapped in triple backticks (```ts at the beginning and ``` at the end) for code blocks.\n\nIf the documentation section is about SimpleDB, make sure to wrap your answer with:\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\nconst sdb = new SimpleDB();\n[PUT THE CODE EXAMPLE HERE. IF THERE IS NO CODE TO ADD, JUST ADD A COMMENT SAYING \"Do your magic here!\"]\nawait sdb.done();\n```\n\nIf the documentation section is about SimpleTable, make sure to wrap your answer with:\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\nconst sdb = new SimpleDB();\nconst table = sdb.newTable();\nawait table.loadData(\"path/to/your/data.csv\"); // Remove this line if not needed or change the file extension if relevant\n[PUT THE CODE EXAMPLE HERE. IF THERE IS NO CODE TO ADD, JUST ADD A COMMENT SAYING \"Do your magic here!\"]\nawait sdb.done();\n```\n\nIf you need inspiration, here is a comprehensive example with comments.\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\n\n// We start a SimpleDB instance.\nconst sdb = new SimpleDB();\n\n// We create a new table\nconst fires = sdb.newTable(\"fires\");\n// We fetch the wildfires data. It's a csv.\nawait fires.loadData(\n  \"data/firesCanada2023.csv\",\n);\n\n// We summarize to count the number of fires\n// and sum up the area burnt in each province.\nawait fires.summarize({\n  values: \"hectares\",\n  categories: \"province\",\n  summaries: [\"count\", \"sum\"],\n  decimals: 0,\n});\n// We rename columns.\nawait fires.renameColumns({\n  count: \"nbFires\",\n  sum: \"burntArea\",\n});\n// We want the province with\n// the greatest burnt area first.\nawait fires.sort({ burntArea: \"desc\" });\n\n// We log the results. By default, the method\n// logs the first 10 rows, but there is 13\n// rows in our data. We also log the data types.\nawait fires.logTable({ nbRowsToLog: 13, types: true });\n\n// And we can write the data to a parquet, json or csv file.\nawait fires.writeData(\"./fires.parquet\");\n\n// We close everything.\nawait sdb.done();\n```\n\nReturn your response as a JSON object with the following structure:\n{\n  \"data\": [\n    { \"question\": \"question1\", \"answer\": \"answer1\" },\n    { \"question\": \"question2\", \"answer\": \"answer2\" },\n    ...\n  ]\n}\n\nHere's the documentation section:\n\n\n#### `getColumns`\n\nReturns a list of all column names in the table.\n\n##### Signature\n\n```typescript\nasync getColumns(): Promise<string[]>;\n```\n\n##### Returns\n\nA promise that resolves to an array of strings, where each string is a column\nname.\n\n##### Examples\n\n```ts\n// Get all column names from the table\nconst columns = await table.getColumns();\nconsole.log(columns); // e.g., [\"id\", \"name\", \"age\"]\n```"
  },
  {
    "model": "qwen3:30b",
    "prompt": "Your task is to generate a set of up to 10 relevant questions and answers based on the provided section of documentation. The questions should be those a junior developer or data analyst might have.\n\nFor each question, you must provide a code example as the answer. You can add comments to the code to explain the steps. A brief, one-sentence explanation may be included in a comment if the code alone is not a sufficient answer.\n\nThe questions must be directly related to the documentation section provided below and must not ask about topics outside its scope. The answer should be grounded in the documentation provided. Do not make assumptions.\n\nWrite simple and straightforward code examples. Don't create functions to encapsulate your code.\n\nYour answers should always be wrapped in triple backticks (```ts at the beginning and ``` at the end) for code blocks.\n\nIf the documentation section is about SimpleDB, make sure to wrap your answer with:\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\nconst sdb = new SimpleDB();\n[PUT THE CODE EXAMPLE HERE. IF THERE IS NO CODE TO ADD, JUST ADD A COMMENT SAYING \"Do your magic here!\"]\nawait sdb.done();\n```\n\nIf the documentation section is about SimpleTable, make sure to wrap your answer with:\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\nconst sdb = new SimpleDB();\nconst table = sdb.newTable();\nawait table.loadData(\"path/to/your/data.csv\"); // Remove this line if not needed or change the file extension if relevant\n[PUT THE CODE EXAMPLE HERE. IF THERE IS NO CODE TO ADD, JUST ADD A COMMENT SAYING \"Do your magic here!\"]\nawait sdb.done();\n```\n\nIf you need inspiration, here is a comprehensive example with comments.\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\n\n// We start a SimpleDB instance.\nconst sdb = new SimpleDB();\n\n// We create a new table\nconst fires = sdb.newTable(\"fires\");\n// We fetch the wildfires data. It's a csv.\nawait fires.loadData(\n  \"data/firesCanada2023.csv\",\n);\n\n// We summarize to count the number of fires\n// and sum up the area burnt in each province.\nawait fires.summarize({\n  values: \"hectares\",\n  categories: \"province\",\n  summaries: [\"count\", \"sum\"],\n  decimals: 0,\n});\n// We rename columns.\nawait fires.renameColumns({\n  count: \"nbFires\",\n  sum: \"burntArea\",\n});\n// We want the province with\n// the greatest burnt area first.\nawait fires.sort({ burntArea: \"desc\" });\n\n// We log the results. By default, the method\n// logs the first 10 rows, but there is 13\n// rows in our data. We also log the data types.\nawait fires.logTable({ nbRowsToLog: 13, types: true });\n\n// And we can write the data to a parquet, json or csv file.\nawait fires.writeData(\"./fires.parquet\");\n\n// We close everything.\nawait sdb.done();\n```\n\nReturn your response as a JSON object with the following structure:\n{\n  \"data\": [\n    { \"question\": \"question1\", \"answer\": \"answer1\" },\n    { \"question\": \"question2\", \"answer\": \"answer2\" },\n    ...\n  ]\n}\n\nHere's the documentation section:\n\n\n#### `getNbColumns`\n\nReturns the number of columns in the table.\n\n##### Signature\n\n```typescript\nasync getNbColumns(): Promise<number>;\n```\n\n##### Returns\n\nA promise that resolves to a number representing the total count of columns.\n\n##### Examples\n\n```ts\n// Get the number of columns in the table\nconst nbColumns = await table.getNbColumns();\nconsole.log(nbColumns); // e.g., 3\n```"
  },
  {
    "model": "qwen3:30b",
    "prompt": "Your task is to generate a set of up to 10 relevant questions and answers based on the provided section of documentation. The questions should be those a junior developer or data analyst might have.\n\nFor each question, you must provide a code example as the answer. You can add comments to the code to explain the steps. A brief, one-sentence explanation may be included in a comment if the code alone is not a sufficient answer.\n\nThe questions must be directly related to the documentation section provided below and must not ask about topics outside its scope. The answer should be grounded in the documentation provided. Do not make assumptions.\n\nWrite simple and straightforward code examples. Don't create functions to encapsulate your code.\n\nYour answers should always be wrapped in triple backticks (```ts at the beginning and ``` at the end) for code blocks.\n\nIf the documentation section is about SimpleDB, make sure to wrap your answer with:\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\nconst sdb = new SimpleDB();\n[PUT THE CODE EXAMPLE HERE. IF THERE IS NO CODE TO ADD, JUST ADD A COMMENT SAYING \"Do your magic here!\"]\nawait sdb.done();\n```\n\nIf the documentation section is about SimpleTable, make sure to wrap your answer with:\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\nconst sdb = new SimpleDB();\nconst table = sdb.newTable();\nawait table.loadData(\"path/to/your/data.csv\"); // Remove this line if not needed or change the file extension if relevant\n[PUT THE CODE EXAMPLE HERE. IF THERE IS NO CODE TO ADD, JUST ADD A COMMENT SAYING \"Do your magic here!\"]\nawait sdb.done();\n```\n\nIf you need inspiration, here is a comprehensive example with comments.\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\n\n// We start a SimpleDB instance.\nconst sdb = new SimpleDB();\n\n// We create a new table\nconst fires = sdb.newTable(\"fires\");\n// We fetch the wildfires data. It's a csv.\nawait fires.loadData(\n  \"data/firesCanada2023.csv\",\n);\n\n// We summarize to count the number of fires\n// and sum up the area burnt in each province.\nawait fires.summarize({\n  values: \"hectares\",\n  categories: \"province\",\n  summaries: [\"count\", \"sum\"],\n  decimals: 0,\n});\n// We rename columns.\nawait fires.renameColumns({\n  count: \"nbFires\",\n  sum: \"burntArea\",\n});\n// We want the province with\n// the greatest burnt area first.\nawait fires.sort({ burntArea: \"desc\" });\n\n// We log the results. By default, the method\n// logs the first 10 rows, but there is 13\n// rows in our data. We also log the data types.\nawait fires.logTable({ nbRowsToLog: 13, types: true });\n\n// And we can write the data to a parquet, json or csv file.\nawait fires.writeData(\"./fires.parquet\");\n\n// We close everything.\nawait sdb.done();\n```\n\nReturn your response as a JSON object with the following structure:\n{\n  \"data\": [\n    { \"question\": \"question1\", \"answer\": \"answer1\" },\n    { \"question\": \"question2\", \"answer\": \"answer2\" },\n    ...\n  ]\n}\n\nHere's the documentation section:\n\n\n#### `getNbRows`\n\nReturns the number of rows in the table.\n\n##### Signature\n\n```typescript\nasync getNbRows(): Promise<number>;\n```\n\n##### Returns\n\nA promise that resolves to a number representing the total count of rows.\n\n##### Examples\n\n```ts\n// Get the number of rows in the table\nconst nbRows = await table.getNbRows();\nconsole.log(nbRows); // e.g., 100\n```"
  },
  {
    "model": "qwen3:30b",
    "prompt": "Your task is to generate a set of up to 10 relevant questions and answers based on the provided section of documentation. The questions should be those a junior developer or data analyst might have.\n\nFor each question, you must provide a code example as the answer. You can add comments to the code to explain the steps. A brief, one-sentence explanation may be included in a comment if the code alone is not a sufficient answer.\n\nThe questions must be directly related to the documentation section provided below and must not ask about topics outside its scope. The answer should be grounded in the documentation provided. Do not make assumptions.\n\nWrite simple and straightforward code examples. Don't create functions to encapsulate your code.\n\nYour answers should always be wrapped in triple backticks (```ts at the beginning and ``` at the end) for code blocks.\n\nIf the documentation section is about SimpleDB, make sure to wrap your answer with:\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\nconst sdb = new SimpleDB();\n[PUT THE CODE EXAMPLE HERE. IF THERE IS NO CODE TO ADD, JUST ADD A COMMENT SAYING \"Do your magic here!\"]\nawait sdb.done();\n```\n\nIf the documentation section is about SimpleTable, make sure to wrap your answer with:\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\nconst sdb = new SimpleDB();\nconst table = sdb.newTable();\nawait table.loadData(\"path/to/your/data.csv\"); // Remove this line if not needed or change the file extension if relevant\n[PUT THE CODE EXAMPLE HERE. IF THERE IS NO CODE TO ADD, JUST ADD A COMMENT SAYING \"Do your magic here!\"]\nawait sdb.done();\n```\n\nIf you need inspiration, here is a comprehensive example with comments.\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\n\n// We start a SimpleDB instance.\nconst sdb = new SimpleDB();\n\n// We create a new table\nconst fires = sdb.newTable(\"fires\");\n// We fetch the wildfires data. It's a csv.\nawait fires.loadData(\n  \"data/firesCanada2023.csv\",\n);\n\n// We summarize to count the number of fires\n// and sum up the area burnt in each province.\nawait fires.summarize({\n  values: \"hectares\",\n  categories: \"province\",\n  summaries: [\"count\", \"sum\"],\n  decimals: 0,\n});\n// We rename columns.\nawait fires.renameColumns({\n  count: \"nbFires\",\n  sum: \"burntArea\",\n});\n// We want the province with\n// the greatest burnt area first.\nawait fires.sort({ burntArea: \"desc\" });\n\n// We log the results. By default, the method\n// logs the first 10 rows, but there is 13\n// rows in our data. We also log the data types.\nawait fires.logTable({ nbRowsToLog: 13, types: true });\n\n// And we can write the data to a parquet, json or csv file.\nawait fires.writeData(\"./fires.parquet\");\n\n// We close everything.\nawait sdb.done();\n```\n\nReturn your response as a JSON object with the following structure:\n{\n  \"data\": [\n    { \"question\": \"question1\", \"answer\": \"answer1\" },\n    { \"question\": \"question2\", \"answer\": \"answer2\" },\n    ...\n  ]\n}\n\nHere's the documentation section:\n\n\n#### `getNbValues`\n\nReturns the total number of values in the table (number of columns multiplied by\nthe number of rows).\n\n##### Signature\n\n```typescript\nasync getNbValues(): Promise<number>;\n```\n\n##### Returns\n\nA promise that resolves to a number representing the total count of values.\n\n##### Examples\n\n```ts\n// Get the total number of values in the table\nconst nbValues = await table.getNbValues();\nconsole.log(nbValues); // e.g., 300 (if 3 columns and 100 rows)\n```"
  },
  {
    "model": "qwen3:30b",
    "prompt": "Your task is to generate a set of up to 10 relevant questions and answers based on the provided section of documentation. The questions should be those a junior developer or data analyst might have.\n\nFor each question, you must provide a code example as the answer. You can add comments to the code to explain the steps. A brief, one-sentence explanation may be included in a comment if the code alone is not a sufficient answer.\n\nThe questions must be directly related to the documentation section provided below and must not ask about topics outside its scope. The answer should be grounded in the documentation provided. Do not make assumptions.\n\nWrite simple and straightforward code examples. Don't create functions to encapsulate your code.\n\nYour answers should always be wrapped in triple backticks (```ts at the beginning and ``` at the end) for code blocks.\n\nIf the documentation section is about SimpleDB, make sure to wrap your answer with:\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\nconst sdb = new SimpleDB();\n[PUT THE CODE EXAMPLE HERE. IF THERE IS NO CODE TO ADD, JUST ADD A COMMENT SAYING \"Do your magic here!\"]\nawait sdb.done();\n```\n\nIf the documentation section is about SimpleTable, make sure to wrap your answer with:\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\nconst sdb = new SimpleDB();\nconst table = sdb.newTable();\nawait table.loadData(\"path/to/your/data.csv\"); // Remove this line if not needed or change the file extension if relevant\n[PUT THE CODE EXAMPLE HERE. IF THERE IS NO CODE TO ADD, JUST ADD A COMMENT SAYING \"Do your magic here!\"]\nawait sdb.done();\n```\n\nIf you need inspiration, here is a comprehensive example with comments.\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\n\n// We start a SimpleDB instance.\nconst sdb = new SimpleDB();\n\n// We create a new table\nconst fires = sdb.newTable(\"fires\");\n// We fetch the wildfires data. It's a csv.\nawait fires.loadData(\n  \"data/firesCanada2023.csv\",\n);\n\n// We summarize to count the number of fires\n// and sum up the area burnt in each province.\nawait fires.summarize({\n  values: \"hectares\",\n  categories: \"province\",\n  summaries: [\"count\", \"sum\"],\n  decimals: 0,\n});\n// We rename columns.\nawait fires.renameColumns({\n  count: \"nbFires\",\n  sum: \"burntArea\",\n});\n// We want the province with\n// the greatest burnt area first.\nawait fires.sort({ burntArea: \"desc\" });\n\n// We log the results. By default, the method\n// logs the first 10 rows, but there is 13\n// rows in our data. We also log the data types.\nawait fires.logTable({ nbRowsToLog: 13, types: true });\n\n// And we can write the data to a parquet, json or csv file.\nawait fires.writeData(\"./fires.parquet\");\n\n// We close everything.\nawait sdb.done();\n```\n\nReturn your response as a JSON object with the following structure:\n{\n  \"data\": [\n    { \"question\": \"question1\", \"answer\": \"answer1\" },\n    { \"question\": \"question2\", \"answer\": \"answer2\" },\n    ...\n  ]\n}\n\nHere's the documentation section:\n\n\n#### `getTypes`\n\nReturns the data types of all columns in the table.\n\n##### Signature\n\n```typescript\nasync getTypes(): Promise<Record<string, string>>;\n```\n\n##### Returns\n\nA promise that resolves to an object where keys are column names and values are\ntheir corresponding data types (e.g., `{ \"id\": \"BIGINT\", \"name\": \"VARCHAR\" }`).\n\n##### Examples\n\n```ts\n// Get the data types of all columns\nconst dataTypes = await table.getTypes();\nconsole.log(dataTypes);\n```"
  },
  {
    "model": "qwen3:30b",
    "prompt": "Your task is to generate a set of up to 10 relevant questions and answers based on the provided section of documentation. The questions should be those a junior developer or data analyst might have.\n\nFor each question, you must provide a code example as the answer. You can add comments to the code to explain the steps. A brief, one-sentence explanation may be included in a comment if the code alone is not a sufficient answer.\n\nThe questions must be directly related to the documentation section provided below and must not ask about topics outside its scope. The answer should be grounded in the documentation provided. Do not make assumptions.\n\nWrite simple and straightforward code examples. Don't create functions to encapsulate your code.\n\nYour answers should always be wrapped in triple backticks (```ts at the beginning and ``` at the end) for code blocks.\n\nIf the documentation section is about SimpleDB, make sure to wrap your answer with:\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\nconst sdb = new SimpleDB();\n[PUT THE CODE EXAMPLE HERE. IF THERE IS NO CODE TO ADD, JUST ADD A COMMENT SAYING \"Do your magic here!\"]\nawait sdb.done();\n```\n\nIf the documentation section is about SimpleTable, make sure to wrap your answer with:\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\nconst sdb = new SimpleDB();\nconst table = sdb.newTable();\nawait table.loadData(\"path/to/your/data.csv\"); // Remove this line if not needed or change the file extension if relevant\n[PUT THE CODE EXAMPLE HERE. IF THERE IS NO CODE TO ADD, JUST ADD A COMMENT SAYING \"Do your magic here!\"]\nawait sdb.done();\n```\n\nIf you need inspiration, here is a comprehensive example with comments.\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\n\n// We start a SimpleDB instance.\nconst sdb = new SimpleDB();\n\n// We create a new table\nconst fires = sdb.newTable(\"fires\");\n// We fetch the wildfires data. It's a csv.\nawait fires.loadData(\n  \"data/firesCanada2023.csv\",\n);\n\n// We summarize to count the number of fires\n// and sum up the area burnt in each province.\nawait fires.summarize({\n  values: \"hectares\",\n  categories: \"province\",\n  summaries: [\"count\", \"sum\"],\n  decimals: 0,\n});\n// We rename columns.\nawait fires.renameColumns({\n  count: \"nbFires\",\n  sum: \"burntArea\",\n});\n// We want the province with\n// the greatest burnt area first.\nawait fires.sort({ burntArea: \"desc\" });\n\n// We log the results. By default, the method\n// logs the first 10 rows, but there is 13\n// rows in our data. We also log the data types.\nawait fires.logTable({ nbRowsToLog: 13, types: true });\n\n// And we can write the data to a parquet, json or csv file.\nawait fires.writeData(\"./fires.parquet\");\n\n// We close everything.\nawait sdb.done();\n```\n\nReturn your response as a JSON object with the following structure:\n{\n  \"data\": [\n    { \"question\": \"question1\", \"answer\": \"answer1\" },\n    { \"question\": \"question2\", \"answer\": \"answer2\" },\n    ...\n  ]\n}\n\nHere's the documentation section:\n\n\n#### `getValues`\n\nReturns all values from a specific column.\n\n##### Signature\n\n```typescript\nasync getValues(column: string): Promise<(string | number | boolean | Date | null)[]>;\n```\n\n##### Parameters\n\n- **`column`**: - The name of the column from which to retrieve values.\n\n##### Returns\n\nA promise that resolves to an array containing all values from the specified\ncolumn.\n\n##### Examples\n\n```ts\n// Get all values from the 'productName' column\nconst productNames = await table.getValues(\"productName\");\nconsole.log(productNames); // e.g., [\"Laptop\", \"Mouse\", \"Keyboard\"]\n```"
  },
  {
    "model": "qwen3:30b",
    "prompt": "Your task is to generate a set of up to 10 relevant questions and answers based on the provided section of documentation. The questions should be those a junior developer or data analyst might have.\n\nFor each question, you must provide a code example as the answer. You can add comments to the code to explain the steps. A brief, one-sentence explanation may be included in a comment if the code alone is not a sufficient answer.\n\nThe questions must be directly related to the documentation section provided below and must not ask about topics outside its scope. The answer should be grounded in the documentation provided. Do not make assumptions.\n\nWrite simple and straightforward code examples. Don't create functions to encapsulate your code.\n\nYour answers should always be wrapped in triple backticks (```ts at the beginning and ``` at the end) for code blocks.\n\nIf the documentation section is about SimpleDB, make sure to wrap your answer with:\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\nconst sdb = new SimpleDB();\n[PUT THE CODE EXAMPLE HERE. IF THERE IS NO CODE TO ADD, JUST ADD A COMMENT SAYING \"Do your magic here!\"]\nawait sdb.done();\n```\n\nIf the documentation section is about SimpleTable, make sure to wrap your answer with:\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\nconst sdb = new SimpleDB();\nconst table = sdb.newTable();\nawait table.loadData(\"path/to/your/data.csv\"); // Remove this line if not needed or change the file extension if relevant\n[PUT THE CODE EXAMPLE HERE. IF THERE IS NO CODE TO ADD, JUST ADD A COMMENT SAYING \"Do your magic here!\"]\nawait sdb.done();\n```\n\nIf you need inspiration, here is a comprehensive example with comments.\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\n\n// We start a SimpleDB instance.\nconst sdb = new SimpleDB();\n\n// We create a new table\nconst fires = sdb.newTable(\"fires\");\n// We fetch the wildfires data. It's a csv.\nawait fires.loadData(\n  \"data/firesCanada2023.csv\",\n);\n\n// We summarize to count the number of fires\n// and sum up the area burnt in each province.\nawait fires.summarize({\n  values: \"hectares\",\n  categories: \"province\",\n  summaries: [\"count\", \"sum\"],\n  decimals: 0,\n});\n// We rename columns.\nawait fires.renameColumns({\n  count: \"nbFires\",\n  sum: \"burntArea\",\n});\n// We want the province with\n// the greatest burnt area first.\nawait fires.sort({ burntArea: \"desc\" });\n\n// We log the results. By default, the method\n// logs the first 10 rows, but there is 13\n// rows in our data. We also log the data types.\nawait fires.logTable({ nbRowsToLog: 13, types: true });\n\n// And we can write the data to a parquet, json or csv file.\nawait fires.writeData(\"./fires.parquet\");\n\n// We close everything.\nawait sdb.done();\n```\n\nReturn your response as a JSON object with the following structure:\n{\n  \"data\": [\n    { \"question\": \"question1\", \"answer\": \"answer1\" },\n    { \"question\": \"question2\", \"answer\": \"answer2\" },\n    ...\n  ]\n}\n\nHere's the documentation section:\n\n\n#### `getMin`\n\nReturns the minimum value from a specific column.\n\n##### Signature\n\n```typescript\nasync getMin(column: string): Promise<string | number | boolean | Date | null>;\n```\n\n##### Parameters\n\n- **`column`**: - The name of the column from which to retrieve the minimum\n  value.\n\n##### Returns\n\nA promise that resolves to the minimum value of the specified column.\n\n##### Examples\n\n```ts\n// Get the minimum value from the 'price' column\nconst minPrice = await table.getMin(\"price\");\nconsole.log(minPrice); // e.g., 10.50\n```"
  },
  {
    "model": "qwen3:30b",
    "prompt": "Your task is to generate a set of up to 10 relevant questions and answers based on the provided section of documentation. The questions should be those a junior developer or data analyst might have.\n\nFor each question, you must provide a code example as the answer. You can add comments to the code to explain the steps. A brief, one-sentence explanation may be included in a comment if the code alone is not a sufficient answer.\n\nThe questions must be directly related to the documentation section provided below and must not ask about topics outside its scope. The answer should be grounded in the documentation provided. Do not make assumptions.\n\nWrite simple and straightforward code examples. Don't create functions to encapsulate your code.\n\nYour answers should always be wrapped in triple backticks (```ts at the beginning and ``` at the end) for code blocks.\n\nIf the documentation section is about SimpleDB, make sure to wrap your answer with:\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\nconst sdb = new SimpleDB();\n[PUT THE CODE EXAMPLE HERE. IF THERE IS NO CODE TO ADD, JUST ADD A COMMENT SAYING \"Do your magic here!\"]\nawait sdb.done();\n```\n\nIf the documentation section is about SimpleTable, make sure to wrap your answer with:\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\nconst sdb = new SimpleDB();\nconst table = sdb.newTable();\nawait table.loadData(\"path/to/your/data.csv\"); // Remove this line if not needed or change the file extension if relevant\n[PUT THE CODE EXAMPLE HERE. IF THERE IS NO CODE TO ADD, JUST ADD A COMMENT SAYING \"Do your magic here!\"]\nawait sdb.done();\n```\n\nIf you need inspiration, here is a comprehensive example with comments.\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\n\n// We start a SimpleDB instance.\nconst sdb = new SimpleDB();\n\n// We create a new table\nconst fires = sdb.newTable(\"fires\");\n// We fetch the wildfires data. It's a csv.\nawait fires.loadData(\n  \"data/firesCanada2023.csv\",\n);\n\n// We summarize to count the number of fires\n// and sum up the area burnt in each province.\nawait fires.summarize({\n  values: \"hectares\",\n  categories: \"province\",\n  summaries: [\"count\", \"sum\"],\n  decimals: 0,\n});\n// We rename columns.\nawait fires.renameColumns({\n  count: \"nbFires\",\n  sum: \"burntArea\",\n});\n// We want the province with\n// the greatest burnt area first.\nawait fires.sort({ burntArea: \"desc\" });\n\n// We log the results. By default, the method\n// logs the first 10 rows, but there is 13\n// rows in our data. We also log the data types.\nawait fires.logTable({ nbRowsToLog: 13, types: true });\n\n// And we can write the data to a parquet, json or csv file.\nawait fires.writeData(\"./fires.parquet\");\n\n// We close everything.\nawait sdb.done();\n```\n\nReturn your response as a JSON object with the following structure:\n{\n  \"data\": [\n    { \"question\": \"question1\", \"answer\": \"answer1\" },\n    { \"question\": \"question2\", \"answer\": \"answer2\" },\n    ...\n  ]\n}\n\nHere's the documentation section:\n\n\n#### `getMax`\n\nReturns the maximum value from a specific column.\n\n##### Signature\n\n```typescript\nasync getMax(column: string): Promise<string | number | boolean | Date | null>;\n```\n\n##### Parameters\n\n- **`column`**: - The name of the column from which to retrieve the maximum\n  value.\n\n##### Returns\n\nA promise that resolves to the maximum value of the specified column.\n\n##### Examples\n\n```ts\n// Get the maximum value from the 'price' column\nconst maxPrice = await table.getMax(\"price\");\nconsole.log(maxPrice); // e.g., 99.99\n```"
  },
  {
    "model": "qwen3:30b",
    "prompt": "Your task is to generate a set of up to 10 relevant questions and answers based on the provided section of documentation. The questions should be those a junior developer or data analyst might have.\n\nFor each question, you must provide a code example as the answer. You can add comments to the code to explain the steps. A brief, one-sentence explanation may be included in a comment if the code alone is not a sufficient answer.\n\nThe questions must be directly related to the documentation section provided below and must not ask about topics outside its scope. The answer should be grounded in the documentation provided. Do not make assumptions.\n\nWrite simple and straightforward code examples. Don't create functions to encapsulate your code.\n\nYour answers should always be wrapped in triple backticks (```ts at the beginning and ``` at the end) for code blocks.\n\nIf the documentation section is about SimpleDB, make sure to wrap your answer with:\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\nconst sdb = new SimpleDB();\n[PUT THE CODE EXAMPLE HERE. IF THERE IS NO CODE TO ADD, JUST ADD A COMMENT SAYING \"Do your magic here!\"]\nawait sdb.done();\n```\n\nIf the documentation section is about SimpleTable, make sure to wrap your answer with:\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\nconst sdb = new SimpleDB();\nconst table = sdb.newTable();\nawait table.loadData(\"path/to/your/data.csv\"); // Remove this line if not needed or change the file extension if relevant\n[PUT THE CODE EXAMPLE HERE. IF THERE IS NO CODE TO ADD, JUST ADD A COMMENT SAYING \"Do your magic here!\"]\nawait sdb.done();\n```\n\nIf you need inspiration, here is a comprehensive example with comments.\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\n\n// We start a SimpleDB instance.\nconst sdb = new SimpleDB();\n\n// We create a new table\nconst fires = sdb.newTable(\"fires\");\n// We fetch the wildfires data. It's a csv.\nawait fires.loadData(\n  \"data/firesCanada2023.csv\",\n);\n\n// We summarize to count the number of fires\n// and sum up the area burnt in each province.\nawait fires.summarize({\n  values: \"hectares\",\n  categories: \"province\",\n  summaries: [\"count\", \"sum\"],\n  decimals: 0,\n});\n// We rename columns.\nawait fires.renameColumns({\n  count: \"nbFires\",\n  sum: \"burntArea\",\n});\n// We want the province with\n// the greatest burnt area first.\nawait fires.sort({ burntArea: \"desc\" });\n\n// We log the results. By default, the method\n// logs the first 10 rows, but there is 13\n// rows in our data. We also log the data types.\nawait fires.logTable({ nbRowsToLog: 13, types: true });\n\n// And we can write the data to a parquet, json or csv file.\nawait fires.writeData(\"./fires.parquet\");\n\n// We close everything.\nawait sdb.done();\n```\n\nReturn your response as a JSON object with the following structure:\n{\n  \"data\": [\n    { \"question\": \"question1\", \"answer\": \"answer1\" },\n    { \"question\": \"question2\", \"answer\": \"answer2\" },\n    ...\n  ]\n}\n\nHere's the documentation section:\n\n\n#### `getQuantile`\n\nReturns the value of a specific quantile from the values in a given numeric\ncolumn.\n\n##### Signature\n\n```typescript\nasync getQuantile(column: string, quantile: number, options?: { decimals?: number }): Promise<number>;\n```\n\n##### Parameters\n\n- **`column`**: - The name of the numeric column from which to calculate the\n  quantile.\n- **`quantile`**: - The quantile to calculate, expressed as a number between 0\n  and 1 (e.g., `0.25` for the first quartile, `0.5` for the median, `0.75` for\n  the third quartile).\n- **`options`**: - An optional object with configuration options:\n- **`options.decimals`**: - The number of decimal places to round the result to.\n  Defaults to `undefined` (no rounding).\n\n##### Returns\n\nA promise that resolves to the quantile value of the specified column.\n\n##### Examples\n\n```ts\n// Get the first quartile (25th percentile) of 'column1'\nconst firstQuartile = await table.getQuantile(\"column1\", 0.25);\nconsole.log(firstQuartile); // e.g., 15.7\n```\n\n```ts\n// Get the 90th percentile of 'score' values, rounded to 2 decimal places\nconst ninetiethPercentile = await table.getQuantile(\"score\", 0.9, {\n  decimals: 2,\n});\nconsole.log(ninetiethPercentile); // e.g., 88.55\n```"
  },
  {
    "model": "qwen3:30b",
    "prompt": "Your task is to generate a set of up to 10 relevant questions and answers based on the provided section of documentation. The questions should be those a junior developer or data analyst might have.\n\nFor each question, you must provide a code example as the answer. You can add comments to the code to explain the steps. A brief, one-sentence explanation may be included in a comment if the code alone is not a sufficient answer.\n\nThe questions must be directly related to the documentation section provided below and must not ask about topics outside its scope. The answer should be grounded in the documentation provided. Do not make assumptions.\n\nWrite simple and straightforward code examples. Don't create functions to encapsulate your code.\n\nYour answers should always be wrapped in triple backticks (```ts at the beginning and ``` at the end) for code blocks.\n\nIf the documentation section is about SimpleDB, make sure to wrap your answer with:\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\nconst sdb = new SimpleDB();\n[PUT THE CODE EXAMPLE HERE. IF THERE IS NO CODE TO ADD, JUST ADD A COMMENT SAYING \"Do your magic here!\"]\nawait sdb.done();\n```\n\nIf the documentation section is about SimpleTable, make sure to wrap your answer with:\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\nconst sdb = new SimpleDB();\nconst table = sdb.newTable();\nawait table.loadData(\"path/to/your/data.csv\"); // Remove this line if not needed or change the file extension if relevant\n[PUT THE CODE EXAMPLE HERE. IF THERE IS NO CODE TO ADD, JUST ADD A COMMENT SAYING \"Do your magic here!\"]\nawait sdb.done();\n```\n\nIf you need inspiration, here is a comprehensive example with comments.\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\n\n// We start a SimpleDB instance.\nconst sdb = new SimpleDB();\n\n// We create a new table\nconst fires = sdb.newTable(\"fires\");\n// We fetch the wildfires data. It's a csv.\nawait fires.loadData(\n  \"data/firesCanada2023.csv\",\n);\n\n// We summarize to count the number of fires\n// and sum up the area burnt in each province.\nawait fires.summarize({\n  values: \"hectares\",\n  categories: \"province\",\n  summaries: [\"count\", \"sum\"],\n  decimals: 0,\n});\n// We rename columns.\nawait fires.renameColumns({\n  count: \"nbFires\",\n  sum: \"burntArea\",\n});\n// We want the province with\n// the greatest burnt area first.\nawait fires.sort({ burntArea: \"desc\" });\n\n// We log the results. By default, the method\n// logs the first 10 rows, but there is 13\n// rows in our data. We also log the data types.\nawait fires.logTable({ nbRowsToLog: 13, types: true });\n\n// And we can write the data to a parquet, json or csv file.\nawait fires.writeData(\"./fires.parquet\");\n\n// We close everything.\nawait sdb.done();\n```\n\nReturn your response as a JSON object with the following structure:\n{\n  \"data\": [\n    { \"question\": \"question1\", \"answer\": \"answer1\" },\n    { \"question\": \"question2\", \"answer\": \"answer2\" },\n    ...\n  ]\n}\n\nHere's the documentation section:\n\n\n#### `getUniques`\n\nReturns unique values from a specific column. The values are returned in\nascending order.\n\n##### Signature\n\n```typescript\nasync getUniques(column: string): Promise<(string | number | boolean | Date | null)[]>;\n```\n\n##### Parameters\n\n- **`column`**: - The name of the column from which to retrieve unique values.\n\n##### Returns\n\nA promise that resolves to an array containing the unique values from the\nspecified column, sorted in ascending order.\n\n##### Examples\n\n```ts\n// Get unique values from the 'category' column\nconst uniqueCategories = await table.getUniques(\"category\");\nconsole.log(uniqueCategories); // e.g., [\"Books\", \"Clothing\", \"Electronics\"]\n```"
  },
  {
    "model": "qwen3:30b",
    "prompt": "Your task is to generate a set of up to 10 relevant questions and answers based on the provided section of documentation. The questions should be those a junior developer or data analyst might have.\n\nFor each question, you must provide a code example as the answer. You can add comments to the code to explain the steps. A brief, one-sentence explanation may be included in a comment if the code alone is not a sufficient answer.\n\nThe questions must be directly related to the documentation section provided below and must not ask about topics outside its scope. The answer should be grounded in the documentation provided. Do not make assumptions.\n\nWrite simple and straightforward code examples. Don't create functions to encapsulate your code.\n\nYour answers should always be wrapped in triple backticks (```ts at the beginning and ``` at the end) for code blocks.\n\nIf the documentation section is about SimpleDB, make sure to wrap your answer with:\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\nconst sdb = new SimpleDB();\n[PUT THE CODE EXAMPLE HERE. IF THERE IS NO CODE TO ADD, JUST ADD A COMMENT SAYING \"Do your magic here!\"]\nawait sdb.done();\n```\n\nIf the documentation section is about SimpleTable, make sure to wrap your answer with:\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\nconst sdb = new SimpleDB();\nconst table = sdb.newTable();\nawait table.loadData(\"path/to/your/data.csv\"); // Remove this line if not needed or change the file extension if relevant\n[PUT THE CODE EXAMPLE HERE. IF THERE IS NO CODE TO ADD, JUST ADD A COMMENT SAYING \"Do your magic here!\"]\nawait sdb.done();\n```\n\nIf you need inspiration, here is a comprehensive example with comments.\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\n\n// We start a SimpleDB instance.\nconst sdb = new SimpleDB();\n\n// We create a new table\nconst fires = sdb.newTable(\"fires\");\n// We fetch the wildfires data. It's a csv.\nawait fires.loadData(\n  \"data/firesCanada2023.csv\",\n);\n\n// We summarize to count the number of fires\n// and sum up the area burnt in each province.\nawait fires.summarize({\n  values: \"hectares\",\n  categories: \"province\",\n  summaries: [\"count\", \"sum\"],\n  decimals: 0,\n});\n// We rename columns.\nawait fires.renameColumns({\n  count: \"nbFires\",\n  sum: \"burntArea\",\n});\n// We want the province with\n// the greatest burnt area first.\nawait fires.sort({ burntArea: \"desc\" });\n\n// We log the results. By default, the method\n// logs the first 10 rows, but there is 13\n// rows in our data. We also log the data types.\nawait fires.logTable({ nbRowsToLog: 13, types: true });\n\n// And we can write the data to a parquet, json or csv file.\nawait fires.writeData(\"./fires.parquet\");\n\n// We close everything.\nawait sdb.done();\n```\n\nReturn your response as a JSON object with the following structure:\n{\n  \"data\": [\n    { \"question\": \"question1\", \"answer\": \"answer1\" },\n    { \"question\": \"question2\", \"answer\": \"answer2\" },\n    ...\n  ]\n}\n\nHere's the documentation section:\n\n\n#### `getRow`\n\nReturns a single row that matches the specified conditions. If no row matches or\nif more than one row matches, an error is thrown by default. You can also use\nJavaScript syntax for conditions (e.g., `AND`, `||`, `===`, `!==`).\n\n##### Signature\n\n```typescript\nasync getRow(conditions: string, options?: { noCheck?: boolean }): Promise<Record<string, string | number | boolean | Date | null> | undefined>;\n```\n\n##### Parameters\n\n- **`conditions`**: - The conditions to match, specified as a SQL `WHERE`\n  clause.\n- **`options`**: - Optional settings:\n- **`options.noCheck`**: - If `true`, no error will be thrown when no row or\n  more than one row match the condition. Defaults to `false`.\n\n##### Returns\n\nA promise that resolves to an object representing the matched row.\n\n##### Examples\n\n```ts\n// Get a row where 'name' is 'John'\nconst johnsRow = await table.getRow(`name = 'John'`);\nconsole.log(johnsRow);\n```\n\n```ts\n// Get a row where 'id' is 123 (using JS syntax)\nconst rowById = await table.getRow(`id === 123`);\nconsole.log(rowById);\n```\n\n```ts\n// Get a row without throwing an error if multiple matches or no match\nconst flexibleRow = await table.getRow(`status = 'pending'`, { noCheck: true });\nconsole.log(flexibleRow);\n```"
  },
  {
    "model": "qwen3:30b",
    "prompt": "Your task is to generate a set of up to 10 relevant questions and answers based on the provided section of documentation. The questions should be those a junior developer or data analyst might have.\n\nFor each question, you must provide a code example as the answer. You can add comments to the code to explain the steps. A brief, one-sentence explanation may be included in a comment if the code alone is not a sufficient answer.\n\nThe questions must be directly related to the documentation section provided below and must not ask about topics outside its scope. The answer should be grounded in the documentation provided. Do not make assumptions.\n\nWrite simple and straightforward code examples. Don't create functions to encapsulate your code.\n\nYour answers should always be wrapped in triple backticks (```ts at the beginning and ``` at the end) for code blocks.\n\nIf the documentation section is about SimpleDB, make sure to wrap your answer with:\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\nconst sdb = new SimpleDB();\n[PUT THE CODE EXAMPLE HERE. IF THERE IS NO CODE TO ADD, JUST ADD A COMMENT SAYING \"Do your magic here!\"]\nawait sdb.done();\n```\n\nIf the documentation section is about SimpleTable, make sure to wrap your answer with:\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\nconst sdb = new SimpleDB();\nconst table = sdb.newTable();\nawait table.loadData(\"path/to/your/data.csv\"); // Remove this line if not needed or change the file extension if relevant\n[PUT THE CODE EXAMPLE HERE. IF THERE IS NO CODE TO ADD, JUST ADD A COMMENT SAYING \"Do your magic here!\"]\nawait sdb.done();\n```\n\nIf you need inspiration, here is a comprehensive example with comments.\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\n\n// We start a SimpleDB instance.\nconst sdb = new SimpleDB();\n\n// We create a new table\nconst fires = sdb.newTable(\"fires\");\n// We fetch the wildfires data. It's a csv.\nawait fires.loadData(\n  \"data/firesCanada2023.csv\",\n);\n\n// We summarize to count the number of fires\n// and sum up the area burnt in each province.\nawait fires.summarize({\n  values: \"hectares\",\n  categories: \"province\",\n  summaries: [\"count\", \"sum\"],\n  decimals: 0,\n});\n// We rename columns.\nawait fires.renameColumns({\n  count: \"nbFires\",\n  sum: \"burntArea\",\n});\n// We want the province with\n// the greatest burnt area first.\nawait fires.sort({ burntArea: \"desc\" });\n\n// We log the results. By default, the method\n// logs the first 10 rows, but there is 13\n// rows in our data. We also log the data types.\nawait fires.logTable({ nbRowsToLog: 13, types: true });\n\n// And we can write the data to a parquet, json or csv file.\nawait fires.writeData(\"./fires.parquet\");\n\n// We close everything.\nawait sdb.done();\n```\n\nReturn your response as a JSON object with the following structure:\n{\n  \"data\": [\n    { \"question\": \"question1\", \"answer\": \"answer1\" },\n    { \"question\": \"question2\", \"answer\": \"answer2\" },\n    ...\n  ]\n}\n\nHere's the documentation section:\n\n\n#### `points`\n\nCreates point geometries from longitude and latitude columns. The geometries\nwill have `[latitude, longitude]` axis order.\n\n##### Signature\n\n```typescript\nasync points(columnLat: string, columnLon: string, newColumn: string): Promise<void>;\n```\n\n##### Parameters\n\n- **`columnLat`**: - The name of the column storing the latitude values.\n- **`columnLon`**: - The name of the column storing the longitude values.\n- **`newColumn`**: - The name of the new column where the point geometries will\n  be stored.\n\n##### Returns\n\nA promise that resolves when the point geometries have been created.\n\n##### Examples\n\n```ts\n// Create point geometries in a new 'geom' column using 'lat' and 'lon' columns\nawait table.points(\"lat\", \"lon\", \"geom\");\n```"
  },
  {
    "model": "qwen3:30b",
    "prompt": "Your task is to generate a set of up to 10 relevant questions and answers based on the provided section of documentation. The questions should be those a junior developer or data analyst might have.\n\nFor each question, you must provide a code example as the answer. You can add comments to the code to explain the steps. A brief, one-sentence explanation may be included in a comment if the code alone is not a sufficient answer.\n\nThe questions must be directly related to the documentation section provided below and must not ask about topics outside its scope. The answer should be grounded in the documentation provided. Do not make assumptions.\n\nWrite simple and straightforward code examples. Don't create functions to encapsulate your code.\n\nYour answers should always be wrapped in triple backticks (```ts at the beginning and ``` at the end) for code blocks.\n\nIf the documentation section is about SimpleDB, make sure to wrap your answer with:\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\nconst sdb = new SimpleDB();\n[PUT THE CODE EXAMPLE HERE. IF THERE IS NO CODE TO ADD, JUST ADD A COMMENT SAYING \"Do your magic here!\"]\nawait sdb.done();\n```\n\nIf the documentation section is about SimpleTable, make sure to wrap your answer with:\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\nconst sdb = new SimpleDB();\nconst table = sdb.newTable();\nawait table.loadData(\"path/to/your/data.csv\"); // Remove this line if not needed or change the file extension if relevant\n[PUT THE CODE EXAMPLE HERE. IF THERE IS NO CODE TO ADD, JUST ADD A COMMENT SAYING \"Do your magic here!\"]\nawait sdb.done();\n```\n\nIf you need inspiration, here is a comprehensive example with comments.\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\n\n// We start a SimpleDB instance.\nconst sdb = new SimpleDB();\n\n// We create a new table\nconst fires = sdb.newTable(\"fires\");\n// We fetch the wildfires data. It's a csv.\nawait fires.loadData(\n  \"data/firesCanada2023.csv\",\n);\n\n// We summarize to count the number of fires\n// and sum up the area burnt in each province.\nawait fires.summarize({\n  values: \"hectares\",\n  categories: \"province\",\n  summaries: [\"count\", \"sum\"],\n  decimals: 0,\n});\n// We rename columns.\nawait fires.renameColumns({\n  count: \"nbFires\",\n  sum: \"burntArea\",\n});\n// We want the province with\n// the greatest burnt area first.\nawait fires.sort({ burntArea: \"desc\" });\n\n// We log the results. By default, the method\n// logs the first 10 rows, but there is 13\n// rows in our data. We also log the data types.\nawait fires.logTable({ nbRowsToLog: 13, types: true });\n\n// And we can write the data to a parquet, json or csv file.\nawait fires.writeData(\"./fires.parquet\");\n\n// We close everything.\nawait sdb.done();\n```\n\nReturn your response as a JSON object with the following structure:\n{\n  \"data\": [\n    { \"question\": \"question1\", \"answer\": \"answer1\" },\n    { \"question\": \"question2\", \"answer\": \"answer2\" },\n    ...\n  ]\n}\n\nHere's the documentation section:\n\n\n#### `isValidGeo`\n\nAdds a column with boolean values indicating the validity of geometries.\n\n##### Signature\n\n```typescript\nasync isValidGeo(newColumn: string, options?: { column?: string }): Promise<void>;\n```\n\n##### Parameters\n\n- **`newColumn`**: - The name of the new column where the boolean results\n  (`TRUE` for valid, `FALSE` for invalid) will be stored.\n- **`options`**: - An optional object with configuration options:\n- **`options.column`**: - The name of the column storing the geometries to be\n  checked. If omitted, the method will automatically attempt to find a geometry\n  column.\n\n##### Returns\n\nA promise that resolves when the validity check is complete.\n\n##### Examples\n\n```ts\n// Check if geometries are valid and store results in a new 'isValid' column\n// The method will automatically detect the geometry column.\nawait table.isValidGeo(\"isValid\");\n```\n\n```ts\n// Check validity of geometries in a specific column named 'myGeom'\nawait table.isValidGeo(\"isValidMyGeom\", { column: \"myGeom\" });\n```"
  },
  {
    "model": "qwen3:30b",
    "prompt": "Your task is to generate a set of up to 10 relevant questions and answers based on the provided section of documentation. The questions should be those a junior developer or data analyst might have.\n\nFor each question, you must provide a code example as the answer. You can add comments to the code to explain the steps. A brief, one-sentence explanation may be included in a comment if the code alone is not a sufficient answer.\n\nThe questions must be directly related to the documentation section provided below and must not ask about topics outside its scope. The answer should be grounded in the documentation provided. Do not make assumptions.\n\nWrite simple and straightforward code examples. Don't create functions to encapsulate your code.\n\nYour answers should always be wrapped in triple backticks (```ts at the beginning and ``` at the end) for code blocks.\n\nIf the documentation section is about SimpleDB, make sure to wrap your answer with:\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\nconst sdb = new SimpleDB();\n[PUT THE CODE EXAMPLE HERE. IF THERE IS NO CODE TO ADD, JUST ADD A COMMENT SAYING \"Do your magic here!\"]\nawait sdb.done();\n```\n\nIf the documentation section is about SimpleTable, make sure to wrap your answer with:\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\nconst sdb = new SimpleDB();\nconst table = sdb.newTable();\nawait table.loadData(\"path/to/your/data.csv\"); // Remove this line if not needed or change the file extension if relevant\n[PUT THE CODE EXAMPLE HERE. IF THERE IS NO CODE TO ADD, JUST ADD A COMMENT SAYING \"Do your magic here!\"]\nawait sdb.done();\n```\n\nIf you need inspiration, here is a comprehensive example with comments.\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\n\n// We start a SimpleDB instance.\nconst sdb = new SimpleDB();\n\n// We create a new table\nconst fires = sdb.newTable(\"fires\");\n// We fetch the wildfires data. It's a csv.\nawait fires.loadData(\n  \"data/firesCanada2023.csv\",\n);\n\n// We summarize to count the number of fires\n// and sum up the area burnt in each province.\nawait fires.summarize({\n  values: \"hectares\",\n  categories: \"province\",\n  summaries: [\"count\", \"sum\"],\n  decimals: 0,\n});\n// We rename columns.\nawait fires.renameColumns({\n  count: \"nbFires\",\n  sum: \"burntArea\",\n});\n// We want the province with\n// the greatest burnt area first.\nawait fires.sort({ burntArea: \"desc\" });\n\n// We log the results. By default, the method\n// logs the first 10 rows, but there is 13\n// rows in our data. We also log the data types.\nawait fires.logTable({ nbRowsToLog: 13, types: true });\n\n// And we can write the data to a parquet, json or csv file.\nawait fires.writeData(\"./fires.parquet\");\n\n// We close everything.\nawait sdb.done();\n```\n\nReturn your response as a JSON object with the following structure:\n{\n  \"data\": [\n    { \"question\": \"question1\", \"answer\": \"answer1\" },\n    { \"question\": \"question2\", \"answer\": \"answer2\" },\n    ...\n  ]\n}\n\nHere's the documentation section:\n\n\n#### `nbVertices`\n\nAdds a column with the number of vertices (points) in each geometry.\n\n##### Signature\n\n```typescript\nasync nbVertices(newColumn: string, options?: { column?: string }): Promise<void>;\n```\n\n##### Parameters\n\n- **`newColumn`**: - The name of the new column where the vertex counts will be\n  stored.\n- **`options`**: - An optional object with configuration options:\n- **`options.column`**: - The name of the column storing the geometries. If\n  omitted, the method will automatically attempt to find a geometry column.\n\n##### Returns\n\nA promise that resolves when the vertex counts have been added.\n\n##### Examples\n\n```ts\n// Add a new column 'vertexCount' with the number of vertices for each geometry\n// The method will automatically detect the geometry column.\nawait table.nbVertices(\"vertexCount\");\n```\n\n```ts\n// Add vertex counts for geometries in a specific column named 'myGeom'\nawait table.nbVertices(\"myGeomVertices\", { column: \"myGeom\" });\n```"
  },
  {
    "model": "qwen3:30b",
    "prompt": "Your task is to generate a set of up to 10 relevant questions and answers based on the provided section of documentation. The questions should be those a junior developer or data analyst might have.\n\nFor each question, you must provide a code example as the answer. You can add comments to the code to explain the steps. A brief, one-sentence explanation may be included in a comment if the code alone is not a sufficient answer.\n\nThe questions must be directly related to the documentation section provided below and must not ask about topics outside its scope. The answer should be grounded in the documentation provided. Do not make assumptions.\n\nWrite simple and straightforward code examples. Don't create functions to encapsulate your code.\n\nYour answers should always be wrapped in triple backticks (```ts at the beginning and ``` at the end) for code blocks.\n\nIf the documentation section is about SimpleDB, make sure to wrap your answer with:\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\nconst sdb = new SimpleDB();\n[PUT THE CODE EXAMPLE HERE. IF THERE IS NO CODE TO ADD, JUST ADD A COMMENT SAYING \"Do your magic here!\"]\nawait sdb.done();\n```\n\nIf the documentation section is about SimpleTable, make sure to wrap your answer with:\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\nconst sdb = new SimpleDB();\nconst table = sdb.newTable();\nawait table.loadData(\"path/to/your/data.csv\"); // Remove this line if not needed or change the file extension if relevant\n[PUT THE CODE EXAMPLE HERE. IF THERE IS NO CODE TO ADD, JUST ADD A COMMENT SAYING \"Do your magic here!\"]\nawait sdb.done();\n```\n\nIf you need inspiration, here is a comprehensive example with comments.\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\n\n// We start a SimpleDB instance.\nconst sdb = new SimpleDB();\n\n// We create a new table\nconst fires = sdb.newTable(\"fires\");\n// We fetch the wildfires data. It's a csv.\nawait fires.loadData(\n  \"data/firesCanada2023.csv\",\n);\n\n// We summarize to count the number of fires\n// and sum up the area burnt in each province.\nawait fires.summarize({\n  values: \"hectares\",\n  categories: \"province\",\n  summaries: [\"count\", \"sum\"],\n  decimals: 0,\n});\n// We rename columns.\nawait fires.renameColumns({\n  count: \"nbFires\",\n  sum: \"burntArea\",\n});\n// We want the province with\n// the greatest burnt area first.\nawait fires.sort({ burntArea: \"desc\" });\n\n// We log the results. By default, the method\n// logs the first 10 rows, but there is 13\n// rows in our data. We also log the data types.\nawait fires.logTable({ nbRowsToLog: 13, types: true });\n\n// And we can write the data to a parquet, json or csv file.\nawait fires.writeData(\"./fires.parquet\");\n\n// We close everything.\nawait sdb.done();\n```\n\nReturn your response as a JSON object with the following structure:\n{\n  \"data\": [\n    { \"question\": \"question1\", \"answer\": \"answer1\" },\n    { \"question\": \"question2\", \"answer\": \"answer2\" },\n    ...\n  ]\n}\n\nHere's the documentation section:\n\n\n#### `fixGeo`\n\nAttempts to make invalid geometries valid without removing any vertices.\n\n##### Signature\n\n```typescript\nasync fixGeo(column?: string): Promise<void>;\n```\n\n##### Parameters\n\n- **`column`**: - The name of the column storing the geometries to be fixed. If\n  omitted, the method will automatically attempt to find a geometry column.\n\n##### Returns\n\nA promise that resolves when the geometries have been processed.\n\n##### Examples\n\n```ts\n// Fix invalid geometries in the default geometry column\nawait table.fixGeo();\n```\n\n```ts\n// Fix invalid geometries in a specific column named 'myGeom'\nawait table.fixGeo(\"myGeom\");\n```"
  },
  {
    "model": "qwen3:30b",
    "prompt": "Your task is to generate a set of up to 10 relevant questions and answers based on the provided section of documentation. The questions should be those a junior developer or data analyst might have.\n\nFor each question, you must provide a code example as the answer. You can add comments to the code to explain the steps. A brief, one-sentence explanation may be included in a comment if the code alone is not a sufficient answer.\n\nThe questions must be directly related to the documentation section provided below and must not ask about topics outside its scope. The answer should be grounded in the documentation provided. Do not make assumptions.\n\nWrite simple and straightforward code examples. Don't create functions to encapsulate your code.\n\nYour answers should always be wrapped in triple backticks (```ts at the beginning and ``` at the end) for code blocks.\n\nIf the documentation section is about SimpleDB, make sure to wrap your answer with:\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\nconst sdb = new SimpleDB();\n[PUT THE CODE EXAMPLE HERE. IF THERE IS NO CODE TO ADD, JUST ADD A COMMENT SAYING \"Do your magic here!\"]\nawait sdb.done();\n```\n\nIf the documentation section is about SimpleTable, make sure to wrap your answer with:\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\nconst sdb = new SimpleDB();\nconst table = sdb.newTable();\nawait table.loadData(\"path/to/your/data.csv\"); // Remove this line if not needed or change the file extension if relevant\n[PUT THE CODE EXAMPLE HERE. IF THERE IS NO CODE TO ADD, JUST ADD A COMMENT SAYING \"Do your magic here!\"]\nawait sdb.done();\n```\n\nIf you need inspiration, here is a comprehensive example with comments.\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\n\n// We start a SimpleDB instance.\nconst sdb = new SimpleDB();\n\n// We create a new table\nconst fires = sdb.newTable(\"fires\");\n// We fetch the wildfires data. It's a csv.\nawait fires.loadData(\n  \"data/firesCanada2023.csv\",\n);\n\n// We summarize to count the number of fires\n// and sum up the area burnt in each province.\nawait fires.summarize({\n  values: \"hectares\",\n  categories: \"province\",\n  summaries: [\"count\", \"sum\"],\n  decimals: 0,\n});\n// We rename columns.\nawait fires.renameColumns({\n  count: \"nbFires\",\n  sum: \"burntArea\",\n});\n// We want the province with\n// the greatest burnt area first.\nawait fires.sort({ burntArea: \"desc\" });\n\n// We log the results. By default, the method\n// logs the first 10 rows, but there is 13\n// rows in our data. We also log the data types.\nawait fires.logTable({ nbRowsToLog: 13, types: true });\n\n// And we can write the data to a parquet, json or csv file.\nawait fires.writeData(\"./fires.parquet\");\n\n// We close everything.\nawait sdb.done();\n```\n\nReturn your response as a JSON object with the following structure:\n{\n  \"data\": [\n    { \"question\": \"question1\", \"answer\": \"answer1\" },\n    { \"question\": \"question2\", \"answer\": \"answer2\" },\n    ...\n  ]\n}\n\nHere's the documentation section:\n\n\n#### `isClosedGeo`\n\nAdds a column with boolean values indicating whether geometries are closed\n(e.g., polygons) or open (e.g., linestrings).\n\n##### Signature\n\n```typescript\nasync isClosedGeo(newColumn: string, options?: { column?: string }): Promise<void>;\n```\n\n##### Parameters\n\n- **`newColumn`**: - The name of the new column where the boolean results\n  (`TRUE` for closed, `FALSE` for open) will be stored.\n- **`options`**: - An optional object with configuration options:\n- **`options.column`**: - The name of the column storing the geometries. If\n  omitted, the method will automatically attempt to find a geometry column.\n\n##### Returns\n\nA promise that resolves when the closed geometry check is complete.\n\n##### Examples\n\n```ts\n// Check if geometries are closed and store results in a new 'isClosed' column\nawait table.isClosedGeo(\"isClosed\");\n```\n\n```ts\n// Check closed status of geometries in a specific column named 'boundaryGeom'\nawait table.isClosedGeo(\"boundaryClosed\", { column: \"boundaryGeom\" });\n```"
  },
  {
    "model": "qwen3:30b",
    "prompt": "Your task is to generate a set of up to 10 relevant questions and answers based on the provided section of documentation. The questions should be those a junior developer or data analyst might have.\n\nFor each question, you must provide a code example as the answer. You can add comments to the code to explain the steps. A brief, one-sentence explanation may be included in a comment if the code alone is not a sufficient answer.\n\nThe questions must be directly related to the documentation section provided below and must not ask about topics outside its scope. The answer should be grounded in the documentation provided. Do not make assumptions.\n\nWrite simple and straightforward code examples. Don't create functions to encapsulate your code.\n\nYour answers should always be wrapped in triple backticks (```ts at the beginning and ``` at the end) for code blocks.\n\nIf the documentation section is about SimpleDB, make sure to wrap your answer with:\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\nconst sdb = new SimpleDB();\n[PUT THE CODE EXAMPLE HERE. IF THERE IS NO CODE TO ADD, JUST ADD A COMMENT SAYING \"Do your magic here!\"]\nawait sdb.done();\n```\n\nIf the documentation section is about SimpleTable, make sure to wrap your answer with:\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\nconst sdb = new SimpleDB();\nconst table = sdb.newTable();\nawait table.loadData(\"path/to/your/data.csv\"); // Remove this line if not needed or change the file extension if relevant\n[PUT THE CODE EXAMPLE HERE. IF THERE IS NO CODE TO ADD, JUST ADD A COMMENT SAYING \"Do your magic here!\"]\nawait sdb.done();\n```\n\nIf you need inspiration, here is a comprehensive example with comments.\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\n\n// We start a SimpleDB instance.\nconst sdb = new SimpleDB();\n\n// We create a new table\nconst fires = sdb.newTable(\"fires\");\n// We fetch the wildfires data. It's a csv.\nawait fires.loadData(\n  \"data/firesCanada2023.csv\",\n);\n\n// We summarize to count the number of fires\n// and sum up the area burnt in each province.\nawait fires.summarize({\n  values: \"hectares\",\n  categories: \"province\",\n  summaries: [\"count\", \"sum\"],\n  decimals: 0,\n});\n// We rename columns.\nawait fires.renameColumns({\n  count: \"nbFires\",\n  sum: \"burntArea\",\n});\n// We want the province with\n// the greatest burnt area first.\nawait fires.sort({ burntArea: \"desc\" });\n\n// We log the results. By default, the method\n// logs the first 10 rows, but there is 13\n// rows in our data. We also log the data types.\nawait fires.logTable({ nbRowsToLog: 13, types: true });\n\n// And we can write the data to a parquet, json or csv file.\nawait fires.writeData(\"./fires.parquet\");\n\n// We close everything.\nawait sdb.done();\n```\n\nReturn your response as a JSON object with the following structure:\n{\n  \"data\": [\n    { \"question\": \"question1\", \"answer\": \"answer1\" },\n    { \"question\": \"question2\", \"answer\": \"answer2\" },\n    ...\n  ]\n}\n\nHere's the documentation section:\n\n\n#### `typeGeo`\n\nAdds a column with the geometry type (e.g., `\"POINT\"`, `\"LINESTRING\"`,\n`\"POLYGON\"`) for each geometry.\n\n##### Signature\n\n```typescript\nasync typeGeo(newColumn: string, options?: { column?: string }): Promise<void>;\n```\n\n##### Parameters\n\n- **`newColumn`**: - The name of the new column where the geometry types will be\n  stored.\n- **`options`**: - An optional object with configuration options:\n- **`options.column`**: - The name of the column storing the geometries. If\n  omitted, the method will automatically attempt to find a geometry column.\n\n##### Returns\n\nA promise that resolves when the geometry types have been added.\n\n##### Examples\n\n```ts\n// Add a new column 'geometryType' with the type of each geometry\nawait table.typeGeo(\"geometryType\");\n```\n\n```ts\n// Get the geometry type for geometries in a specific column named 'featureGeom'\nawait table.typeGeo(\"featureType\", { column: \"featureGeom\" });\n```"
  },
  {
    "model": "qwen3:30b",
    "prompt": "Your task is to generate a set of up to 10 relevant questions and answers based on the provided section of documentation. The questions should be those a junior developer or data analyst might have.\n\nFor each question, you must provide a code example as the answer. You can add comments to the code to explain the steps. A brief, one-sentence explanation may be included in a comment if the code alone is not a sufficient answer.\n\nThe questions must be directly related to the documentation section provided below and must not ask about topics outside its scope. The answer should be grounded in the documentation provided. Do not make assumptions.\n\nWrite simple and straightforward code examples. Don't create functions to encapsulate your code.\n\nYour answers should always be wrapped in triple backticks (```ts at the beginning and ``` at the end) for code blocks.\n\nIf the documentation section is about SimpleDB, make sure to wrap your answer with:\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\nconst sdb = new SimpleDB();\n[PUT THE CODE EXAMPLE HERE. IF THERE IS NO CODE TO ADD, JUST ADD A COMMENT SAYING \"Do your magic here!\"]\nawait sdb.done();\n```\n\nIf the documentation section is about SimpleTable, make sure to wrap your answer with:\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\nconst sdb = new SimpleDB();\nconst table = sdb.newTable();\nawait table.loadData(\"path/to/your/data.csv\"); // Remove this line if not needed or change the file extension if relevant\n[PUT THE CODE EXAMPLE HERE. IF THERE IS NO CODE TO ADD, JUST ADD A COMMENT SAYING \"Do your magic here!\"]\nawait sdb.done();\n```\n\nIf you need inspiration, here is a comprehensive example with comments.\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\n\n// We start a SimpleDB instance.\nconst sdb = new SimpleDB();\n\n// We create a new table\nconst fires = sdb.newTable(\"fires\");\n// We fetch the wildfires data. It's a csv.\nawait fires.loadData(\n  \"data/firesCanada2023.csv\",\n);\n\n// We summarize to count the number of fires\n// and sum up the area burnt in each province.\nawait fires.summarize({\n  values: \"hectares\",\n  categories: \"province\",\n  summaries: [\"count\", \"sum\"],\n  decimals: 0,\n});\n// We rename columns.\nawait fires.renameColumns({\n  count: \"nbFires\",\n  sum: \"burntArea\",\n});\n// We want the province with\n// the greatest burnt area first.\nawait fires.sort({ burntArea: \"desc\" });\n\n// We log the results. By default, the method\n// logs the first 10 rows, but there is 13\n// rows in our data. We also log the data types.\nawait fires.logTable({ nbRowsToLog: 13, types: true });\n\n// And we can write the data to a parquet, json or csv file.\nawait fires.writeData(\"./fires.parquet\");\n\n// We close everything.\nawait sdb.done();\n```\n\nReturn your response as a JSON object with the following structure:\n{\n  \"data\": [\n    { \"question\": \"question1\", \"answer\": \"answer1\" },\n    { \"question\": \"question2\", \"answer\": \"answer2\" },\n    ...\n  ]\n}\n\nHere's the documentation section:\n\n\n#### `flipCoordinates`\n\nFlips the coordinate order of geometries in a specified column (e.g., from\n`[lon, lat]` to `[lat, lon]` or vice-versa). **Warning:** This method should be\nused with caution as it directly manipulates coordinate order and can affect the\naccuracy of geospatial operations if not used correctly. It also messes up with\nthe projections stored in `table.projections`.\n\n##### Signature\n\n```typescript\nasync flipCoordinates(column?: string): Promise<void>;\n```\n\n##### Parameters\n\n- **`column`**: - The name of the column storing the geometries. If omitted, the\n  method will automatically attempt to find a geometry column.\n\n##### Returns\n\nA promise that resolves when the coordinates have been flipped.\n\n##### Examples\n\n```ts\n// Flip coordinates in the default geometry column\nawait table.flipCoordinates();\n```\n\n```ts\n// Flip coordinates in a specific column named 'myGeom'\nawait table.flipCoordinates(\"myGeom\");\n```"
  },
  {
    "model": "qwen3:30b",
    "prompt": "Your task is to generate a set of up to 10 relevant questions and answers based on the provided section of documentation. The questions should be those a junior developer or data analyst might have.\n\nFor each question, you must provide a code example as the answer. You can add comments to the code to explain the steps. A brief, one-sentence explanation may be included in a comment if the code alone is not a sufficient answer.\n\nThe questions must be directly related to the documentation section provided below and must not ask about topics outside its scope. The answer should be grounded in the documentation provided. Do not make assumptions.\n\nWrite simple and straightforward code examples. Don't create functions to encapsulate your code.\n\nYour answers should always be wrapped in triple backticks (```ts at the beginning and ``` at the end) for code blocks.\n\nIf the documentation section is about SimpleDB, make sure to wrap your answer with:\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\nconst sdb = new SimpleDB();\n[PUT THE CODE EXAMPLE HERE. IF THERE IS NO CODE TO ADD, JUST ADD A COMMENT SAYING \"Do your magic here!\"]\nawait sdb.done();\n```\n\nIf the documentation section is about SimpleTable, make sure to wrap your answer with:\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\nconst sdb = new SimpleDB();\nconst table = sdb.newTable();\nawait table.loadData(\"path/to/your/data.csv\"); // Remove this line if not needed or change the file extension if relevant\n[PUT THE CODE EXAMPLE HERE. IF THERE IS NO CODE TO ADD, JUST ADD A COMMENT SAYING \"Do your magic here!\"]\nawait sdb.done();\n```\n\nIf you need inspiration, here is a comprehensive example with comments.\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\n\n// We start a SimpleDB instance.\nconst sdb = new SimpleDB();\n\n// We create a new table\nconst fires = sdb.newTable(\"fires\");\n// We fetch the wildfires data. It's a csv.\nawait fires.loadData(\n  \"data/firesCanada2023.csv\",\n);\n\n// We summarize to count the number of fires\n// and sum up the area burnt in each province.\nawait fires.summarize({\n  values: \"hectares\",\n  categories: \"province\",\n  summaries: [\"count\", \"sum\"],\n  decimals: 0,\n});\n// We rename columns.\nawait fires.renameColumns({\n  count: \"nbFires\",\n  sum: \"burntArea\",\n});\n// We want the province with\n// the greatest burnt area first.\nawait fires.sort({ burntArea: \"desc\" });\n\n// We log the results. By default, the method\n// logs the first 10 rows, but there is 13\n// rows in our data. We also log the data types.\nawait fires.logTable({ nbRowsToLog: 13, types: true });\n\n// And we can write the data to a parquet, json or csv file.\nawait fires.writeData(\"./fires.parquet\");\n\n// We close everything.\nawait sdb.done();\n```\n\nReturn your response as a JSON object with the following structure:\n{\n  \"data\": [\n    { \"question\": \"question1\", \"answer\": \"answer1\" },\n    { \"question\": \"question2\", \"answer\": \"answer2\" },\n    ...\n  ]\n}\n\nHere's the documentation section:\n\n\n#### `area`\n\nComputes the area of geometries in square meters (`\"m2\"`) or optionally square\nkilometers (`\"km2\"`). The input geometry is assumed to be in the EPSG:4326\ncoordinate system (WGS84), with `[latitude, longitude]` axis order.\n\n##### Signature\n\n```typescript\nasync area(newColumn: string, options?: { unit?: \"m2\" | \"km2\"; column?: string }): Promise<void>;\n```\n\n##### Parameters\n\n- **`newColumn`**: - The name of the new column where the computed areas will be\n  stored.\n- **`options`**: - An optional object with configuration options:\n- **`options.unit`**: - The unit for the computed area: `\"m2\"` (square meters)\n  or `\"km2\"` (square kilometers). Defaults to `\"m2\"`.\n- **`options.column`**: - The name of the column storing the geometries. If\n  omitted, the method will automatically attempt to find a geometry column.\n\n##### Returns\n\nA promise that resolves when the areas have been computed.\n\n##### Examples\n\n```ts\n// Compute the area of geometries in square meters and store in 'area_m2'\nawait table.area(\"area_m2\");\n```\n\n```ts\n// Compute the area of geometries in square kilometers and store in 'area_km2'\nawait table.area(\"area_km2\", { unit: \"km2\" });\n```\n\n```ts\n// Compute the area of geometries in a specific column named 'myGeom'\nawait table.area(\"myGeomArea\", { column: \"myGeom\" });\n```"
  },
  {
    "model": "qwen3:30b",
    "prompt": "Your task is to generate a set of up to 10 relevant questions and answers based on the provided section of documentation. The questions should be those a junior developer or data analyst might have.\n\nFor each question, you must provide a code example as the answer. You can add comments to the code to explain the steps. A brief, one-sentence explanation may be included in a comment if the code alone is not a sufficient answer.\n\nThe questions must be directly related to the documentation section provided below and must not ask about topics outside its scope. The answer should be grounded in the documentation provided. Do not make assumptions.\n\nWrite simple and straightforward code examples. Don't create functions to encapsulate your code.\n\nYour answers should always be wrapped in triple backticks (```ts at the beginning and ``` at the end) for code blocks.\n\nIf the documentation section is about SimpleDB, make sure to wrap your answer with:\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\nconst sdb = new SimpleDB();\n[PUT THE CODE EXAMPLE HERE. IF THERE IS NO CODE TO ADD, JUST ADD A COMMENT SAYING \"Do your magic here!\"]\nawait sdb.done();\n```\n\nIf the documentation section is about SimpleTable, make sure to wrap your answer with:\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\nconst sdb = new SimpleDB();\nconst table = sdb.newTable();\nawait table.loadData(\"path/to/your/data.csv\"); // Remove this line if not needed or change the file extension if relevant\n[PUT THE CODE EXAMPLE HERE. IF THERE IS NO CODE TO ADD, JUST ADD A COMMENT SAYING \"Do your magic here!\"]\nawait sdb.done();\n```\n\nIf you need inspiration, here is a comprehensive example with comments.\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\n\n// We start a SimpleDB instance.\nconst sdb = new SimpleDB();\n\n// We create a new table\nconst fires = sdb.newTable(\"fires\");\n// We fetch the wildfires data. It's a csv.\nawait fires.loadData(\n  \"data/firesCanada2023.csv\",\n);\n\n// We summarize to count the number of fires\n// and sum up the area burnt in each province.\nawait fires.summarize({\n  values: \"hectares\",\n  categories: \"province\",\n  summaries: [\"count\", \"sum\"],\n  decimals: 0,\n});\n// We rename columns.\nawait fires.renameColumns({\n  count: \"nbFires\",\n  sum: \"burntArea\",\n});\n// We want the province with\n// the greatest burnt area first.\nawait fires.sort({ burntArea: \"desc\" });\n\n// We log the results. By default, the method\n// logs the first 10 rows, but there is 13\n// rows in our data. We also log the data types.\nawait fires.logTable({ nbRowsToLog: 13, types: true });\n\n// And we can write the data to a parquet, json or csv file.\nawait fires.writeData(\"./fires.parquet\");\n\n// We close everything.\nawait sdb.done();\n```\n\nReturn your response as a JSON object with the following structure:\n{\n  \"data\": [\n    { \"question\": \"question1\", \"answer\": \"answer1\" },\n    { \"question\": \"question2\", \"answer\": \"answer2\" },\n    ...\n  ]\n}\n\nHere's the documentation section:\n\n\n#### `length`\n\nComputes the length of line geometries in meters (`\"m\"`) or optionally\nkilometers (`\"km\"`). The input geometry is assumed to be in the EPSG:4326\ncoordinate system (WGS84), with `[latitude, longitude]` axis order.\n\n##### Signature\n\n```typescript\nasync length(newColumn: string, options?: { unit?: \"m\" | \"km\"; column?: string }): Promise<void>;\n```\n\n##### Parameters\n\n- **`newColumn`**: - The name of the new column where the computed lengths will\n  be stored.\n- **`options`**: - An optional object with configuration options:\n- **`options.unit`**: - The unit for the computed length: `\"m\"` (meters) or\n  `\"km\"` (kilometers). Defaults to `\"m\"`.\n- **`options.column`**: - The name of the column storing the geometries. If\n  omitted, the method will automatically attempt to find a geometry column.\n\n##### Returns\n\nA promise that resolves when the lengths have been computed.\n\n##### Examples\n\n```ts\n// Compute the length of line geometries in meters and store in 'length_m'\nawait table.length(\"length_m\");\n```\n\n```ts\n// Compute the length of line geometries in kilometers and store in 'length_km'\nawait table.length(\"length_km\", { unit: \"km\" });\n```\n\n```ts\n// Compute the length of geometries in a specific column named 'routeGeom'\nawait table.length(\"routeLength\", { column: \"routeGeom\" });\n```"
  },
  {
    "model": "qwen3:30b",
    "prompt": "Your task is to generate a set of up to 10 relevant questions and answers based on the provided section of documentation. The questions should be those a junior developer or data analyst might have.\n\nFor each question, you must provide a code example as the answer. You can add comments to the code to explain the steps. A brief, one-sentence explanation may be included in a comment if the code alone is not a sufficient answer.\n\nThe questions must be directly related to the documentation section provided below and must not ask about topics outside its scope. The answer should be grounded in the documentation provided. Do not make assumptions.\n\nWrite simple and straightforward code examples. Don't create functions to encapsulate your code.\n\nYour answers should always be wrapped in triple backticks (```ts at the beginning and ``` at the end) for code blocks.\n\nIf the documentation section is about SimpleDB, make sure to wrap your answer with:\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\nconst sdb = new SimpleDB();\n[PUT THE CODE EXAMPLE HERE. IF THERE IS NO CODE TO ADD, JUST ADD A COMMENT SAYING \"Do your magic here!\"]\nawait sdb.done();\n```\n\nIf the documentation section is about SimpleTable, make sure to wrap your answer with:\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\nconst sdb = new SimpleDB();\nconst table = sdb.newTable();\nawait table.loadData(\"path/to/your/data.csv\"); // Remove this line if not needed or change the file extension if relevant\n[PUT THE CODE EXAMPLE HERE. IF THERE IS NO CODE TO ADD, JUST ADD A COMMENT SAYING \"Do your magic here!\"]\nawait sdb.done();\n```\n\nIf you need inspiration, here is a comprehensive example with comments.\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\n\n// We start a SimpleDB instance.\nconst sdb = new SimpleDB();\n\n// We create a new table\nconst fires = sdb.newTable(\"fires\");\n// We fetch the wildfires data. It's a csv.\nawait fires.loadData(\n  \"data/firesCanada2023.csv\",\n);\n\n// We summarize to count the number of fires\n// and sum up the area burnt in each province.\nawait fires.summarize({\n  values: \"hectares\",\n  categories: \"province\",\n  summaries: [\"count\", \"sum\"],\n  decimals: 0,\n});\n// We rename columns.\nawait fires.renameColumns({\n  count: \"nbFires\",\n  sum: \"burntArea\",\n});\n// We want the province with\n// the greatest burnt area first.\nawait fires.sort({ burntArea: \"desc\" });\n\n// We log the results. By default, the method\n// logs the first 10 rows, but there is 13\n// rows in our data. We also log the data types.\nawait fires.logTable({ nbRowsToLog: 13, types: true });\n\n// And we can write the data to a parquet, json or csv file.\nawait fires.writeData(\"./fires.parquet\");\n\n// We close everything.\nawait sdb.done();\n```\n\nReturn your response as a JSON object with the following structure:\n{\n  \"data\": [\n    { \"question\": \"question1\", \"answer\": \"answer1\" },\n    { \"question\": \"question2\", \"answer\": \"answer2\" },\n    ...\n  ]\n}\n\nHere's the documentation section:\n\n\n#### `perimeter`\n\nComputes the perimeter of polygon geometries in meters (`\"m\"`) or optionally\nkilometers (`\"km\"`). The input geometry is assumed to be in the EPSG:4326\ncoordinate system (WGS84), with `[latitude, longitude]` axis order.\n\n##### Signature\n\n```typescript\nasync perimeter(newColumn: string, options?: { unit?: \"m\" | \"km\"; column?: string }): Promise<void>;\n```\n\n##### Parameters\n\n- **`newColumn`**: - The name of the new column where the computed perimeters\n  will be stored.\n- **`options`**: - An optional object with configuration options:\n- **`options.unit`**: - The unit for the computed perimeter: `\"m\"` (meters) or\n  `\"km\"` (kilometers). Defaults to `\"m\"`.\n- **`options.column`**: - The name of the column storing the geometries. If\n  omitted, the method will automatically attempt to find a geometry column.\n\n##### Returns\n\nA promise that resolves when the perimeters have been computed.\n\n##### Examples\n\n```ts\n// Compute the perimeter of polygon geometries in meters and store in 'perimeter_m'\nawait table.perimeter(\"perimeter_m\");\n```\n\n```ts\n// Compute the perimeter of polygon geometries in kilometers and store in 'perimeter_km'\nawait table.perimeter(\"perimeter_km\", { unit: \"km\" });\n```\n\n```ts\n// Compute the perimeter of geometries in a specific column named 'landParcelGeom'\nawait table.perimeter(\"landParcelPerimeter\", { column: \"landParcelGeom\" });\n```"
  },
  {
    "model": "qwen3:30b",
    "prompt": "Your task is to generate a set of up to 10 relevant questions and answers based on the provided section of documentation. The questions should be those a junior developer or data analyst might have.\n\nFor each question, you must provide a code example as the answer. You can add comments to the code to explain the steps. A brief, one-sentence explanation may be included in a comment if the code alone is not a sufficient answer.\n\nThe questions must be directly related to the documentation section provided below and must not ask about topics outside its scope. The answer should be grounded in the documentation provided. Do not make assumptions.\n\nWrite simple and straightforward code examples. Don't create functions to encapsulate your code.\n\nYour answers should always be wrapped in triple backticks (```ts at the beginning and ``` at the end) for code blocks.\n\nIf the documentation section is about SimpleDB, make sure to wrap your answer with:\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\nconst sdb = new SimpleDB();\n[PUT THE CODE EXAMPLE HERE. IF THERE IS NO CODE TO ADD, JUST ADD A COMMENT SAYING \"Do your magic here!\"]\nawait sdb.done();\n```\n\nIf the documentation section is about SimpleTable, make sure to wrap your answer with:\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\nconst sdb = new SimpleDB();\nconst table = sdb.newTable();\nawait table.loadData(\"path/to/your/data.csv\"); // Remove this line if not needed or change the file extension if relevant\n[PUT THE CODE EXAMPLE HERE. IF THERE IS NO CODE TO ADD, JUST ADD A COMMENT SAYING \"Do your magic here!\"]\nawait sdb.done();\n```\n\nIf you need inspiration, here is a comprehensive example with comments.\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\n\n// We start a SimpleDB instance.\nconst sdb = new SimpleDB();\n\n// We create a new table\nconst fires = sdb.newTable(\"fires\");\n// We fetch the wildfires data. It's a csv.\nawait fires.loadData(\n  \"data/firesCanada2023.csv\",\n);\n\n// We summarize to count the number of fires\n// and sum up the area burnt in each province.\nawait fires.summarize({\n  values: \"hectares\",\n  categories: \"province\",\n  summaries: [\"count\", \"sum\"],\n  decimals: 0,\n});\n// We rename columns.\nawait fires.renameColumns({\n  count: \"nbFires\",\n  sum: \"burntArea\",\n});\n// We want the province with\n// the greatest burnt area first.\nawait fires.sort({ burntArea: \"desc\" });\n\n// We log the results. By default, the method\n// logs the first 10 rows, but there is 13\n// rows in our data. We also log the data types.\nawait fires.logTable({ nbRowsToLog: 13, types: true });\n\n// And we can write the data to a parquet, json or csv file.\nawait fires.writeData(\"./fires.parquet\");\n\n// We close everything.\nawait sdb.done();\n```\n\nReturn your response as a JSON object with the following structure:\n{\n  \"data\": [\n    { \"question\": \"question1\", \"answer\": \"answer1\" },\n    { \"question\": \"question2\", \"answer\": \"answer2\" },\n    ...\n  ]\n}\n\nHere's the documentation section:\n\n\n#### `buffer`\n\nComputes a buffer (a polygon representing a specified distance around a\ngeometry) for geometries in a specified column. The distance is in the Spatial\nReference System (SRS) unit of the input geometries.\n\n##### Signature\n\n```typescript\nasync buffer(newColumn: string, distance: number, options?: { column?: string }): Promise<void>;\n```\n\n##### Parameters\n\n- **`newColumn`**: - The name of the new column where the buffered geometries\n  will be stored.\n- **`distance`**: - The distance for the buffer. This value is in the units of\n  the geometry's SRS.\n- **`options`**: - An optional object with configuration options:\n- **`options.column`**: - The name of the column storing the geometries. If\n  omitted, the method will automatically attempt to find a geometry column.\n\n##### Returns\n\nA promise that resolves when the buffers have been computed.\n\n##### Examples\n\n```ts\n// Create a buffer of 1 unit around geometries in the default column, storing results in 'bufferedGeom'\nawait table.buffer(\"bufferedGeom\", 1);\n```\n\n```ts\n// Create a buffer of 10 units around geometries in a specific column named 'pointsGeom'\nawait table.buffer(\"pointsBuffer\", 10, { column: \"pointsGeom\" });\n```"
  },
  {
    "model": "qwen3:30b",
    "prompt": "Your task is to generate a set of up to 10 relevant questions and answers based on the provided section of documentation. The questions should be those a junior developer or data analyst might have.\n\nFor each question, you must provide a code example as the answer. You can add comments to the code to explain the steps. A brief, one-sentence explanation may be included in a comment if the code alone is not a sufficient answer.\n\nThe questions must be directly related to the documentation section provided below and must not ask about topics outside its scope. The answer should be grounded in the documentation provided. Do not make assumptions.\n\nWrite simple and straightforward code examples. Don't create functions to encapsulate your code.\n\nYour answers should always be wrapped in triple backticks (```ts at the beginning and ``` at the end) for code blocks.\n\nIf the documentation section is about SimpleDB, make sure to wrap your answer with:\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\nconst sdb = new SimpleDB();\n[PUT THE CODE EXAMPLE HERE. IF THERE IS NO CODE TO ADD, JUST ADD A COMMENT SAYING \"Do your magic here!\"]\nawait sdb.done();\n```\n\nIf the documentation section is about SimpleTable, make sure to wrap your answer with:\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\nconst sdb = new SimpleDB();\nconst table = sdb.newTable();\nawait table.loadData(\"path/to/your/data.csv\"); // Remove this line if not needed or change the file extension if relevant\n[PUT THE CODE EXAMPLE HERE. IF THERE IS NO CODE TO ADD, JUST ADD A COMMENT SAYING \"Do your magic here!\"]\nawait sdb.done();\n```\n\nIf you need inspiration, here is a comprehensive example with comments.\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\n\n// We start a SimpleDB instance.\nconst sdb = new SimpleDB();\n\n// We create a new table\nconst fires = sdb.newTable(\"fires\");\n// We fetch the wildfires data. It's a csv.\nawait fires.loadData(\n  \"data/firesCanada2023.csv\",\n);\n\n// We summarize to count the number of fires\n// and sum up the area burnt in each province.\nawait fires.summarize({\n  values: \"hectares\",\n  categories: \"province\",\n  summaries: [\"count\", \"sum\"],\n  decimals: 0,\n});\n// We rename columns.\nawait fires.renameColumns({\n  count: \"nbFires\",\n  sum: \"burntArea\",\n});\n// We want the province with\n// the greatest burnt area first.\nawait fires.sort({ burntArea: \"desc\" });\n\n// We log the results. By default, the method\n// logs the first 10 rows, but there is 13\n// rows in our data. We also log the data types.\nawait fires.logTable({ nbRowsToLog: 13, types: true });\n\n// And we can write the data to a parquet, json or csv file.\nawait fires.writeData(\"./fires.parquet\");\n\n// We close everything.\nawait sdb.done();\n```\n\nReturn your response as a JSON object with the following structure:\n{\n  \"data\": [\n    { \"question\": \"question1\", \"answer\": \"answer1\" },\n    { \"question\": \"question2\", \"answer\": \"answer2\" },\n    ...\n  ]\n}\n\nHere's the documentation section:\n\n\n#### `joinGeo`\n\nMerges the data of this table (considered the left table) with another table\n(the right table) based on a spatial relationship. Note that the order of rows\nin the returned data is not guaranteed to be the same as in the original tables.\nThis operation might create temporary files in a `.tmp` folder; consider adding\n`.tmp` to your `.gitignore`.\n\n##### Signature\n\n```typescript\nasync joinGeo(rightTable: SimpleTable, method: \"intersect\" | \"inside\" | \"within\", options?: { leftTableColumn?: string; rightTableColumn?: string; type?: \"inner\" | \"left\" | \"right\" | \"full\"; distance?: number; distanceMethod?: \"srs\" | \"haversine\" | \"spheroid\"; outputTable?: string | boolean }): Promise<SimpleTable>;\n```\n\n##### Parameters\n\n- **`rightTable`**: - The SimpleTable instance to be joined with this table.\n- **`method`**: - The spatial join method to use: `\"intersect\"` (geometries\n  overlap), `\"inside\"` (geometries of the left table are entirely within\n  geometries of the right table), or `\"within\"` (geometries of the left table\n  are within a specified distance of geometries in the right table).\n- **`options`**: - An optional object with configuration options:\n- **`options.leftTableColumn`**: - The name of the column storing geometries in\n  the left table (this table). If omitted, the method attempts to find one.\n- **`options.rightTableColumn`**: - The name of the column storing geometries in\n  the right table. If omitted, the method attempts to find one.\n- **`options.type`**: - The type of join operation to perform: `\"inner\"`,\n  `\"left\"` (default), `\"right\"`, or `\"full\"`. For some types (like `\"inside\"`),\n  the table order is important.\n- **`options.distance`**: - Required if `method` is `\"within\"`. The target\n  distance for the spatial join. The unit depends on `distanceMethod`.\n- **`options.distanceMethod`**: - The method for distance calculations: `\"srs\"`\n  (default, uses the SRS unit), `\"haversine\"` (uses meters, requires EPSG:4326\n  input), or `\"spheroid\"` (uses meters, requires EPSG:4326 input, most accurate\n  but slowest).\n- **`options.outputTable`**: - If `true`, the results will be stored in a new\n  table with a generated name. If a string, it will be used as the name for the\n  new table. If `false` or omitted, the current table will be overwritten.\n  Defaults to `false`.\n\n##### Returns\n\nA promise that resolves to the SimpleTable instance containing the spatially\njoined data (either the modified current table or a new table).\n\n##### Examples\n\n```ts\n// Merge data based on intersecting geometries, overwriting tableA\nawait tableA.joinGeo(tableB, \"intersect\");\n```\n\n```ts\n// Merge data where geometries in tableA are inside geometries in tableB\nawait tableA.joinGeo(tableB, \"inside\");\n```\n\n```ts\n// Merge data where geometries in tableA are within 10 units (SRS) of geometries in tableB\nawait tableA.joinGeo(tableB, \"within\", { distance: 10 });\n```\n\n```ts\n// Merge data where geometries in tableA are within 10 kilometers (Haversine) of geometries in tableB\n// Input geometries must be in EPSG:4326.\nawait tableA.joinGeo(tableB, \"within\", {\n  distance: 10,\n  distanceMethod: \"haversine\",\n  unit: \"km\",\n});\n```\n\n```ts\n// Merge data with specific geometry columns and an inner join type, storing results in a new table\nconst tableC = await tableA.joinGeo(tableB, \"intersect\", {\n  leftTableColumn: \"geometriesA\",\n  rightTableColumn: \"geometriesB\",\n  type: \"inner\",\n  outputTable: true,\n});\n```"
  },
  {
    "model": "qwen3:30b",
    "prompt": "Your task is to generate a set of up to 10 relevant questions and answers based on the provided section of documentation. The questions should be those a junior developer or data analyst might have.\n\nFor each question, you must provide a code example as the answer. You can add comments to the code to explain the steps. A brief, one-sentence explanation may be included in a comment if the code alone is not a sufficient answer.\n\nThe questions must be directly related to the documentation section provided below and must not ask about topics outside its scope. The answer should be grounded in the documentation provided. Do not make assumptions.\n\nWrite simple and straightforward code examples. Don't create functions to encapsulate your code.\n\nYour answers should always be wrapped in triple backticks (```ts at the beginning and ``` at the end) for code blocks.\n\nIf the documentation section is about SimpleDB, make sure to wrap your answer with:\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\nconst sdb = new SimpleDB();\n[PUT THE CODE EXAMPLE HERE. IF THERE IS NO CODE TO ADD, JUST ADD A COMMENT SAYING \"Do your magic here!\"]\nawait sdb.done();\n```\n\nIf the documentation section is about SimpleTable, make sure to wrap your answer with:\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\nconst sdb = new SimpleDB();\nconst table = sdb.newTable();\nawait table.loadData(\"path/to/your/data.csv\"); // Remove this line if not needed or change the file extension if relevant\n[PUT THE CODE EXAMPLE HERE. IF THERE IS NO CODE TO ADD, JUST ADD A COMMENT SAYING \"Do your magic here!\"]\nawait sdb.done();\n```\n\nIf you need inspiration, here is a comprehensive example with comments.\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\n\n// We start a SimpleDB instance.\nconst sdb = new SimpleDB();\n\n// We create a new table\nconst fires = sdb.newTable(\"fires\");\n// We fetch the wildfires data. It's a csv.\nawait fires.loadData(\n  \"data/firesCanada2023.csv\",\n);\n\n// We summarize to count the number of fires\n// and sum up the area burnt in each province.\nawait fires.summarize({\n  values: \"hectares\",\n  categories: \"province\",\n  summaries: [\"count\", \"sum\"],\n  decimals: 0,\n});\n// We rename columns.\nawait fires.renameColumns({\n  count: \"nbFires\",\n  sum: \"burntArea\",\n});\n// We want the province with\n// the greatest burnt area first.\nawait fires.sort({ burntArea: \"desc\" });\n\n// We log the results. By default, the method\n// logs the first 10 rows, but there is 13\n// rows in our data. We also log the data types.\nawait fires.logTable({ nbRowsToLog: 13, types: true });\n\n// And we can write the data to a parquet, json or csv file.\nawait fires.writeData(\"./fires.parquet\");\n\n// We close everything.\nawait sdb.done();\n```\n\nReturn your response as a JSON object with the following structure:\n{\n  \"data\": [\n    { \"question\": \"question1\", \"answer\": \"answer1\" },\n    { \"question\": \"question2\", \"answer\": \"answer2\" },\n    ...\n  ]\n}\n\nHere's the documentation section:\n\n\n#### `intersection`\n\nComputes the intersection of two sets of geometries, creating new geometries\nwhere they overlap.\n\n##### Signature\n\n```typescript\nasync intersection(column1: string, column2: string, newColumn: string): Promise<void>;\n```\n\n##### Parameters\n\n- **`column1`**: - The name of the first column storing geometries.\n- **`column2`**: - The name of the second column storing geometries. Both\n  columns must have the same projection.\n- **`newColumn`**: - The name of the new column where the computed intersection\n  geometries will be stored.\n\n##### Returns\n\nA promise that resolves when the intersection geometries have been computed.\n\n##### Examples\n\n```ts\n// Compute the intersection of geometries in 'geomA' and 'geomB' columns, storing results in 'intersectGeom'\nawait table.intersection(\"geomA\", \"geomB\", \"intersectGeom\");\n```"
  },
  {
    "model": "qwen3:30b",
    "prompt": "Your task is to generate a set of up to 10 relevant questions and answers based on the provided section of documentation. The questions should be those a junior developer or data analyst might have.\n\nFor each question, you must provide a code example as the answer. You can add comments to the code to explain the steps. A brief, one-sentence explanation may be included in a comment if the code alone is not a sufficient answer.\n\nThe questions must be directly related to the documentation section provided below and must not ask about topics outside its scope. The answer should be grounded in the documentation provided. Do not make assumptions.\n\nWrite simple and straightforward code examples. Don't create functions to encapsulate your code.\n\nYour answers should always be wrapped in triple backticks (```ts at the beginning and ``` at the end) for code blocks.\n\nIf the documentation section is about SimpleDB, make sure to wrap your answer with:\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\nconst sdb = new SimpleDB();\n[PUT THE CODE EXAMPLE HERE. IF THERE IS NO CODE TO ADD, JUST ADD A COMMENT SAYING \"Do your magic here!\"]\nawait sdb.done();\n```\n\nIf the documentation section is about SimpleTable, make sure to wrap your answer with:\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\nconst sdb = new SimpleDB();\nconst table = sdb.newTable();\nawait table.loadData(\"path/to/your/data.csv\"); // Remove this line if not needed or change the file extension if relevant\n[PUT THE CODE EXAMPLE HERE. IF THERE IS NO CODE TO ADD, JUST ADD A COMMENT SAYING \"Do your magic here!\"]\nawait sdb.done();\n```\n\nIf you need inspiration, here is a comprehensive example with comments.\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\n\n// We start a SimpleDB instance.\nconst sdb = new SimpleDB();\n\n// We create a new table\nconst fires = sdb.newTable(\"fires\");\n// We fetch the wildfires data. It's a csv.\nawait fires.loadData(\n  \"data/firesCanada2023.csv\",\n);\n\n// We summarize to count the number of fires\n// and sum up the area burnt in each province.\nawait fires.summarize({\n  values: \"hectares\",\n  categories: \"province\",\n  summaries: [\"count\", \"sum\"],\n  decimals: 0,\n});\n// We rename columns.\nawait fires.renameColumns({\n  count: \"nbFires\",\n  sum: \"burntArea\",\n});\n// We want the province with\n// the greatest burnt area first.\nawait fires.sort({ burntArea: \"desc\" });\n\n// We log the results. By default, the method\n// logs the first 10 rows, but there is 13\n// rows in our data. We also log the data types.\nawait fires.logTable({ nbRowsToLog: 13, types: true });\n\n// And we can write the data to a parquet, json or csv file.\nawait fires.writeData(\"./fires.parquet\");\n\n// We close everything.\nawait sdb.done();\n```\n\nReturn your response as a JSON object with the following structure:\n{\n  \"data\": [\n    { \"question\": \"question1\", \"answer\": \"answer1\" },\n    { \"question\": \"question2\", \"answer\": \"answer2\" },\n    ...\n  ]\n}\n\nHere's the documentation section:\n\n\n#### `removeIntersection`\n\nRemoves the intersection of two geometries from the first geometry, effectively\ncomputing the geometric difference.\n\n##### Signature\n\n```typescript\nasync removeIntersection(column1: string, column2: string, newColumn: string): Promise<void>;\n```\n\n##### Parameters\n\n- **`column1`**: - The name of the column storing the reference geometries.\n  These geometries will have the intersection removed.\n- **`column2`**: - The name of the column storing the geometries used to compute\n  the intersection. Both columns must have the same projection.\n- **`newColumn`**: - The name of the new column where the resulting geometries\n  (without the intersection) will be stored.\n\n##### Returns\n\nA promise that resolves when the geometries have been processed.\n\n##### Examples\n\n```ts\n// Remove the intersection of 'geomB' from 'geomA', storing the result in 'geomA_minus_geomB'\nawait table.removeIntersection(\"geomA\", \"geomB\", \"geomA_minus_geomB\");\n```"
  },
  {
    "model": "qwen3:30b",
    "prompt": "Your task is to generate a set of up to 10 relevant questions and answers based on the provided section of documentation. The questions should be those a junior developer or data analyst might have.\n\nFor each question, you must provide a code example as the answer. You can add comments to the code to explain the steps. A brief, one-sentence explanation may be included in a comment if the code alone is not a sufficient answer.\n\nThe questions must be directly related to the documentation section provided below and must not ask about topics outside its scope. The answer should be grounded in the documentation provided. Do not make assumptions.\n\nWrite simple and straightforward code examples. Don't create functions to encapsulate your code.\n\nYour answers should always be wrapped in triple backticks (```ts at the beginning and ``` at the end) for code blocks.\n\nIf the documentation section is about SimpleDB, make sure to wrap your answer with:\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\nconst sdb = new SimpleDB();\n[PUT THE CODE EXAMPLE HERE. IF THERE IS NO CODE TO ADD, JUST ADD A COMMENT SAYING \"Do your magic here!\"]\nawait sdb.done();\n```\n\nIf the documentation section is about SimpleTable, make sure to wrap your answer with:\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\nconst sdb = new SimpleDB();\nconst table = sdb.newTable();\nawait table.loadData(\"path/to/your/data.csv\"); // Remove this line if not needed or change the file extension if relevant\n[PUT THE CODE EXAMPLE HERE. IF THERE IS NO CODE TO ADD, JUST ADD A COMMENT SAYING \"Do your magic here!\"]\nawait sdb.done();\n```\n\nIf you need inspiration, here is a comprehensive example with comments.\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\n\n// We start a SimpleDB instance.\nconst sdb = new SimpleDB();\n\n// We create a new table\nconst fires = sdb.newTable(\"fires\");\n// We fetch the wildfires data. It's a csv.\nawait fires.loadData(\n  \"data/firesCanada2023.csv\",\n);\n\n// We summarize to count the number of fires\n// and sum up the area burnt in each province.\nawait fires.summarize({\n  values: \"hectares\",\n  categories: \"province\",\n  summaries: [\"count\", \"sum\"],\n  decimals: 0,\n});\n// We rename columns.\nawait fires.renameColumns({\n  count: \"nbFires\",\n  sum: \"burntArea\",\n});\n// We want the province with\n// the greatest burnt area first.\nawait fires.sort({ burntArea: \"desc\" });\n\n// We log the results. By default, the method\n// logs the first 10 rows, but there is 13\n// rows in our data. We also log the data types.\nawait fires.logTable({ nbRowsToLog: 13, types: true });\n\n// And we can write the data to a parquet, json or csv file.\nawait fires.writeData(\"./fires.parquet\");\n\n// We close everything.\nawait sdb.done();\n```\n\nReturn your response as a JSON object with the following structure:\n{\n  \"data\": [\n    { \"question\": \"question1\", \"answer\": \"answer1\" },\n    { \"question\": \"question2\", \"answer\": \"answer2\" },\n    ...\n  ]\n}\n\nHere's the documentation section:\n\n\n#### `intersect`\n\nReturns `TRUE` if two geometries intersect (overlap in any way), and `FALSE`\notherwise.\n\n##### Signature\n\n```typescript\nasync intersect(column1: string, column2: string, newColumn: string): Promise<void>;\n```\n\n##### Parameters\n\n- **`column1`**: - The name of the first column storing geometries.\n- **`column2`**: - The name of the second column storing geometries. Both\n  columns must have the same projection.\n- **`newColumn`**: - The name of the new column where the boolean results\n  (`TRUE` for intersection, `FALSE` otherwise) will be stored.\n\n##### Returns\n\nA promise that resolves when the intersection check is complete.\n\n##### Examples\n\n```ts\n// Check if geometries in 'geomA' and 'geomB' intersect, storing results in 'doIntersect'\nawait table.intersect(\"geomA\", \"geomB\", \"doIntersect\");\n```"
  },
  {
    "model": "qwen3:30b",
    "prompt": "Your task is to generate a set of up to 10 relevant questions and answers based on the provided section of documentation. The questions should be those a junior developer or data analyst might have.\n\nFor each question, you must provide a code example as the answer. You can add comments to the code to explain the steps. A brief, one-sentence explanation may be included in a comment if the code alone is not a sufficient answer.\n\nThe questions must be directly related to the documentation section provided below and must not ask about topics outside its scope. The answer should be grounded in the documentation provided. Do not make assumptions.\n\nWrite simple and straightforward code examples. Don't create functions to encapsulate your code.\n\nYour answers should always be wrapped in triple backticks (```ts at the beginning and ``` at the end) for code blocks.\n\nIf the documentation section is about SimpleDB, make sure to wrap your answer with:\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\nconst sdb = new SimpleDB();\n[PUT THE CODE EXAMPLE HERE. IF THERE IS NO CODE TO ADD, JUST ADD A COMMENT SAYING \"Do your magic here!\"]\nawait sdb.done();\n```\n\nIf the documentation section is about SimpleTable, make sure to wrap your answer with:\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\nconst sdb = new SimpleDB();\nconst table = sdb.newTable();\nawait table.loadData(\"path/to/your/data.csv\"); // Remove this line if not needed or change the file extension if relevant\n[PUT THE CODE EXAMPLE HERE. IF THERE IS NO CODE TO ADD, JUST ADD A COMMENT SAYING \"Do your magic here!\"]\nawait sdb.done();\n```\n\nIf you need inspiration, here is a comprehensive example with comments.\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\n\n// We start a SimpleDB instance.\nconst sdb = new SimpleDB();\n\n// We create a new table\nconst fires = sdb.newTable(\"fires\");\n// We fetch the wildfires data. It's a csv.\nawait fires.loadData(\n  \"data/firesCanada2023.csv\",\n);\n\n// We summarize to count the number of fires\n// and sum up the area burnt in each province.\nawait fires.summarize({\n  values: \"hectares\",\n  categories: \"province\",\n  summaries: [\"count\", \"sum\"],\n  decimals: 0,\n});\n// We rename columns.\nawait fires.renameColumns({\n  count: \"nbFires\",\n  sum: \"burntArea\",\n});\n// We want the province with\n// the greatest burnt area first.\nawait fires.sort({ burntArea: \"desc\" });\n\n// We log the results. By default, the method\n// logs the first 10 rows, but there is 13\n// rows in our data. We also log the data types.\nawait fires.logTable({ nbRowsToLog: 13, types: true });\n\n// And we can write the data to a parquet, json or csv file.\nawait fires.writeData(\"./fires.parquet\");\n\n// We close everything.\nawait sdb.done();\n```\n\nReturn your response as a JSON object with the following structure:\n{\n  \"data\": [\n    { \"question\": \"question1\", \"answer\": \"answer1\" },\n    { \"question\": \"question2\", \"answer\": \"answer2\" },\n    ...\n  ]\n}\n\nHere's the documentation section:\n\n\n#### `inside`\n\nReturns `TRUE` if all points of a geometry in `column1` lie inside a geometry in\n`column2`, and `FALSE` otherwise.\n\n##### Signature\n\n```typescript\nasync inside(column1: string, column2: string, newColumn: string): Promise<void>;\n```\n\n##### Parameters\n\n- **`column1`**: - The name of the column storing the geometries to be tested\n  for containment.\n- **`column2`**: - The name of the column storing the geometries to be tested as\n  containers. Both columns must have the same projection.\n- **`newColumn`**: - The name of the new column where the boolean results\n  (`TRUE` for inside, `FALSE` otherwise) will be stored.\n\n##### Returns\n\nA promise that resolves when the containment check is complete.\n\n##### Examples\n\n```ts\n// Check if geometries in 'pointGeom' are inside 'polygonGeom', storing results in 'isInsidePolygon'\nawait table.inside(\"pointGeom\", \"polygonGeom\", \"isInsidePolygon\");\n```"
  },
  {
    "model": "qwen3:30b",
    "prompt": "Your task is to generate a set of up to 10 relevant questions and answers based on the provided section of documentation. The questions should be those a junior developer or data analyst might have.\n\nFor each question, you must provide a code example as the answer. You can add comments to the code to explain the steps. A brief, one-sentence explanation may be included in a comment if the code alone is not a sufficient answer.\n\nThe questions must be directly related to the documentation section provided below and must not ask about topics outside its scope. The answer should be grounded in the documentation provided. Do not make assumptions.\n\nWrite simple and straightforward code examples. Don't create functions to encapsulate your code.\n\nYour answers should always be wrapped in triple backticks (```ts at the beginning and ``` at the end) for code blocks.\n\nIf the documentation section is about SimpleDB, make sure to wrap your answer with:\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\nconst sdb = new SimpleDB();\n[PUT THE CODE EXAMPLE HERE. IF THERE IS NO CODE TO ADD, JUST ADD A COMMENT SAYING \"Do your magic here!\"]\nawait sdb.done();\n```\n\nIf the documentation section is about SimpleTable, make sure to wrap your answer with:\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\nconst sdb = new SimpleDB();\nconst table = sdb.newTable();\nawait table.loadData(\"path/to/your/data.csv\"); // Remove this line if not needed or change the file extension if relevant\n[PUT THE CODE EXAMPLE HERE. IF THERE IS NO CODE TO ADD, JUST ADD A COMMENT SAYING \"Do your magic here!\"]\nawait sdb.done();\n```\n\nIf you need inspiration, here is a comprehensive example with comments.\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\n\n// We start a SimpleDB instance.\nconst sdb = new SimpleDB();\n\n// We create a new table\nconst fires = sdb.newTable(\"fires\");\n// We fetch the wildfires data. It's a csv.\nawait fires.loadData(\n  \"data/firesCanada2023.csv\",\n);\n\n// We summarize to count the number of fires\n// and sum up the area burnt in each province.\nawait fires.summarize({\n  values: \"hectares\",\n  categories: \"province\",\n  summaries: [\"count\", \"sum\"],\n  decimals: 0,\n});\n// We rename columns.\nawait fires.renameColumns({\n  count: \"nbFires\",\n  sum: \"burntArea\",\n});\n// We want the province with\n// the greatest burnt area first.\nawait fires.sort({ burntArea: \"desc\" });\n\n// We log the results. By default, the method\n// logs the first 10 rows, but there is 13\n// rows in our data. We also log the data types.\nawait fires.logTable({ nbRowsToLog: 13, types: true });\n\n// And we can write the data to a parquet, json or csv file.\nawait fires.writeData(\"./fires.parquet\");\n\n// We close everything.\nawait sdb.done();\n```\n\nReturn your response as a JSON object with the following structure:\n{\n  \"data\": [\n    { \"question\": \"question1\", \"answer\": \"answer1\" },\n    { \"question\": \"question2\", \"answer\": \"answer2\" },\n    ...\n  ]\n}\n\nHere's the documentation section:\n\n\n#### `union`\n\nComputes the union of two geometries, creating a new geometry that represents\nthe merged area of both.\n\n##### Signature\n\n```typescript\nasync union(column1: string, column2: string, newColumn: string): Promise<void>;\n```\n\n##### Parameters\n\n- **`column1`**: - The name of the first column storing geometries.\n- **`column2`**: - The name of the second column storing geometries. Both\n  columns must have the same projection.\n- **`newColumn`**: - The name of the new column where the computed union\n  geometries will be stored.\n\n##### Returns\n\nA promise that resolves when the union geometries have been computed.\n\n##### Examples\n\n```ts\n// Compute the union of geometries in 'geomA' and 'geomB', storing results in 'unionGeom'\nawait table.union(\"geomA\", \"geomB\", \"unionGeom\");\n```"
  },
  {
    "model": "qwen3:30b",
    "prompt": "Your task is to generate a set of up to 10 relevant questions and answers based on the provided section of documentation. The questions should be those a junior developer or data analyst might have.\n\nFor each question, you must provide a code example as the answer. You can add comments to the code to explain the steps. A brief, one-sentence explanation may be included in a comment if the code alone is not a sufficient answer.\n\nThe questions must be directly related to the documentation section provided below and must not ask about topics outside its scope. The answer should be grounded in the documentation provided. Do not make assumptions.\n\nWrite simple and straightforward code examples. Don't create functions to encapsulate your code.\n\nYour answers should always be wrapped in triple backticks (```ts at the beginning and ``` at the end) for code blocks.\n\nIf the documentation section is about SimpleDB, make sure to wrap your answer with:\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\nconst sdb = new SimpleDB();\n[PUT THE CODE EXAMPLE HERE. IF THERE IS NO CODE TO ADD, JUST ADD A COMMENT SAYING \"Do your magic here!\"]\nawait sdb.done();\n```\n\nIf the documentation section is about SimpleTable, make sure to wrap your answer with:\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\nconst sdb = new SimpleDB();\nconst table = sdb.newTable();\nawait table.loadData(\"path/to/your/data.csv\"); // Remove this line if not needed or change the file extension if relevant\n[PUT THE CODE EXAMPLE HERE. IF THERE IS NO CODE TO ADD, JUST ADD A COMMENT SAYING \"Do your magic here!\"]\nawait sdb.done();\n```\n\nIf you need inspiration, here is a comprehensive example with comments.\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\n\n// We start a SimpleDB instance.\nconst sdb = new SimpleDB();\n\n// We create a new table\nconst fires = sdb.newTable(\"fires\");\n// We fetch the wildfires data. It's a csv.\nawait fires.loadData(\n  \"data/firesCanada2023.csv\",\n);\n\n// We summarize to count the number of fires\n// and sum up the area burnt in each province.\nawait fires.summarize({\n  values: \"hectares\",\n  categories: \"province\",\n  summaries: [\"count\", \"sum\"],\n  decimals: 0,\n});\n// We rename columns.\nawait fires.renameColumns({\n  count: \"nbFires\",\n  sum: \"burntArea\",\n});\n// We want the province with\n// the greatest burnt area first.\nawait fires.sort({ burntArea: \"desc\" });\n\n// We log the results. By default, the method\n// logs the first 10 rows, but there is 13\n// rows in our data. We also log the data types.\nawait fires.logTable({ nbRowsToLog: 13, types: true });\n\n// And we can write the data to a parquet, json or csv file.\nawait fires.writeData(\"./fires.parquet\");\n\n// We close everything.\nawait sdb.done();\n```\n\nReturn your response as a JSON object with the following structure:\n{\n  \"data\": [\n    { \"question\": \"question1\", \"answer\": \"answer1\" },\n    { \"question\": \"question2\", \"answer\": \"answer2\" },\n    ...\n  ]\n}\n\nHere's the documentation section:\n\n\n#### `latLon`\n\nExtracts the latitude and longitude coordinates from point geometries. The input\ngeometry is assumed to be in the EPSG:4326 coordinate system (WGS84), with\n`[latitude, longitude]` axis order.\n\n##### Signature\n\n```typescript\nasync latLon(column: string, columnLat: string, columnLon: string): Promise<void>;\n```\n\n##### Parameters\n\n- **`column`**: - The name of the column storing the point geometries.\n- **`columnLat`**: - The name of the new column where the extracted latitude\n  values will be stored.\n- **`columnLon`**: - The name of the new column where the extracted longitude\n  values will be stored.\n\n##### Returns\n\nA promise that resolves when the latitude and longitude have been extracted.\n\n##### Examples\n\n```ts\n// Extract latitude and longitude from 'geom' column into new 'lat' and 'lon' columns\nawait table.latLon(\"geom\", \"lat\", \"lon\");\n```"
  },
  {
    "model": "qwen3:30b",
    "prompt": "Your task is to generate a set of up to 10 relevant questions and answers based on the provided section of documentation. The questions should be those a junior developer or data analyst might have.\n\nFor each question, you must provide a code example as the answer. You can add comments to the code to explain the steps. A brief, one-sentence explanation may be included in a comment if the code alone is not a sufficient answer.\n\nThe questions must be directly related to the documentation section provided below and must not ask about topics outside its scope. The answer should be grounded in the documentation provided. Do not make assumptions.\n\nWrite simple and straightforward code examples. Don't create functions to encapsulate your code.\n\nYour answers should always be wrapped in triple backticks (```ts at the beginning and ``` at the end) for code blocks.\n\nIf the documentation section is about SimpleDB, make sure to wrap your answer with:\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\nconst sdb = new SimpleDB();\n[PUT THE CODE EXAMPLE HERE. IF THERE IS NO CODE TO ADD, JUST ADD A COMMENT SAYING \"Do your magic here!\"]\nawait sdb.done();\n```\n\nIf the documentation section is about SimpleTable, make sure to wrap your answer with:\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\nconst sdb = new SimpleDB();\nconst table = sdb.newTable();\nawait table.loadData(\"path/to/your/data.csv\"); // Remove this line if not needed or change the file extension if relevant\n[PUT THE CODE EXAMPLE HERE. IF THERE IS NO CODE TO ADD, JUST ADD A COMMENT SAYING \"Do your magic here!\"]\nawait sdb.done();\n```\n\nIf you need inspiration, here is a comprehensive example with comments.\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\n\n// We start a SimpleDB instance.\nconst sdb = new SimpleDB();\n\n// We create a new table\nconst fires = sdb.newTable(\"fires\");\n// We fetch the wildfires data. It's a csv.\nawait fires.loadData(\n  \"data/firesCanada2023.csv\",\n);\n\n// We summarize to count the number of fires\n// and sum up the area burnt in each province.\nawait fires.summarize({\n  values: \"hectares\",\n  categories: \"province\",\n  summaries: [\"count\", \"sum\"],\n  decimals: 0,\n});\n// We rename columns.\nawait fires.renameColumns({\n  count: \"nbFires\",\n  sum: \"burntArea\",\n});\n// We want the province with\n// the greatest burnt area first.\nawait fires.sort({ burntArea: \"desc\" });\n\n// We log the results. By default, the method\n// logs the first 10 rows, but there is 13\n// rows in our data. We also log the data types.\nawait fires.logTable({ nbRowsToLog: 13, types: true });\n\n// And we can write the data to a parquet, json or csv file.\nawait fires.writeData(\"./fires.parquet\");\n\n// We close everything.\nawait sdb.done();\n```\n\nReturn your response as a JSON object with the following structure:\n{\n  \"data\": [\n    { \"question\": \"question1\", \"answer\": \"answer1\" },\n    { \"question\": \"question2\", \"answer\": \"answer2\" },\n    ...\n  ]\n}\n\nHere's the documentation section:\n\n\n#### `simplify`\n\nSimplifies geometries while preserving their overall coverage. A higher\ntolerance results in more significant simplification.\n\n##### Signature\n\n```typescript\nasync simplify(tolerance: number, options?: { column?: string; simplifyBoundary?: boolean }): Promise<void>;\n```\n\n##### Parameters\n\n- **`tolerance`**: - A numeric value representing the simplification tolerance.\n  A higher value leads to greater simplification.\n- **`options`**: - An optional object with configuration options:\n- **`options.column`**: - The name of the column storing the geometries. If\n  omitted, the method will automatically attempt to find a geometry column.\n- **`options.simplifyBoundary`**: - If `true` (default), the boundary of the\n  geometries will also be simplified. If `false`, only the interior of the\n  geometries will be simplified, preserving the original boundary.\n\n##### Returns\n\nA promise that resolves when the geometries have been simplified.\n\n##### Examples\n\n```ts\n// Simplify geometries in the default column with a tolerance of 0.1\nawait table.simplify(0.1);\n```\n\n```ts\n// Simplify geometries in 'myGeom' column, preserving the boundary\nawait table.simplify(0.05, { column: \"myGeom\", simplifyBoundary: false });\n```"
  },
  {
    "model": "qwen3:30b",
    "prompt": "Your task is to generate a set of up to 10 relevant questions and answers based on the provided section of documentation. The questions should be those a junior developer or data analyst might have.\n\nFor each question, you must provide a code example as the answer. You can add comments to the code to explain the steps. A brief, one-sentence explanation may be included in a comment if the code alone is not a sufficient answer.\n\nThe questions must be directly related to the documentation section provided below and must not ask about topics outside its scope. The answer should be grounded in the documentation provided. Do not make assumptions.\n\nWrite simple and straightforward code examples. Don't create functions to encapsulate your code.\n\nYour answers should always be wrapped in triple backticks (```ts at the beginning and ``` at the end) for code blocks.\n\nIf the documentation section is about SimpleDB, make sure to wrap your answer with:\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\nconst sdb = new SimpleDB();\n[PUT THE CODE EXAMPLE HERE. IF THERE IS NO CODE TO ADD, JUST ADD A COMMENT SAYING \"Do your magic here!\"]\nawait sdb.done();\n```\n\nIf the documentation section is about SimpleTable, make sure to wrap your answer with:\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\nconst sdb = new SimpleDB();\nconst table = sdb.newTable();\nawait table.loadData(\"path/to/your/data.csv\"); // Remove this line if not needed or change the file extension if relevant\n[PUT THE CODE EXAMPLE HERE. IF THERE IS NO CODE TO ADD, JUST ADD A COMMENT SAYING \"Do your magic here!\"]\nawait sdb.done();\n```\n\nIf you need inspiration, here is a comprehensive example with comments.\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\n\n// We start a SimpleDB instance.\nconst sdb = new SimpleDB();\n\n// We create a new table\nconst fires = sdb.newTable(\"fires\");\n// We fetch the wildfires data. It's a csv.\nawait fires.loadData(\n  \"data/firesCanada2023.csv\",\n);\n\n// We summarize to count the number of fires\n// and sum up the area burnt in each province.\nawait fires.summarize({\n  values: \"hectares\",\n  categories: \"province\",\n  summaries: [\"count\", \"sum\"],\n  decimals: 0,\n});\n// We rename columns.\nawait fires.renameColumns({\n  count: \"nbFires\",\n  sum: \"burntArea\",\n});\n// We want the province with\n// the greatest burnt area first.\nawait fires.sort({ burntArea: \"desc\" });\n\n// We log the results. By default, the method\n// logs the first 10 rows, but there is 13\n// rows in our data. We also log the data types.\nawait fires.logTable({ nbRowsToLog: 13, types: true });\n\n// And we can write the data to a parquet, json or csv file.\nawait fires.writeData(\"./fires.parquet\");\n\n// We close everything.\nawait sdb.done();\n```\n\nReturn your response as a JSON object with the following structure:\n{\n  \"data\": [\n    { \"question\": \"question1\", \"answer\": \"answer1\" },\n    { \"question\": \"question2\", \"answer\": \"answer2\" },\n    ...\n  ]\n}\n\nHere's the documentation section:\n\n\n#### `centroid`\n\nComputes the centroid of geometries. The values are returned in the SRS unit of\nthe input geometries.\n\n##### Signature\n\n```typescript\nasync centroid(newColumn: string, options?: { column?: string }): Promise<void>;\n```\n\n##### Parameters\n\n- **`newColumn`**: - The name of the new column where the computed centroid\n  geometries will be stored.\n- **`options`**: - An optional object with configuration options:\n- **`options.column`**: - The name of the column storing the geometries. If\n  omitted, the method will automatically attempt to find a geometry column.\n\n##### Returns\n\nA promise that resolves when the centroids have been computed.\n\n##### Examples\n\n```ts\n// Compute the centroid of geometries in the default column, storing results in 'centerPoint'\nawait table.centroid(\"centerPoint\");\n```\n\n```ts\n// Compute the centroid of geometries in a specific column named 'areaGeom'\nawait table.centroid(\"areaCentroid\", { column: \"areaGeom\" });\n```"
  },
  {
    "model": "qwen3:30b",
    "prompt": "Your task is to generate a set of up to 10 relevant questions and answers based on the provided section of documentation. The questions should be those a junior developer or data analyst might have.\n\nFor each question, you must provide a code example as the answer. You can add comments to the code to explain the steps. A brief, one-sentence explanation may be included in a comment if the code alone is not a sufficient answer.\n\nThe questions must be directly related to the documentation section provided below and must not ask about topics outside its scope. The answer should be grounded in the documentation provided. Do not make assumptions.\n\nWrite simple and straightforward code examples. Don't create functions to encapsulate your code.\n\nYour answers should always be wrapped in triple backticks (```ts at the beginning and ``` at the end) for code blocks.\n\nIf the documentation section is about SimpleDB, make sure to wrap your answer with:\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\nconst sdb = new SimpleDB();\n[PUT THE CODE EXAMPLE HERE. IF THERE IS NO CODE TO ADD, JUST ADD A COMMENT SAYING \"Do your magic here!\"]\nawait sdb.done();\n```\n\nIf the documentation section is about SimpleTable, make sure to wrap your answer with:\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\nconst sdb = new SimpleDB();\nconst table = sdb.newTable();\nawait table.loadData(\"path/to/your/data.csv\"); // Remove this line if not needed or change the file extension if relevant\n[PUT THE CODE EXAMPLE HERE. IF THERE IS NO CODE TO ADD, JUST ADD A COMMENT SAYING \"Do your magic here!\"]\nawait sdb.done();\n```\n\nIf you need inspiration, here is a comprehensive example with comments.\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\n\n// We start a SimpleDB instance.\nconst sdb = new SimpleDB();\n\n// We create a new table\nconst fires = sdb.newTable(\"fires\");\n// We fetch the wildfires data. It's a csv.\nawait fires.loadData(\n  \"data/firesCanada2023.csv\",\n);\n\n// We summarize to count the number of fires\n// and sum up the area burnt in each province.\nawait fires.summarize({\n  values: \"hectares\",\n  categories: \"province\",\n  summaries: [\"count\", \"sum\"],\n  decimals: 0,\n});\n// We rename columns.\nawait fires.renameColumns({\n  count: \"nbFires\",\n  sum: \"burntArea\",\n});\n// We want the province with\n// the greatest burnt area first.\nawait fires.sort({ burntArea: \"desc\" });\n\n// We log the results. By default, the method\n// logs the first 10 rows, but there is 13\n// rows in our data. We also log the data types.\nawait fires.logTable({ nbRowsToLog: 13, types: true });\n\n// And we can write the data to a parquet, json or csv file.\nawait fires.writeData(\"./fires.parquet\");\n\n// We close everything.\nawait sdb.done();\n```\n\nReturn your response as a JSON object with the following structure:\n{\n  \"data\": [\n    { \"question\": \"question1\", \"answer\": \"answer1\" },\n    { \"question\": \"question2\", \"answer\": \"answer2\" },\n    ...\n  ]\n}\n\nHere's the documentation section:\n\n\n#### `distance`\n\nComputes the distance between geometries in two specified columns. By default,\nthe distance is calculated in the Spatial Reference System (SRS) unit of the\ninput geometries. You can optionally specify `\"spheroid\"` or `\"haversine\"`\nmethods to get results in meters or kilometers. If using `\"spheroid\"` or\n`\"haversine\"`, the input geometries must be in the EPSG:4326 coordinate system\n(WGS84), with `[latitude, longitude]` axis order.\n\n##### Signature\n\n```typescript\nasync distance(column1: string, column2: string, newColumn: string, options?: { unit?: \"m\" | \"km\"; method?: \"srs\" | \"haversine\" | \"spheroid\"; decimals?: number }): Promise<void>;\n```\n\n##### Parameters\n\n- **`column1`**: - The name of the first column storing geometries.\n- **`column2`**: - The name of the second column storing geometries.\n- **`newColumn`**: - The name of the new column where the computed distances\n  will be stored.\n- **`options`**: - An optional object with configuration options:\n- **`options.method`**: - The method to use for distance calculations: `\"srs\"`\n  (default, uses SRS unit), `\"haversine\"` (meters, requires EPSG:4326), or\n  `\"spheroid\"` (meters, requires EPSG:4326, most accurate but slowest).\n- **`options.unit`**: - If `method` is `\"spheroid\"` or `\"haversine\"`, you can\n  choose between `\"m\"` (meters, default) or `\"km\"` (kilometers).\n- **`options.decimals`**: - The number of decimal places to round the distance\n  values. Defaults to `undefined` (no rounding).\n\n##### Returns\n\nA promise that resolves when the distances have been computed.\n\n##### Examples\n\n```ts\n// Compute distance between 'geomA' and 'geomB' in SRS units, store in 'distance_srs'\nawait table.distance(\"geomA\", \"geomB\", \"distance_srs\");\n```\n\n```ts\n// Compute Haversine distance in meters between 'point1' and 'point2', store in 'distance_m'\n// Input geometries must be in EPSG:4326.\nawait table.distance(\"point1\", \"point2\", \"distance_m\", { method: \"haversine\" });\n```\n\n```ts\n// Compute Haversine distance in kilometers, rounded to 2 decimal places\n// Input geometries must be in EPSG:4326.\nawait table.distance(\"point1\", \"point2\", \"distance_km\", {\n  method: \"haversine\",\n  unit: \"km\",\n  decimals: 2,\n});\n```\n\n```ts\n// Compute Spheroid distance in kilometers\n// Input geometries must be in EPSG:4326.\nawait table.distance(\"area1\", \"area2\", \"distance_spheroid_km\", {\n  method: \"spheroid\",\n  unit: \"km\",\n});\n```"
  },
  {
    "model": "qwen3:30b",
    "prompt": "Your task is to generate a set of up to 10 relevant questions and answers based on the provided section of documentation. The questions should be those a junior developer or data analyst might have.\n\nFor each question, you must provide a code example as the answer. You can add comments to the code to explain the steps. A brief, one-sentence explanation may be included in a comment if the code alone is not a sufficient answer.\n\nThe questions must be directly related to the documentation section provided below and must not ask about topics outside its scope. The answer should be grounded in the documentation provided. Do not make assumptions.\n\nWrite simple and straightforward code examples. Don't create functions to encapsulate your code.\n\nYour answers should always be wrapped in triple backticks (```ts at the beginning and ``` at the end) for code blocks.\n\nIf the documentation section is about SimpleDB, make sure to wrap your answer with:\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\nconst sdb = new SimpleDB();\n[PUT THE CODE EXAMPLE HERE. IF THERE IS NO CODE TO ADD, JUST ADD A COMMENT SAYING \"Do your magic here!\"]\nawait sdb.done();\n```\n\nIf the documentation section is about SimpleTable, make sure to wrap your answer with:\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\nconst sdb = new SimpleDB();\nconst table = sdb.newTable();\nawait table.loadData(\"path/to/your/data.csv\"); // Remove this line if not needed or change the file extension if relevant\n[PUT THE CODE EXAMPLE HERE. IF THERE IS NO CODE TO ADD, JUST ADD A COMMENT SAYING \"Do your magic here!\"]\nawait sdb.done();\n```\n\nIf you need inspiration, here is a comprehensive example with comments.\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\n\n// We start a SimpleDB instance.\nconst sdb = new SimpleDB();\n\n// We create a new table\nconst fires = sdb.newTable(\"fires\");\n// We fetch the wildfires data. It's a csv.\nawait fires.loadData(\n  \"data/firesCanada2023.csv\",\n);\n\n// We summarize to count the number of fires\n// and sum up the area burnt in each province.\nawait fires.summarize({\n  values: \"hectares\",\n  categories: \"province\",\n  summaries: [\"count\", \"sum\"],\n  decimals: 0,\n});\n// We rename columns.\nawait fires.renameColumns({\n  count: \"nbFires\",\n  sum: \"burntArea\",\n});\n// We want the province with\n// the greatest burnt area first.\nawait fires.sort({ burntArea: \"desc\" });\n\n// We log the results. By default, the method\n// logs the first 10 rows, but there is 13\n// rows in our data. We also log the data types.\nawait fires.logTable({ nbRowsToLog: 13, types: true });\n\n// And we can write the data to a parquet, json or csv file.\nawait fires.writeData(\"./fires.parquet\");\n\n// We close everything.\nawait sdb.done();\n```\n\nReturn your response as a JSON object with the following structure:\n{\n  \"data\": [\n    { \"question\": \"question1\", \"answer\": \"answer1\" },\n    { \"question\": \"question2\", \"answer\": \"answer2\" },\n    ...\n  ]\n}\n\nHere's the documentation section:\n\n\n#### `unnestGeo`\n\nUnnests geometries recursively, transforming multi-part geometries (e.g.,\nMultiPolygon) into individual single-part geometries (e.g., Polygon).\n\n##### Signature\n\n```typescript\nasync unnestGeo(column?: string): Promise<void>;\n```\n\n##### Parameters\n\n- **`column`**: - The name of the column storing the geometries to be unnested.\n  If omitted, the method will automatically attempt to find a geometry column.\n\n##### Returns\n\nA promise that resolves when the geometries have been unnested.\n\n##### Examples\n\n```ts\n// Unnest geometries in the default column\nawait table.unnestGeo();\n```\n\n```ts\n// Unnest geometries in a specific column named 'multiGeom'\nawait table.unnestGeo(\"multiGeom\");\n```"
  },
  {
    "model": "qwen3:30b",
    "prompt": "Your task is to generate a set of up to 10 relevant questions and answers based on the provided section of documentation. The questions should be those a junior developer or data analyst might have.\n\nFor each question, you must provide a code example as the answer. You can add comments to the code to explain the steps. A brief, one-sentence explanation may be included in a comment if the code alone is not a sufficient answer.\n\nThe questions must be directly related to the documentation section provided below and must not ask about topics outside its scope. The answer should be grounded in the documentation provided. Do not make assumptions.\n\nWrite simple and straightforward code examples. Don't create functions to encapsulate your code.\n\nYour answers should always be wrapped in triple backticks (```ts at the beginning and ``` at the end) for code blocks.\n\nIf the documentation section is about SimpleDB, make sure to wrap your answer with:\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\nconst sdb = new SimpleDB();\n[PUT THE CODE EXAMPLE HERE. IF THERE IS NO CODE TO ADD, JUST ADD A COMMENT SAYING \"Do your magic here!\"]\nawait sdb.done();\n```\n\nIf the documentation section is about SimpleTable, make sure to wrap your answer with:\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\nconst sdb = new SimpleDB();\nconst table = sdb.newTable();\nawait table.loadData(\"path/to/your/data.csv\"); // Remove this line if not needed or change the file extension if relevant\n[PUT THE CODE EXAMPLE HERE. IF THERE IS NO CODE TO ADD, JUST ADD A COMMENT SAYING \"Do your magic here!\"]\nawait sdb.done();\n```\n\nIf you need inspiration, here is a comprehensive example with comments.\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\n\n// We start a SimpleDB instance.\nconst sdb = new SimpleDB();\n\n// We create a new table\nconst fires = sdb.newTable(\"fires\");\n// We fetch the wildfires data. It's a csv.\nawait fires.loadData(\n  \"data/firesCanada2023.csv\",\n);\n\n// We summarize to count the number of fires\n// and sum up the area burnt in each province.\nawait fires.summarize({\n  values: \"hectares\",\n  categories: \"province\",\n  summaries: [\"count\", \"sum\"],\n  decimals: 0,\n});\n// We rename columns.\nawait fires.renameColumns({\n  count: \"nbFires\",\n  sum: \"burntArea\",\n});\n// We want the province with\n// the greatest burnt area first.\nawait fires.sort({ burntArea: \"desc\" });\n\n// We log the results. By default, the method\n// logs the first 10 rows, but there is 13\n// rows in our data. We also log the data types.\nawait fires.logTable({ nbRowsToLog: 13, types: true });\n\n// And we can write the data to a parquet, json or csv file.\nawait fires.writeData(\"./fires.parquet\");\n\n// We close everything.\nawait sdb.done();\n```\n\nReturn your response as a JSON object with the following structure:\n{\n  \"data\": [\n    { \"question\": \"question1\", \"answer\": \"answer1\" },\n    { \"question\": \"question2\", \"answer\": \"answer2\" },\n    ...\n  ]\n}\n\nHere's the documentation section:\n\n\n#### `linesToPolygons`\n\nTransforms closed linestring geometries into polygon geometries.\n\n##### Signature\n\n```typescript\nasync linesToPolygons(column?: string): Promise<void>;\n```\n\n##### Parameters\n\n- **`column`**: - The name of the column storing the linestring geometries. If\n  omitted, the method will automatically attempt to find a geometry column.\n\n##### Returns\n\nA promise that resolves when the transformation is complete.\n\n##### Examples\n\n```ts\n// Transform closed linestrings in the default geometry column into polygons\nawait table.linesToPolygons();\n```\n\n```ts\n// Transform closed linestrings in a specific column named 'routeLines' into polygons\nawait table.linesToPolygons(\"routeLines\");\n```"
  },
  {
    "model": "qwen3:30b",
    "prompt": "Your task is to generate a set of up to 10 relevant questions and answers based on the provided section of documentation. The questions should be those a junior developer or data analyst might have.\n\nFor each question, you must provide a code example as the answer. You can add comments to the code to explain the steps. A brief, one-sentence explanation may be included in a comment if the code alone is not a sufficient answer.\n\nThe questions must be directly related to the documentation section provided below and must not ask about topics outside its scope. The answer should be grounded in the documentation provided. Do not make assumptions.\n\nWrite simple and straightforward code examples. Don't create functions to encapsulate your code.\n\nYour answers should always be wrapped in triple backticks (```ts at the beginning and ``` at the end) for code blocks.\n\nIf the documentation section is about SimpleDB, make sure to wrap your answer with:\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\nconst sdb = new SimpleDB();\n[PUT THE CODE EXAMPLE HERE. IF THERE IS NO CODE TO ADD, JUST ADD A COMMENT SAYING \"Do your magic here!\"]\nawait sdb.done();\n```\n\nIf the documentation section is about SimpleTable, make sure to wrap your answer with:\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\nconst sdb = new SimpleDB();\nconst table = sdb.newTable();\nawait table.loadData(\"path/to/your/data.csv\"); // Remove this line if not needed or change the file extension if relevant\n[PUT THE CODE EXAMPLE HERE. IF THERE IS NO CODE TO ADD, JUST ADD A COMMENT SAYING \"Do your magic here!\"]\nawait sdb.done();\n```\n\nIf you need inspiration, here is a comprehensive example with comments.\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\n\n// We start a SimpleDB instance.\nconst sdb = new SimpleDB();\n\n// We create a new table\nconst fires = sdb.newTable(\"fires\");\n// We fetch the wildfires data. It's a csv.\nawait fires.loadData(\n  \"data/firesCanada2023.csv\",\n);\n\n// We summarize to count the number of fires\n// and sum up the area burnt in each province.\nawait fires.summarize({\n  values: \"hectares\",\n  categories: \"province\",\n  summaries: [\"count\", \"sum\"],\n  decimals: 0,\n});\n// We rename columns.\nawait fires.renameColumns({\n  count: \"nbFires\",\n  sum: \"burntArea\",\n});\n// We want the province with\n// the greatest burnt area first.\nawait fires.sort({ burntArea: \"desc\" });\n\n// We log the results. By default, the method\n// logs the first 10 rows, but there is 13\n// rows in our data. We also log the data types.\nawait fires.logTable({ nbRowsToLog: 13, types: true });\n\n// And we can write the data to a parquet, json or csv file.\nawait fires.writeData(\"./fires.parquet\");\n\n// We close everything.\nawait sdb.done();\n```\n\nReturn your response as a JSON object with the following structure:\n{\n  \"data\": [\n    { \"question\": \"question1\", \"answer\": \"answer1\" },\n    { \"question\": \"question2\", \"answer\": \"answer2\" },\n    ...\n  ]\n}\n\nHere's the documentation section:\n\n\n#### `getGeoData`\n\nReturns the table's geospatial data as a GeoJSON object. If the table has\nmultiple geometry columns, you must specify which one to use. If the geometry\ncolumn's projection is WGS84 or EPSG:4326 (`[latitude, longitude]` axis order),\nthe coordinates will be flipped to follow the RFC7946 standard\n(`[longitude, latitude]` axis order) in the output GeoJSON.\n\n##### Signature\n\n```typescript\nasync getGeoData(column?: string, options?: { rewind?: boolean }): Promise<{ type: string; features: unknown[] }>;\n```\n\n##### Parameters\n\n- **`column`**: - The name of the column storing the geometries. If omitted, the\n  method will automatically attempt to find a geometry column.\n- **`options`**: - An optional object with configuration options:\n- **`options.rewind`**: - If `true`, rewinds the coordinates of polygons to\n  follow the spherical winding order (important for D3.js). Defaults to `false`.\n\n##### Returns\n\nA promise that resolves to a GeoJSON object representing the table's geospatial\ndata.\n\n##### Examples\n\n```ts\n// Get GeoJSON data from the default geometry column\nconst geojson = await table.getGeoData();\nconsole.log(geojson);\n```\n\n```ts\n// Get GeoJSON data from a specific geometry column named 'myGeometries'\nconst myGeomJson = await table.getGeoData(\"myGeometries\");\nconsole.log(myGeomJson);\n```\n\n```ts\n// Get GeoJSON data and rewind polygon coordinates for D3.js compatibility\nconst rewoundGeojson = await table.getGeoData(undefined, { rewind: true });\nconsole.log(rewoundGeojson);\n```"
  },
  {
    "model": "qwen3:30b",
    "prompt": "Your task is to generate a set of up to 10 relevant questions and answers based on the provided section of documentation. The questions should be those a junior developer or data analyst might have.\n\nFor each question, you must provide a code example as the answer. You can add comments to the code to explain the steps. A brief, one-sentence explanation may be included in a comment if the code alone is not a sufficient answer.\n\nThe questions must be directly related to the documentation section provided below and must not ask about topics outside its scope. The answer should be grounded in the documentation provided. Do not make assumptions.\n\nWrite simple and straightforward code examples. Don't create functions to encapsulate your code.\n\nYour answers should always be wrapped in triple backticks (```ts at the beginning and ``` at the end) for code blocks.\n\nIf the documentation section is about SimpleDB, make sure to wrap your answer with:\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\nconst sdb = new SimpleDB();\n[PUT THE CODE EXAMPLE HERE. IF THERE IS NO CODE TO ADD, JUST ADD A COMMENT SAYING \"Do your magic here!\"]\nawait sdb.done();\n```\n\nIf the documentation section is about SimpleTable, make sure to wrap your answer with:\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\nconst sdb = new SimpleDB();\nconst table = sdb.newTable();\nawait table.loadData(\"path/to/your/data.csv\"); // Remove this line if not needed or change the file extension if relevant\n[PUT THE CODE EXAMPLE HERE. IF THERE IS NO CODE TO ADD, JUST ADD A COMMENT SAYING \"Do your magic here!\"]\nawait sdb.done();\n```\n\nIf you need inspiration, here is a comprehensive example with comments.\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\n\n// We start a SimpleDB instance.\nconst sdb = new SimpleDB();\n\n// We create a new table\nconst fires = sdb.newTable(\"fires\");\n// We fetch the wildfires data. It's a csv.\nawait fires.loadData(\n  \"data/firesCanada2023.csv\",\n);\n\n// We summarize to count the number of fires\n// and sum up the area burnt in each province.\nawait fires.summarize({\n  values: \"hectares\",\n  categories: \"province\",\n  summaries: [\"count\", \"sum\"],\n  decimals: 0,\n});\n// We rename columns.\nawait fires.renameColumns({\n  count: \"nbFires\",\n  sum: \"burntArea\",\n});\n// We want the province with\n// the greatest burnt area first.\nawait fires.sort({ burntArea: \"desc\" });\n\n// We log the results. By default, the method\n// logs the first 10 rows, but there is 13\n// rows in our data. We also log the data types.\nawait fires.logTable({ nbRowsToLog: 13, types: true });\n\n// And we can write the data to a parquet, json or csv file.\nawait fires.writeData(\"./fires.parquet\");\n\n// We close everything.\nawait sdb.done();\n```\n\nReturn your response as a JSON object with the following structure:\n{\n  \"data\": [\n    { \"question\": \"question1\", \"answer\": \"answer1\" },\n    { \"question\": \"question2\", \"answer\": \"answer2\" },\n    ...\n  ]\n}\n\nHere's the documentation section:\n\n\n#### `writeData`\n\nWrites the table's data to a file in various formats (CSV, JSON, Parquet,\nDuckDB, SQLite). If the specified path does not exist, it will be created.\n\n##### Signature\n\n```typescript\nasync writeData(file: string, options?: { compression?: boolean; dataAsArrays?: boolean; formatDates?: boolean }): Promise<void>;\n```\n\n##### Parameters\n\n- **`file`**: - The absolute path to the output file (e.g., `\"./output.csv\"`,\n  `\"./output.json\"`).\n- **`options`**: - An optional object with configuration options:\n- **`options.compression`**: - A boolean indicating whether to compress the\n  output file. If `true`, CSV and JSON files will be compressed with GZIP, while\n  Parquet files will use ZSTD. Defaults to `false`.\n- **`options.dataAsArrays`**: - For JSON files only. If `true`, JSON files are\n  written as a single object with arrays for each column (e.g.,\n  `{ \"col1\": [v1, v2], \"col2\": [v3, v4] }`) instead of an array of objects. This\n  can reduce file size for web projects. You can use the `arraysToData` function\n  from the\n  [journalism library](https://jsr.io/@nshiab/journalism/doc/~/arraysToData) to\n  convert it back.\n- **`options.formatDates`**: - For CSV and JSON files only. If `true`, date and\n  timestamp columns will be formatted as ISO 8601 strings (e.g.,\n  `\"2025-01-01T01:00:00.000Z\"`). Defaults to `false`.\n\n##### Returns\n\nA promise that resolves when the data has been written to the file.\n\n##### Examples\n\n```ts\n// Write data to a CSV file\nawait table.writeData(\"./output.csv\");\n```\n\n```ts\n// Write data to a JSON file with GZIP compression.\n// The output file will be named output.json.gz.\nawait table.writeData(\"./output.json\", { compression: true });\n```\n\n```ts\n// Write data to a Parquet file\nawait table.writeData(\"./output.parquet\");\n```\n\n```ts\n// Write data to a DuckDB database file\nawait table.writeData(\"./my_database.db\");\n```\n\n```ts\n// Write data to a SQLite database file\nawait table.writeData(\"./my_database.sqlite\");\n```\n\n```ts\n// Write JSON data with dates formatted as ISO strings\nawait table.writeData(\"./output_dates.json\", { formatDates: true });\n```"
  },
  {
    "model": "qwen3:30b",
    "prompt": "Your task is to generate a set of up to 10 relevant questions and answers based on the provided section of documentation. The questions should be those a junior developer or data analyst might have.\n\nFor each question, you must provide a code example as the answer. You can add comments to the code to explain the steps. A brief, one-sentence explanation may be included in a comment if the code alone is not a sufficient answer.\n\nThe questions must be directly related to the documentation section provided below and must not ask about topics outside its scope. The answer should be grounded in the documentation provided. Do not make assumptions.\n\nWrite simple and straightforward code examples. Don't create functions to encapsulate your code.\n\nYour answers should always be wrapped in triple backticks (```ts at the beginning and ``` at the end) for code blocks.\n\nIf the documentation section is about SimpleDB, make sure to wrap your answer with:\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\nconst sdb = new SimpleDB();\n[PUT THE CODE EXAMPLE HERE. IF THERE IS NO CODE TO ADD, JUST ADD A COMMENT SAYING \"Do your magic here!\"]\nawait sdb.done();\n```\n\nIf the documentation section is about SimpleTable, make sure to wrap your answer with:\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\nconst sdb = new SimpleDB();\nconst table = sdb.newTable();\nawait table.loadData(\"path/to/your/data.csv\"); // Remove this line if not needed or change the file extension if relevant\n[PUT THE CODE EXAMPLE HERE. IF THERE IS NO CODE TO ADD, JUST ADD A COMMENT SAYING \"Do your magic here!\"]\nawait sdb.done();\n```\n\nIf you need inspiration, here is a comprehensive example with comments.\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\n\n// We start a SimpleDB instance.\nconst sdb = new SimpleDB();\n\n// We create a new table\nconst fires = sdb.newTable(\"fires\");\n// We fetch the wildfires data. It's a csv.\nawait fires.loadData(\n  \"data/firesCanada2023.csv\",\n);\n\n// We summarize to count the number of fires\n// and sum up the area burnt in each province.\nawait fires.summarize({\n  values: \"hectares\",\n  categories: \"province\",\n  summaries: [\"count\", \"sum\"],\n  decimals: 0,\n});\n// We rename columns.\nawait fires.renameColumns({\n  count: \"nbFires\",\n  sum: \"burntArea\",\n});\n// We want the province with\n// the greatest burnt area first.\nawait fires.sort({ burntArea: \"desc\" });\n\n// We log the results. By default, the method\n// logs the first 10 rows, but there is 13\n// rows in our data. We also log the data types.\nawait fires.logTable({ nbRowsToLog: 13, types: true });\n\n// And we can write the data to a parquet, json or csv file.\nawait fires.writeData(\"./fires.parquet\");\n\n// We close everything.\nawait sdb.done();\n```\n\nReturn your response as a JSON object with the following structure:\n{\n  \"data\": [\n    { \"question\": \"question1\", \"answer\": \"answer1\" },\n    { \"question\": \"question2\", \"answer\": \"answer2\" },\n    ...\n  ]\n}\n\nHere's the documentation section:\n\n\n#### `toSheet`\n\nClears a Google Sheet and populates it with the table's data. This method uses\nthe `overwriteSheetData` function from the\n[journalism library](https://jsr.io/@nshiab/journalism/doc/~/overwriteSheetData).\nRefer to its documentation for more details.\n\nBy default, this function looks for the API key in `GOOGLE_PRIVATE_KEY` and the\nservice account email in `GOOGLE_SERVICE_ACCOUNT_EMAIL` environment variables.\nIf you don't have credentials, refer to the\n[Google Spreadsheet authentication guide](https://theoephraim.github.io/node-google-spreadsheet/#/guides/authentication).\n\n##### Signature\n\n```typescript\nasync toSheet(sheetUrl: string, options?: { prepend?: string; lastUpdate?: boolean; timeZone?: \"Canada/Atlantic\" | \"Canada/Central\" | \"Canada/Eastern\" | \"Canada/Mountain\" | \"Canada/Newfoundland\" | \"Canada/Pacific\" | \"Canada/Saskatchewan\" | \"Canada/Yukon\"; raw?: boolean; apiEmail?: string; apiKey?: string }): Promise<void>;\n```\n\n##### Parameters\n\n- **`sheetUrl`**: - The URL pointing to a specific Google Sheet (e.g.,\n  `\"https://docs.google.com/spreadsheets/d/.../edit#gid=0\"`).\n- **`options`**: - An optional object with configuration options:\n- **`options.prepend`**: - Text to be added before the data in the sheet.\n- **`options.lastUpdate`**: - If `true`, adds a row before the data with the\n  date of the update.\n- **`options.timeZone`**: - If `lastUpdate` is `true`, this option allows\n  formatting the date to a specific time zone.\n- **`options.raw`**: - If `true`, Google Sheets will not attempt to guess the\n  data type and will not format or parse the values.\n- **`options.apiEmail`**: - If your API email is stored under a different\n  environment variable name, use this option to specify it.\n- **`options.apiKey`**: - If your API key is stored under a different\n  environment variable name, use this option to specify it.\n\n##### Returns\n\nA promise that resolves when the data has been written to the Google Sheet.\n\n##### Examples\n\n```ts\n// Write table data to a Google Sheet\nawait table.toSheet(\"https://docs.google.com/spreadsheets/d/.../edit#gid=0\");\n```\n\n```ts\n// Write data to a Google Sheet, prepending a message and including the last update timestamp\nawait table.toSheet(\"https://docs.google.com/spreadsheets/d/.../edit#gid=0\", {\n  prepend: \"Report generated on:\",\n  lastUpdate: true,\n  timeZone: \"Canada/Eastern\",\n});\n```"
  },
  {
    "model": "qwen3:30b",
    "prompt": "Your task is to generate a set of up to 10 relevant questions and answers based on the provided section of documentation. The questions should be those a junior developer or data analyst might have.\n\nFor each question, you must provide a code example as the answer. You can add comments to the code to explain the steps. A brief, one-sentence explanation may be included in a comment if the code alone is not a sufficient answer.\n\nThe questions must be directly related to the documentation section provided below and must not ask about topics outside its scope. The answer should be grounded in the documentation provided. Do not make assumptions.\n\nWrite simple and straightforward code examples. Don't create functions to encapsulate your code.\n\nYour answers should always be wrapped in triple backticks (```ts at the beginning and ``` at the end) for code blocks.\n\nIf the documentation section is about SimpleDB, make sure to wrap your answer with:\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\nconst sdb = new SimpleDB();\n[PUT THE CODE EXAMPLE HERE. IF THERE IS NO CODE TO ADD, JUST ADD A COMMENT SAYING \"Do your magic here!\"]\nawait sdb.done();\n```\n\nIf the documentation section is about SimpleTable, make sure to wrap your answer with:\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\nconst sdb = new SimpleDB();\nconst table = sdb.newTable();\nawait table.loadData(\"path/to/your/data.csv\"); // Remove this line if not needed or change the file extension if relevant\n[PUT THE CODE EXAMPLE HERE. IF THERE IS NO CODE TO ADD, JUST ADD A COMMENT SAYING \"Do your magic here!\"]\nawait sdb.done();\n```\n\nIf you need inspiration, here is a comprehensive example with comments.\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\n\n// We start a SimpleDB instance.\nconst sdb = new SimpleDB();\n\n// We create a new table\nconst fires = sdb.newTable(\"fires\");\n// We fetch the wildfires data. It's a csv.\nawait fires.loadData(\n  \"data/firesCanada2023.csv\",\n);\n\n// We summarize to count the number of fires\n// and sum up the area burnt in each province.\nawait fires.summarize({\n  values: \"hectares\",\n  categories: \"province\",\n  summaries: [\"count\", \"sum\"],\n  decimals: 0,\n});\n// We rename columns.\nawait fires.renameColumns({\n  count: \"nbFires\",\n  sum: \"burntArea\",\n});\n// We want the province with\n// the greatest burnt area first.\nawait fires.sort({ burntArea: \"desc\" });\n\n// We log the results. By default, the method\n// logs the first 10 rows, but there is 13\n// rows in our data. We also log the data types.\nawait fires.logTable({ nbRowsToLog: 13, types: true });\n\n// And we can write the data to a parquet, json or csv file.\nawait fires.writeData(\"./fires.parquet\");\n\n// We close everything.\nawait sdb.done();\n```\n\nReturn your response as a JSON object with the following structure:\n{\n  \"data\": [\n    { \"question\": \"question1\", \"answer\": \"answer1\" },\n    { \"question\": \"question2\", \"answer\": \"answer2\" },\n    ...\n  ]\n}\n\nHere's the documentation section:\n\n\n#### `cache`\n\nCaches the results of computations in `./.sda-cache`. You should add\n`./.sda-cache` to your `.gitignore` file.\n\n##### Signature\n\n```typescript\nasync cache(run: () => any, options?: { ttl?: number }): Promise<void>;\n```\n\n##### Parameters\n\n- **`run`**: - A function wrapping the computations to be cached. This function\n  will be executed on the first run or if the cached data is invalid/expired.\n- **`options`**: - An optional object with configuration options:\n- **`options.ttl`**: - Time to live (in seconds). If the data in the cache is\n  older than this duration, the `run` function will be executed again to refresh\n  the cache. By default, there is no TTL, meaning the cache is only invalidated\n  if the `run` function's content changes.\n\n##### Returns\n\nA promise that resolves when the computations are complete or the data is loaded\nfrom cache.\n\n##### Examples\n\n```ts\n// Basic usage: computations are cached and re-run only if the function content changes\nconst sdb = new SimpleDB();\nconst table = sdb.newTable();\n\nawait table.cache(async () => {\n  await table.loadData(\"items.csv\");\n  await table.summarize({\n    values: \"price\",\n    categories: \"department\",\n    summaries: [\"min\", \"max\", \"mean\"],\n  });\n});\n\n// It's important to call done() on the SimpleDB instance to clean up the cache.\n// This prevents the cache from growing indefinitely.\nawait sdb.done();\n```\n\n```ts\n// Cache with a Time-To-Live (TTL) of 60 seconds\n// The computations will be re-run if the cached data is older than 1 minute or if the function content changes.\nconst sdb = new SimpleDB();\nconst table = sdb.newTable();\n\nawait table.cache(async () => {\n  await table.loadData(\"items.csv\");\n  await table.summarize({\n    values: \"price\",\n    categories: \"department\",\n    summaries: [\"min\", \"max\", \"mean\"],\n  });\n}, { ttl: 60 });\n\nawait sdb.done();\n```\n\n```ts\n// Enable verbose logging for cache operations via SimpleDB instance\nconst sdb = new SimpleDB({ cacheVerbose: true });\nconst table = sdb.newTable();\n\nawait table.cache(async () => {\n  await table.loadData(\"items.csv\");\n  await table.summarize({\n    values: \"price\",\n    categories: \"department\",\n    summaries: [\"min\", \"max\", \"mean\"],\n  });\n});\n\nawait sdb.done();\n```"
  },
  {
    "model": "qwen3:30b",
    "prompt": "Your task is to generate a set of up to 10 relevant questions and answers based on the provided section of documentation. The questions should be those a junior developer or data analyst might have.\n\nFor each question, you must provide a code example as the answer. You can add comments to the code to explain the steps. A brief, one-sentence explanation may be included in a comment if the code alone is not a sufficient answer.\n\nThe questions must be directly related to the documentation section provided below and must not ask about topics outside its scope. The answer should be grounded in the documentation provided. Do not make assumptions.\n\nWrite simple and straightforward code examples. Don't create functions to encapsulate your code.\n\nYour answers should always be wrapped in triple backticks (```ts at the beginning and ``` at the end) for code blocks.\n\nIf the documentation section is about SimpleDB, make sure to wrap your answer with:\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\nconst sdb = new SimpleDB();\n[PUT THE CODE EXAMPLE HERE. IF THERE IS NO CODE TO ADD, JUST ADD A COMMENT SAYING \"Do your magic here!\"]\nawait sdb.done();\n```\n\nIf the documentation section is about SimpleTable, make sure to wrap your answer with:\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\nconst sdb = new SimpleDB();\nconst table = sdb.newTable();\nawait table.loadData(\"path/to/your/data.csv\"); // Remove this line if not needed or change the file extension if relevant\n[PUT THE CODE EXAMPLE HERE. IF THERE IS NO CODE TO ADD, JUST ADD A COMMENT SAYING \"Do your magic here!\"]\nawait sdb.done();\n```\n\nIf you need inspiration, here is a comprehensive example with comments.\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\n\n// We start a SimpleDB instance.\nconst sdb = new SimpleDB();\n\n// We create a new table\nconst fires = sdb.newTable(\"fires\");\n// We fetch the wildfires data. It's a csv.\nawait fires.loadData(\n  \"data/firesCanada2023.csv\",\n);\n\n// We summarize to count the number of fires\n// and sum up the area burnt in each province.\nawait fires.summarize({\n  values: \"hectares\",\n  categories: \"province\",\n  summaries: [\"count\", \"sum\"],\n  decimals: 0,\n});\n// We rename columns.\nawait fires.renameColumns({\n  count: \"nbFires\",\n  sum: \"burntArea\",\n});\n// We want the province with\n// the greatest burnt area first.\nawait fires.sort({ burntArea: \"desc\" });\n\n// We log the results. By default, the method\n// logs the first 10 rows, but there is 13\n// rows in our data. We also log the data types.\nawait fires.logTable({ nbRowsToLog: 13, types: true });\n\n// And we can write the data to a parquet, json or csv file.\nawait fires.writeData(\"./fires.parquet\");\n\n// We close everything.\nawait sdb.done();\n```\n\nReturn your response as a JSON object with the following structure:\n{\n  \"data\": [\n    { \"question\": \"question1\", \"answer\": \"answer1\" },\n    { \"question\": \"question2\", \"answer\": \"answer2\" },\n    ...\n  ]\n}\n\nHere's the documentation section:\n\n\n#### `writeChart`\n\nCreates an [Observable Plot](https://github.com/observablehq/plot) chart as an\nimage file (.png, .jpeg, or .svg) from the table data. To create maps, use the\n`writeMap` method.\n\n##### Signature\n\n```typescript\nasync writeChart(chart: (data: unknown[]) => any, path: string, options?: { style?: string; dark?: boolean }): Promise<void>;\n```\n\n##### Parameters\n\n- **`chart`**: - A function that takes data (as an array of objects) and returns\n  an Observable Plot chart (an `SVGSVGElement` or `HTMLElement`).\n- **`path`**: - The absolute path where the chart image will be saved (e.g.,\n  `\"./output/chart.png\"`).\n- **`options`**: - Optional object containing additional settings:\n- **`options.style`**: - A CSS string to customize the chart's appearance. This\n  is applied to a `<div>` element wrapping the Plot chart (which has the id\n  `chart`). Use this if the Plot `style` option is insufficient.\n- **`options.dark`**: - If `true`, switches the chart to dark mode. Defaults to\n  `false`.\n\n##### Returns\n\nA promise that resolves when the chart image has been saved.\n\n##### Examples\n\n```ts\nimport { dot, plot } from \"@observablehq/plot\";\n\nconst sdb = new SimpleDB();\nconst table = sdb.newTable();\nconst data = [{ year: 2024, value: 10 }, { year: 2025, value: 15 }];\nawait table.loadArray(data);\n\nconst chartFunction = (plotData: unknown[]) =>\n  plot({\n    marks: [\n      dot(plotData, { x: \"year\", y: \"value\" }),\n    ],\n  });\n\nconst outputPath = \"output/chart.png\";\n\nawait table.writeChart(chartFunction, outputPath);\n```"
  },
  {
    "model": "qwen3:30b",
    "prompt": "Your task is to generate a set of up to 10 relevant questions and answers based on the provided section of documentation. The questions should be those a junior developer or data analyst might have.\n\nFor each question, you must provide a code example as the answer. You can add comments to the code to explain the steps. A brief, one-sentence explanation may be included in a comment if the code alone is not a sufficient answer.\n\nThe questions must be directly related to the documentation section provided below and must not ask about topics outside its scope. The answer should be grounded in the documentation provided. Do not make assumptions.\n\nWrite simple and straightforward code examples. Don't create functions to encapsulate your code.\n\nYour answers should always be wrapped in triple backticks (```ts at the beginning and ``` at the end) for code blocks.\n\nIf the documentation section is about SimpleDB, make sure to wrap your answer with:\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\nconst sdb = new SimpleDB();\n[PUT THE CODE EXAMPLE HERE. IF THERE IS NO CODE TO ADD, JUST ADD A COMMENT SAYING \"Do your magic here!\"]\nawait sdb.done();\n```\n\nIf the documentation section is about SimpleTable, make sure to wrap your answer with:\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\nconst sdb = new SimpleDB();\nconst table = sdb.newTable();\nawait table.loadData(\"path/to/your/data.csv\"); // Remove this line if not needed or change the file extension if relevant\n[PUT THE CODE EXAMPLE HERE. IF THERE IS NO CODE TO ADD, JUST ADD A COMMENT SAYING \"Do your magic here!\"]\nawait sdb.done();\n```\n\nIf you need inspiration, here is a comprehensive example with comments.\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\n\n// We start a SimpleDB instance.\nconst sdb = new SimpleDB();\n\n// We create a new table\nconst fires = sdb.newTable(\"fires\");\n// We fetch the wildfires data. It's a csv.\nawait fires.loadData(\n  \"data/firesCanada2023.csv\",\n);\n\n// We summarize to count the number of fires\n// and sum up the area burnt in each province.\nawait fires.summarize({\n  values: \"hectares\",\n  categories: \"province\",\n  summaries: [\"count\", \"sum\"],\n  decimals: 0,\n});\n// We rename columns.\nawait fires.renameColumns({\n  count: \"nbFires\",\n  sum: \"burntArea\",\n});\n// We want the province with\n// the greatest burnt area first.\nawait fires.sort({ burntArea: \"desc\" });\n\n// We log the results. By default, the method\n// logs the first 10 rows, but there is 13\n// rows in our data. We also log the data types.\nawait fires.logTable({ nbRowsToLog: 13, types: true });\n\n// And we can write the data to a parquet, json or csv file.\nawait fires.writeData(\"./fires.parquet\");\n\n// We close everything.\nawait sdb.done();\n```\n\nReturn your response as a JSON object with the following structure:\n{\n  \"data\": [\n    { \"question\": \"question1\", \"answer\": \"answer1\" },\n    { \"question\": \"question2\", \"answer\": \"answer2\" },\n    ...\n  ]\n}\n\nHere's the documentation section:\n\n\n#### `writeMap`\n\nCreates an [Observable Plot](https://github.com/observablehq/plot) map as an\nimage file (.png, .jpeg, or .svg) from the table's geospatial data. To create\ncharts from non-geospatial data, use the `writeChart` method.\n\n##### Signature\n\n```typescript\nasync writeMap(map: (geoData: { features: { properties: Record<string, unknown> }[] }) => any, path: string, options?: { column?: string; rewind?: boolean; style?: string; dark?: boolean }): Promise<void>;\n```\n\n##### Parameters\n\n- **`map`**: - A function that takes geospatial data (in GeoJSON format) and\n  returns an Observable Plot map (an `SVGSVGElement` or `HTMLElement`).\n- **`path`**: - The absolute path where the map image will be saved (e.g.,\n  `\"./output/map.png\"`).\n- **`options`**: - An optional object with configuration options:\n- **`options.column`**: - The name of the column storing geometries. If there is\n  only one geometry column, it will be used by default.\n- **`options.rewind`**: - If `true`, rewinds the coordinates of polygons to\n  follow the spherical winding order (important for D3.js). Defaults to `true`.\n- **`options.style`**: - A CSS string to customize the map's appearance. This is\n  applied to a `<div>` element wrapping the Plot map (which has the ID `chart`).\n  Use this if the Plot `style` option is insufficient.\n- **`options.dark`**: - If `true`, switches the map to dark mode. Defaults to\n  `false`.\n\n##### Returns\n\nA promise that resolves when the map image has been saved.\n\n##### Examples\n\n```ts\nimport { geo, plot } from \"@observablehq/plot\";\n\nconst sdb = new SimpleDB();\nconst table = sdb.newTable();\nawait table.loadGeoData(\"./CanadianProvincesAndTerritories.geojson\");\n\nconst mapFunction = (geoJsonData: { features: unknown[] }) =>\n  plot({\n    projection: {\n      type: \"conic-conformal\",\n      rotate: [100, -60],\n      domain: geoJsonData,\n    },\n    marks: [\n      geo(geoJsonData, { stroke: \"black\", fill: \"lightblue\" }),\n    ],\n  });\n\nconst outputPath = \"./output/map.png\";\n\nawait table.writeMap(mapFunction, outputPath);\n```"
  },
  {
    "model": "qwen3:30b",
    "prompt": "Your task is to generate a set of up to 10 relevant questions and answers based on the provided section of documentation. The questions should be those a junior developer or data analyst might have.\n\nFor each question, you must provide a code example as the answer. You can add comments to the code to explain the steps. A brief, one-sentence explanation may be included in a comment if the code alone is not a sufficient answer.\n\nThe questions must be directly related to the documentation section provided below and must not ask about topics outside its scope. The answer should be grounded in the documentation provided. Do not make assumptions.\n\nWrite simple and straightforward code examples. Don't create functions to encapsulate your code.\n\nYour answers should always be wrapped in triple backticks (```ts at the beginning and ``` at the end) for code blocks.\n\nIf the documentation section is about SimpleDB, make sure to wrap your answer with:\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\nconst sdb = new SimpleDB();\n[PUT THE CODE EXAMPLE HERE. IF THERE IS NO CODE TO ADD, JUST ADD A COMMENT SAYING \"Do your magic here!\"]\nawait sdb.done();\n```\n\nIf the documentation section is about SimpleTable, make sure to wrap your answer with:\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\nconst sdb = new SimpleDB();\nconst table = sdb.newTable();\nawait table.loadData(\"path/to/your/data.csv\"); // Remove this line if not needed or change the file extension if relevant\n[PUT THE CODE EXAMPLE HERE. IF THERE IS NO CODE TO ADD, JUST ADD A COMMENT SAYING \"Do your magic here!\"]\nawait sdb.done();\n```\n\nIf you need inspiration, here is a comprehensive example with comments.\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\n\n// We start a SimpleDB instance.\nconst sdb = new SimpleDB();\n\n// We create a new table\nconst fires = sdb.newTable(\"fires\");\n// We fetch the wildfires data. It's a csv.\nawait fires.loadData(\n  \"data/firesCanada2023.csv\",\n);\n\n// We summarize to count the number of fires\n// and sum up the area burnt in each province.\nawait fires.summarize({\n  values: \"hectares\",\n  categories: \"province\",\n  summaries: [\"count\", \"sum\"],\n  decimals: 0,\n});\n// We rename columns.\nawait fires.renameColumns({\n  count: \"nbFires\",\n  sum: \"burntArea\",\n});\n// We want the province with\n// the greatest burnt area first.\nawait fires.sort({ burntArea: \"desc\" });\n\n// We log the results. By default, the method\n// logs the first 10 rows, but there is 13\n// rows in our data. We also log the data types.\nawait fires.logTable({ nbRowsToLog: 13, types: true });\n\n// And we can write the data to a parquet, json or csv file.\nawait fires.writeData(\"./fires.parquet\");\n\n// We close everything.\nawait sdb.done();\n```\n\nReturn your response as a JSON object with the following structure:\n{\n  \"data\": [\n    { \"question\": \"question1\", \"answer\": \"answer1\" },\n    { \"question\": \"question2\", \"answer\": \"answer2\" },\n    ...\n  ]\n}\n\nHere's the documentation section:\n\n\n#### `logTable`\n\nLogs a specified number of rows from the table to the console. By default, the\nfirst 10 rows are logged. You can optionally log the column types and filter the\ndata based on conditions. You can also use JavaScript syntax for conditions\n(e.g., `&&`, `||`, `===`, `!==`).\n\n##### Signature\n\n```typescript\nasync logTable(options?: \"all\" | number | { nbRowsToLog?: number | \"all\"; types?: boolean; conditions?: string }): Promise<void>;\n```\n\n##### Parameters\n\n- **`options`**: - Either the number of rows to log (a specific number or\n  `\"all\"`) or an object with configuration options:\n- **`options.nbRowsToLog`**: - The number of rows to log. Defaults to 10 or the\n  value set in the SimpleDB instance. Use `\"all\"` to log all rows.\n- **`options.types`**: - If `true`, logs the column types along with the data.\n  Defaults to `false`.\n- **`options.conditions`**: - A SQL `WHERE` clause condition to filter the data\n  before logging. Defaults to no condition.\n\n##### Returns\n\nA promise that resolves when the table data has been logged.\n\n##### Examples\n\n```ts\n// Log the first 10 rows (default behavior)\nawait table.logTable();\n```\n\n```ts\n// Log the first 50 rows\nawait table.logTable(50);\n```\n\n```ts\n// Log all rows\nawait table.logTable(\"all\");\n```\n\n```ts\n// Log the first 20 rows and include column types\nawait table.logTable({ nbRowsToLog: 20, types: true });\n```\n\n```ts\n// Log rows where 'status' is 'active' (using JS syntax for conditions)\nawait table.logTable({ conditions: `status === 'active'` });\n```"
  },
  {
    "model": "qwen3:30b",
    "prompt": "Your task is to generate a set of up to 10 relevant questions and answers based on the provided section of documentation. The questions should be those a junior developer or data analyst might have.\n\nFor each question, you must provide a code example as the answer. You can add comments to the code to explain the steps. A brief, one-sentence explanation may be included in a comment if the code alone is not a sufficient answer.\n\nThe questions must be directly related to the documentation section provided below and must not ask about topics outside its scope. The answer should be grounded in the documentation provided. Do not make assumptions.\n\nWrite simple and straightforward code examples. Don't create functions to encapsulate your code.\n\nYour answers should always be wrapped in triple backticks (```ts at the beginning and ``` at the end) for code blocks.\n\nIf the documentation section is about SimpleDB, make sure to wrap your answer with:\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\nconst sdb = new SimpleDB();\n[PUT THE CODE EXAMPLE HERE. IF THERE IS NO CODE TO ADD, JUST ADD A COMMENT SAYING \"Do your magic here!\"]\nawait sdb.done();\n```\n\nIf the documentation section is about SimpleTable, make sure to wrap your answer with:\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\nconst sdb = new SimpleDB();\nconst table = sdb.newTable();\nawait table.loadData(\"path/to/your/data.csv\"); // Remove this line if not needed or change the file extension if relevant\n[PUT THE CODE EXAMPLE HERE. IF THERE IS NO CODE TO ADD, JUST ADD A COMMENT SAYING \"Do your magic here!\"]\nawait sdb.done();\n```\n\nIf you need inspiration, here is a comprehensive example with comments.\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\n\n// We start a SimpleDB instance.\nconst sdb = new SimpleDB();\n\n// We create a new table\nconst fires = sdb.newTable(\"fires\");\n// We fetch the wildfires data. It's a csv.\nawait fires.loadData(\n  \"data/firesCanada2023.csv\",\n);\n\n// We summarize to count the number of fires\n// and sum up the area burnt in each province.\nawait fires.summarize({\n  values: \"hectares\",\n  categories: \"province\",\n  summaries: [\"count\", \"sum\"],\n  decimals: 0,\n});\n// We rename columns.\nawait fires.renameColumns({\n  count: \"nbFires\",\n  sum: \"burntArea\",\n});\n// We want the province with\n// the greatest burnt area first.\nawait fires.sort({ burntArea: \"desc\" });\n\n// We log the results. By default, the method\n// logs the first 10 rows, but there is 13\n// rows in our data. We also log the data types.\nawait fires.logTable({ nbRowsToLog: 13, types: true });\n\n// And we can write the data to a parquet, json or csv file.\nawait fires.writeData(\"./fires.parquet\");\n\n// We close everything.\nawait sdb.done();\n```\n\nReturn your response as a JSON object with the following structure:\n{\n  \"data\": [\n    { \"question\": \"question1\", \"answer\": \"answer1\" },\n    { \"question\": \"question2\", \"answer\": \"answer2\" },\n    ...\n  ]\n}\n\nHere's the documentation section:\n\n\n#### `logLineChart`\n\nGenerates and logs a line chart to the console. The data should be sorted by the\nx-axis values for accurate representation.\n\n**Data Type Requirements:**\n\n- **X-axis values**: Must be `number` or `Date` objects.\n- **Y-axis values**: Must be `number` values.\n- All values must be non-null and defined.\n\n##### Signature\n\n```typescript\nasync logLineChart(x: string, y: string, options?: { formatX?: (d: unknown) => any; formatY?: (d: unknown) => any; smallMultiples?: string; fixedScales?: boolean; smallMultiplesPerRow?: number; width?: number; height?: number }): Promise<void>;\n```\n\n##### Parameters\n\n- **`x`**: - The name of the column to be used for the x-axis. Values must be\n  numbers or Date objects.\n- **`y`**: - The name of the column to be used for the y-axis. Values must be\n  numbers.\n- **`options`**: - An optional object with configuration options:\n- **`options.formatX`**: - A function to format the x-axis values for display.\n  It receives the raw x-value as input and should return a string. If the first\n  data point's x value is a Date, it defaults to formatting the date as\n  \"YYYY-MM-DD\".\n- **`options.formatY`**: - A function to format the y-axis values for display.\n  It receives the raw y-value as input and should return a string.\n- **`options.smallMultiples`**: - The name of a column to create small multiples\n  (also known as facets or trellis charts). Each unique value in this column\n  will generate a separate chart.\n- **`options.fixedScales`**: - If `true`, all small multiples will share the\n  same y-axis scale. Defaults to `false`.\n- **`options.smallMultiplesPerRow`**: - The number of small multiples to display\n  per row.\n- **`options.width`**: - The width of the chart in characters.\n- **`options.height`**: - The height of the chart in characters.\n\n##### Returns\n\nA promise that resolves when the chart has been logged to the console.\n\n##### Examples\n\n// Basic line chart\n\n```typescript\nconst data = [\n  { date: new Date(\"2023-01-01\"), value: 10 },\n  { date: new Date(\"2023-02-01\"), value: 20 },\n  { date: new Date(\"2023-03-01\"), value: 30 },\n  { date: new Date(\"2023-04-01\"), value: 40 },\n];\nawait table.loadArray(data);\nawait table.convert({ date: \"string\" }, { datetimeFormat: \"%x\" });\nawait table.logLineChart(\"date\", \"value\");\n```\n\n// Line chart with small multiples\n\n```typescript\nconst data = [\n  { date: new Date(\"2023-01-01\"), value: 10, category: \"A\" },\n  { date: new Date(\"2023-02-01\"), value: 20, category: \"A\" },\n  { date: new Date(\"2023-03-01\"), value: 30, category: \"A\" },\n  { date: new Date(\"2023-04-01\"), value: 40, category: \"A\" },\n  { date: new Date(\"2023-01-01\"), value: 15, category: \"B\" },\n  { date: new Date(\"2023-02-01\"), value: 25, category: \"B\" },\n  { date: new Date(\"2023-03-01\"), value: 35, category: \"B\" },\n  { date: new Date(\"2023-04-01\"), value: 45, category: \"B\" },\n];\nawait table.loadArray(data);\nawait table.convert({ date: \"string\" }, { datetimeFormat: \"%x\" });\nawait table.logLineChart(\"date\", \"value\", {\n  smallMultiples: \"category\",\n});\n```"
  },
  {
    "model": "qwen3:30b",
    "prompt": "Your task is to generate a set of up to 10 relevant questions and answers based on the provided section of documentation. The questions should be those a junior developer or data analyst might have.\n\nFor each question, you must provide a code example as the answer. You can add comments to the code to explain the steps. A brief, one-sentence explanation may be included in a comment if the code alone is not a sufficient answer.\n\nThe questions must be directly related to the documentation section provided below and must not ask about topics outside its scope. The answer should be grounded in the documentation provided. Do not make assumptions.\n\nWrite simple and straightforward code examples. Don't create functions to encapsulate your code.\n\nYour answers should always be wrapped in triple backticks (```ts at the beginning and ``` at the end) for code blocks.\n\nIf the documentation section is about SimpleDB, make sure to wrap your answer with:\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\nconst sdb = new SimpleDB();\n[PUT THE CODE EXAMPLE HERE. IF THERE IS NO CODE TO ADD, JUST ADD A COMMENT SAYING \"Do your magic here!\"]\nawait sdb.done();\n```\n\nIf the documentation section is about SimpleTable, make sure to wrap your answer with:\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\nconst sdb = new SimpleDB();\nconst table = sdb.newTable();\nawait table.loadData(\"path/to/your/data.csv\"); // Remove this line if not needed or change the file extension if relevant\n[PUT THE CODE EXAMPLE HERE. IF THERE IS NO CODE TO ADD, JUST ADD A COMMENT SAYING \"Do your magic here!\"]\nawait sdb.done();\n```\n\nIf you need inspiration, here is a comprehensive example with comments.\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\n\n// We start a SimpleDB instance.\nconst sdb = new SimpleDB();\n\n// We create a new table\nconst fires = sdb.newTable(\"fires\");\n// We fetch the wildfires data. It's a csv.\nawait fires.loadData(\n  \"data/firesCanada2023.csv\",\n);\n\n// We summarize to count the number of fires\n// and sum up the area burnt in each province.\nawait fires.summarize({\n  values: \"hectares\",\n  categories: \"province\",\n  summaries: [\"count\", \"sum\"],\n  decimals: 0,\n});\n// We rename columns.\nawait fires.renameColumns({\n  count: \"nbFires\",\n  sum: \"burntArea\",\n});\n// We want the province with\n// the greatest burnt area first.\nawait fires.sort({ burntArea: \"desc\" });\n\n// We log the results. By default, the method\n// logs the first 10 rows, but there is 13\n// rows in our data. We also log the data types.\nawait fires.logTable({ nbRowsToLog: 13, types: true });\n\n// And we can write the data to a parquet, json or csv file.\nawait fires.writeData(\"./fires.parquet\");\n\n// We close everything.\nawait sdb.done();\n```\n\nReturn your response as a JSON object with the following structure:\n{\n  \"data\": [\n    { \"question\": \"question1\", \"answer\": \"answer1\" },\n    { \"question\": \"question2\", \"answer\": \"answer2\" },\n    ...\n  ]\n}\n\nHere's the documentation section:\n\n\n#### `logBarChart`\n\nGenerates and logs a bar chart to the console.\n\n##### Signature\n\n```typescript\nasync logBarChart(labels: string, values: string, options?: { formatLabels?: (d: unknown) => any; formatValues?: (d: unknown) => any; width?: number }): Promise<void>;\n```\n\n##### Parameters\n\n- **`labels`**: - The name of the column to be used for the labels (categories).\n- **`values`**: - The name of the column to be used for the values.\n- **`options`**: - An optional object with configuration options:\n- **`options.formatLabels`**: - A function to format the labels. Defaults to\n  converting the label to a string.\n- **`options.formatValues`**: - A function to format the values. Defaults to\n  converting the value to a string.\n- **`options.width`**: - The width of the chart in characters. Defaults to 40.\n\n##### Returns\n\nA promise that resolves when the chart has been logged to the console.\n\n##### Examples\n\n```typescript\nconst data = [\n  { category: \"A\", value: 10 },\n  { category: \"B\", value: 20 },\n];\nawait table.loadArray(data);\nawait table.logBarChart(\"category\", \"value\");\n```"
  },
  {
    "model": "qwen3:30b",
    "prompt": "Your task is to generate a set of up to 10 relevant questions and answers based on the provided section of documentation. The questions should be those a junior developer or data analyst might have.\n\nFor each question, you must provide a code example as the answer. You can add comments to the code to explain the steps. A brief, one-sentence explanation may be included in a comment if the code alone is not a sufficient answer.\n\nThe questions must be directly related to the documentation section provided below and must not ask about topics outside its scope. The answer should be grounded in the documentation provided. Do not make assumptions.\n\nWrite simple and straightforward code examples. Don't create functions to encapsulate your code.\n\nYour answers should always be wrapped in triple backticks (```ts at the beginning and ``` at the end) for code blocks.\n\nIf the documentation section is about SimpleDB, make sure to wrap your answer with:\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\nconst sdb = new SimpleDB();\n[PUT THE CODE EXAMPLE HERE. IF THERE IS NO CODE TO ADD, JUST ADD A COMMENT SAYING \"Do your magic here!\"]\nawait sdb.done();\n```\n\nIf the documentation section is about SimpleTable, make sure to wrap your answer with:\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\nconst sdb = new SimpleDB();\nconst table = sdb.newTable();\nawait table.loadData(\"path/to/your/data.csv\"); // Remove this line if not needed or change the file extension if relevant\n[PUT THE CODE EXAMPLE HERE. IF THERE IS NO CODE TO ADD, JUST ADD A COMMENT SAYING \"Do your magic here!\"]\nawait sdb.done();\n```\n\nIf you need inspiration, here is a comprehensive example with comments.\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\n\n// We start a SimpleDB instance.\nconst sdb = new SimpleDB();\n\n// We create a new table\nconst fires = sdb.newTable(\"fires\");\n// We fetch the wildfires data. It's a csv.\nawait fires.loadData(\n  \"data/firesCanada2023.csv\",\n);\n\n// We summarize to count the number of fires\n// and sum up the area burnt in each province.\nawait fires.summarize({\n  values: \"hectares\",\n  categories: \"province\",\n  summaries: [\"count\", \"sum\"],\n  decimals: 0,\n});\n// We rename columns.\nawait fires.renameColumns({\n  count: \"nbFires\",\n  sum: \"burntArea\",\n});\n// We want the province with\n// the greatest burnt area first.\nawait fires.sort({ burntArea: \"desc\" });\n\n// We log the results. By default, the method\n// logs the first 10 rows, but there is 13\n// rows in our data. We also log the data types.\nawait fires.logTable({ nbRowsToLog: 13, types: true });\n\n// And we can write the data to a parquet, json or csv file.\nawait fires.writeData(\"./fires.parquet\");\n\n// We close everything.\nawait sdb.done();\n```\n\nReturn your response as a JSON object with the following structure:\n{\n  \"data\": [\n    { \"question\": \"question1\", \"answer\": \"answer1\" },\n    { \"question\": \"question2\", \"answer\": \"answer2\" },\n    ...\n  ]\n}\n\nHere's the documentation section:\n\n\n#### `logHistogram`\n\nGenerates and logs a histogram of a numeric column to the console.\n\n##### Signature\n\n```typescript\nasync logHistogram(values: string, options?: { bins?: number; formatLabels?: (min: number, max: number) => any; compact?: boolean; width?: number }): Promise<void>;\n```\n\n##### Parameters\n\n- **`values`**: - The name of the numeric column for which to generate the\n  histogram.\n- **`options`**: - An optional object with configuration options:\n- **`options.bins`**: - The number of bins (intervals) to use for the histogram.\n  Defaults to 10.\n- **`options.formatLabels`**: - A function to format the labels for the\n  histogram bins. It receives the lower and upper bounds of each bin as\n  arguments.\n- **`options.compact`**: - If `true`, the histogram will be displayed in a more\n  compact format. Defaults to `false`.\n- **`options.width`**: - The maximum width of the histogram bars in characters.\n\n##### Returns\n\nA promise that resolves when the histogram has been logged to the console.\n\n##### Examples\n\n// Basic histogram of the 'temperature' column\n\n```typescript\nawait table.logHistogram(\"temperature\");\n```\n\n// Histogram with 20 bins and custom label formatting\n\n```typescript\nawait table.logHistogram(\"age\", {\n  bins: 20,\n  formatLabels: (min, max) => `${min}-${max} years`,\n});\n```"
  },
  {
    "model": "qwen3:30b",
    "prompt": "Your task is to generate a set of up to 10 relevant questions and answers based on the provided section of documentation. The questions should be those a junior developer or data analyst might have.\n\nFor each question, you must provide a code example as the answer. You can add comments to the code to explain the steps. A brief, one-sentence explanation may be included in a comment if the code alone is not a sufficient answer.\n\nThe questions must be directly related to the documentation section provided below and must not ask about topics outside its scope. The answer should be grounded in the documentation provided. Do not make assumptions.\n\nWrite simple and straightforward code examples. Don't create functions to encapsulate your code.\n\nYour answers should always be wrapped in triple backticks (```ts at the beginning and ``` at the end) for code blocks.\n\nIf the documentation section is about SimpleDB, make sure to wrap your answer with:\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\nconst sdb = new SimpleDB();\n[PUT THE CODE EXAMPLE HERE. IF THERE IS NO CODE TO ADD, JUST ADD A COMMENT SAYING \"Do your magic here!\"]\nawait sdb.done();\n```\n\nIf the documentation section is about SimpleTable, make sure to wrap your answer with:\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\nconst sdb = new SimpleDB();\nconst table = sdb.newTable();\nawait table.loadData(\"path/to/your/data.csv\"); // Remove this line if not needed or change the file extension if relevant\n[PUT THE CODE EXAMPLE HERE. IF THERE IS NO CODE TO ADD, JUST ADD A COMMENT SAYING \"Do your magic here!\"]\nawait sdb.done();\n```\n\nIf you need inspiration, here is a comprehensive example with comments.\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\n\n// We start a SimpleDB instance.\nconst sdb = new SimpleDB();\n\n// We create a new table\nconst fires = sdb.newTable(\"fires\");\n// We fetch the wildfires data. It's a csv.\nawait fires.loadData(\n  \"data/firesCanada2023.csv\",\n);\n\n// We summarize to count the number of fires\n// and sum up the area burnt in each province.\nawait fires.summarize({\n  values: \"hectares\",\n  categories: \"province\",\n  summaries: [\"count\", \"sum\"],\n  decimals: 0,\n});\n// We rename columns.\nawait fires.renameColumns({\n  count: \"nbFires\",\n  sum: \"burntArea\",\n});\n// We want the province with\n// the greatest burnt area first.\nawait fires.sort({ burntArea: \"desc\" });\n\n// We log the results. By default, the method\n// logs the first 10 rows, but there is 13\n// rows in our data. We also log the data types.\nawait fires.logTable({ nbRowsToLog: 13, types: true });\n\n// And we can write the data to a parquet, json or csv file.\nawait fires.writeData(\"./fires.parquet\");\n\n// We close everything.\nawait sdb.done();\n```\n\nReturn your response as a JSON object with the following structure:\n{\n  \"data\": [\n    { \"question\": \"question1\", \"answer\": \"answer1\" },\n    { \"question\": \"question2\", \"answer\": \"answer2\" },\n    ...\n  ]\n}\n\nHere's the documentation section:\n\n\n#### `logDescription`\n\nLogs descriptive information about the columns in the table to the console. This\nincludes details such as data types, number of null values, and number of\ndistinct values for each column. It internally calls the `getDescription` method\nto retrieve the descriptive statistics.\n\n##### Signature\n\n```typescript\nasync logDescription(): Promise<void>;\n```\n\n##### Returns\n\nA promise that resolves when the column description has been logged to the\nconsole.\n\n##### Examples\n\n```ts\n// Log descriptive information for all columns in the table\nawait table.logDescription();\n```"
  },
  {
    "model": "qwen3:30b",
    "prompt": "Your task is to generate a set of up to 10 relevant questions and answers based on the provided section of documentation. The questions should be those a junior developer or data analyst might have.\n\nFor each question, you must provide a code example as the answer. You can add comments to the code to explain the steps. A brief, one-sentence explanation may be included in a comment if the code alone is not a sufficient answer.\n\nThe questions must be directly related to the documentation section provided below and must not ask about topics outside its scope. The answer should be grounded in the documentation provided. Do not make assumptions.\n\nWrite simple and straightforward code examples. Don't create functions to encapsulate your code.\n\nYour answers should always be wrapped in triple backticks (```ts at the beginning and ``` at the end) for code blocks.\n\nIf the documentation section is about SimpleDB, make sure to wrap your answer with:\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\nconst sdb = new SimpleDB();\n[PUT THE CODE EXAMPLE HERE. IF THERE IS NO CODE TO ADD, JUST ADD A COMMENT SAYING \"Do your magic here!\"]\nawait sdb.done();\n```\n\nIf the documentation section is about SimpleTable, make sure to wrap your answer with:\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\nconst sdb = new SimpleDB();\nconst table = sdb.newTable();\nawait table.loadData(\"path/to/your/data.csv\"); // Remove this line if not needed or change the file extension if relevant\n[PUT THE CODE EXAMPLE HERE. IF THERE IS NO CODE TO ADD, JUST ADD A COMMENT SAYING \"Do your magic here!\"]\nawait sdb.done();\n```\n\nIf you need inspiration, here is a comprehensive example with comments.\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\n\n// We start a SimpleDB instance.\nconst sdb = new SimpleDB();\n\n// We create a new table\nconst fires = sdb.newTable(\"fires\");\n// We fetch the wildfires data. It's a csv.\nawait fires.loadData(\n  \"data/firesCanada2023.csv\",\n);\n\n// We summarize to count the number of fires\n// and sum up the area burnt in each province.\nawait fires.summarize({\n  values: \"hectares\",\n  categories: \"province\",\n  summaries: [\"count\", \"sum\"],\n  decimals: 0,\n});\n// We rename columns.\nawait fires.renameColumns({\n  count: \"nbFires\",\n  sum: \"burntArea\",\n});\n// We want the province with\n// the greatest burnt area first.\nawait fires.sort({ burntArea: \"desc\" });\n\n// We log the results. By default, the method\n// logs the first 10 rows, but there is 13\n// rows in our data. We also log the data types.\nawait fires.logTable({ nbRowsToLog: 13, types: true });\n\n// And we can write the data to a parquet, json or csv file.\nawait fires.writeData(\"./fires.parquet\");\n\n// We close everything.\nawait sdb.done();\n```\n\nReturn your response as a JSON object with the following structure:\n{\n  \"data\": [\n    { \"question\": \"question1\", \"answer\": \"answer1\" },\n    { \"question\": \"question2\", \"answer\": \"answer2\" },\n    ...\n  ]\n}\n\nHere's the documentation section:\n\n\n#### `logProjections`\n\nLogs the projections of the geospatial data (if any) to the console.\n\n##### Signature\n\n```typescript\nasync logProjections(): Promise<SimpleTable>;\n```\n\n##### Returns\n\nA promise that resolves to the SimpleTable instance after logging the\nprojections.\n\n##### Examples\n\n```ts\n// Log the geospatial projections of the table\nawait table.logProjections();\n```"
  },
  {
    "model": "qwen3:30b",
    "prompt": "Your task is to generate a set of up to 10 relevant questions and answers based on the provided section of documentation. The questions should be those a junior developer or data analyst might have.\n\nFor each question, you must provide a code example as the answer. You can add comments to the code to explain the steps. A brief, one-sentence explanation may be included in a comment if the code alone is not a sufficient answer.\n\nThe questions must be directly related to the documentation section provided below and must not ask about topics outside its scope. The answer should be grounded in the documentation provided. Do not make assumptions.\n\nWrite simple and straightforward code examples. Don't create functions to encapsulate your code.\n\nYour answers should always be wrapped in triple backticks (```ts at the beginning and ``` at the end) for code blocks.\n\nIf the documentation section is about SimpleDB, make sure to wrap your answer with:\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\nconst sdb = new SimpleDB();\n[PUT THE CODE EXAMPLE HERE. IF THERE IS NO CODE TO ADD, JUST ADD A COMMENT SAYING \"Do your magic here!\"]\nawait sdb.done();\n```\n\nIf the documentation section is about SimpleTable, make sure to wrap your answer with:\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\nconst sdb = new SimpleDB();\nconst table = sdb.newTable();\nawait table.loadData(\"path/to/your/data.csv\"); // Remove this line if not needed or change the file extension if relevant\n[PUT THE CODE EXAMPLE HERE. IF THERE IS NO CODE TO ADD, JUST ADD A COMMENT SAYING \"Do your magic here!\"]\nawait sdb.done();\n```\n\nIf you need inspiration, here is a comprehensive example with comments.\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\n\n// We start a SimpleDB instance.\nconst sdb = new SimpleDB();\n\n// We create a new table\nconst fires = sdb.newTable(\"fires\");\n// We fetch the wildfires data. It's a csv.\nawait fires.loadData(\n  \"data/firesCanada2023.csv\",\n);\n\n// We summarize to count the number of fires\n// and sum up the area burnt in each province.\nawait fires.summarize({\n  values: \"hectares\",\n  categories: \"province\",\n  summaries: [\"count\", \"sum\"],\n  decimals: 0,\n});\n// We rename columns.\nawait fires.renameColumns({\n  count: \"nbFires\",\n  sum: \"burntArea\",\n});\n// We want the province with\n// the greatest burnt area first.\nawait fires.sort({ burntArea: \"desc\" });\n\n// We log the results. By default, the method\n// logs the first 10 rows, but there is 13\n// rows in our data. We also log the data types.\nawait fires.logTable({ nbRowsToLog: 13, types: true });\n\n// And we can write the data to a parquet, json or csv file.\nawait fires.writeData(\"./fires.parquet\");\n\n// We close everything.\nawait sdb.done();\n```\n\nReturn your response as a JSON object with the following structure:\n{\n  \"data\": [\n    { \"question\": \"question1\", \"answer\": \"answer1\" },\n    { \"question\": \"question2\", \"answer\": \"answer2\" },\n    ...\n  ]\n}\n\nHere's the documentation section:\n\n\n#### `logTypes`\n\nLogs the types of all columns in the table to the console.\n\n##### Signature\n\n```typescript\nasync logTypes(): Promise<SimpleTable>;\n```\n\n##### Returns\n\nA promise that resolves to the SimpleTable instance after logging the column\ntypes.\n\n##### Examples\n\n```ts\n// Log the data types of all columns in the table\nawait table.logTypes();\n```"
  },
  {
    "model": "qwen3:30b",
    "prompt": "Your task is to generate a set of up to 10 relevant questions and answers based on the provided section of documentation. The questions should be those a junior developer or data analyst might have.\n\nFor each question, you must provide a code example as the answer. You can add comments to the code to explain the steps. A brief, one-sentence explanation may be included in a comment if the code alone is not a sufficient answer.\n\nThe questions must be directly related to the documentation section provided below and must not ask about topics outside its scope. The answer should be grounded in the documentation provided. Do not make assumptions.\n\nWrite simple and straightforward code examples. Don't create functions to encapsulate your code.\n\nYour answers should always be wrapped in triple backticks (```ts at the beginning and ``` at the end) for code blocks.\n\nIf the documentation section is about SimpleDB, make sure to wrap your answer with:\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\nconst sdb = new SimpleDB();\n[PUT THE CODE EXAMPLE HERE. IF THERE IS NO CODE TO ADD, JUST ADD A COMMENT SAYING \"Do your magic here!\"]\nawait sdb.done();\n```\n\nIf the documentation section is about SimpleTable, make sure to wrap your answer with:\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\nconst sdb = new SimpleDB();\nconst table = sdb.newTable();\nawait table.loadData(\"path/to/your/data.csv\"); // Remove this line if not needed or change the file extension if relevant\n[PUT THE CODE EXAMPLE HERE. IF THERE IS NO CODE TO ADD, JUST ADD A COMMENT SAYING \"Do your magic here!\"]\nawait sdb.done();\n```\n\nIf you need inspiration, here is a comprehensive example with comments.\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\n\n// We start a SimpleDB instance.\nconst sdb = new SimpleDB();\n\n// We create a new table\nconst fires = sdb.newTable(\"fires\");\n// We fetch the wildfires data. It's a csv.\nawait fires.loadData(\n  \"data/firesCanada2023.csv\",\n);\n\n// We summarize to count the number of fires\n// and sum up the area burnt in each province.\nawait fires.summarize({\n  values: \"hectares\",\n  categories: \"province\",\n  summaries: [\"count\", \"sum\"],\n  decimals: 0,\n});\n// We rename columns.\nawait fires.renameColumns({\n  count: \"nbFires\",\n  sum: \"burntArea\",\n});\n// We want the province with\n// the greatest burnt area first.\nawait fires.sort({ burntArea: \"desc\" });\n\n// We log the results. By default, the method\n// logs the first 10 rows, but there is 13\n// rows in our data. We also log the data types.\nawait fires.logTable({ nbRowsToLog: 13, types: true });\n\n// And we can write the data to a parquet, json or csv file.\nawait fires.writeData(\"./fires.parquet\");\n\n// We close everything.\nawait sdb.done();\n```\n\nReturn your response as a JSON object with the following structure:\n{\n  \"data\": [\n    { \"question\": \"question1\", \"answer\": \"answer1\" },\n    { \"question\": \"question2\", \"answer\": \"answer2\" },\n    ...\n  ]\n}\n\nHere's the documentation section:\n\n\n#### `logUniques`\n\nLogs unique values for a specified column to the console. By default, a maximum\nof 100 values are logged (depending on your runtime). You can optionally\nstringify the values to see them all.\n\n##### Signature\n\n```typescript\nasync logUniques(column: string, options?: { stringify?: boolean }): Promise<SimpleTable>;\n```\n\n##### Parameters\n\n- **`column`**: - The name of the column from which to retrieve and log unique\n  values.\n- **`options`**: - An optional object with configuration options:\n- **`options.stringify`**: - If `true`, converts the unique values to a JSON\n  string before logging. Defaults to `false`.\n\n##### Returns\n\nA promise that resolves to the SimpleTable instance after logging the unique\nvalues.\n\n##### Examples\n\n```ts\n// Logs unique values for the column \"name\"\nawait table.logUniques(\"name\");\n```\n\n```ts\n// Logs unique values for the column \"name\" and stringifies them\nawait table.logUniques(\"name\", { stringify: true });\n```"
  },
  {
    "model": "qwen3:30b",
    "prompt": "Your task is to generate a set of up to 10 relevant questions and answers based on the provided section of documentation. The questions should be those a junior developer or data analyst might have.\n\nFor each question, you must provide a code example as the answer. You can add comments to the code to explain the steps. A brief, one-sentence explanation may be included in a comment if the code alone is not a sufficient answer.\n\nThe questions must be directly related to the documentation section provided below and must not ask about topics outside its scope. The answer should be grounded in the documentation provided. Do not make assumptions.\n\nWrite simple and straightforward code examples. Don't create functions to encapsulate your code.\n\nYour answers should always be wrapped in triple backticks (```ts at the beginning and ``` at the end) for code blocks.\n\nIf the documentation section is about SimpleDB, make sure to wrap your answer with:\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\nconst sdb = new SimpleDB();\n[PUT THE CODE EXAMPLE HERE. IF THERE IS NO CODE TO ADD, JUST ADD A COMMENT SAYING \"Do your magic here!\"]\nawait sdb.done();\n```\n\nIf the documentation section is about SimpleTable, make sure to wrap your answer with:\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\nconst sdb = new SimpleDB();\nconst table = sdb.newTable();\nawait table.loadData(\"path/to/your/data.csv\"); // Remove this line if not needed or change the file extension if relevant\n[PUT THE CODE EXAMPLE HERE. IF THERE IS NO CODE TO ADD, JUST ADD A COMMENT SAYING \"Do your magic here!\"]\nawait sdb.done();\n```\n\nIf you need inspiration, here is a comprehensive example with comments.\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\n\n// We start a SimpleDB instance.\nconst sdb = new SimpleDB();\n\n// We create a new table\nconst fires = sdb.newTable(\"fires\");\n// We fetch the wildfires data. It's a csv.\nawait fires.loadData(\n  \"data/firesCanada2023.csv\",\n);\n\n// We summarize to count the number of fires\n// and sum up the area burnt in each province.\nawait fires.summarize({\n  values: \"hectares\",\n  categories: \"province\",\n  summaries: [\"count\", \"sum\"],\n  decimals: 0,\n});\n// We rename columns.\nawait fires.renameColumns({\n  count: \"nbFires\",\n  sum: \"burntArea\",\n});\n// We want the province with\n// the greatest burnt area first.\nawait fires.sort({ burntArea: \"desc\" });\n\n// We log the results. By default, the method\n// logs the first 10 rows, but there is 13\n// rows in our data. We also log the data types.\nawait fires.logTable({ nbRowsToLog: 13, types: true });\n\n// And we can write the data to a parquet, json or csv file.\nawait fires.writeData(\"./fires.parquet\");\n\n// We close everything.\nawait sdb.done();\n```\n\nReturn your response as a JSON object with the following structure:\n{\n  \"data\": [\n    { \"question\": \"question1\", \"answer\": \"answer1\" },\n    { \"question\": \"question2\", \"answer\": \"answer2\" },\n    ...\n  ]\n}\n\nHere's the documentation section:\n\n\n#### `logNbRows`\n\nLogs the total number of rows in the table to the console.\n\n##### Signature\n\n```typescript\nasync logNbRows(): Promise<SimpleTable>;\n```\n\n##### Returns\n\nA promise that resolves to the SimpleTable instance after logging the row count.\n\n##### Examples\n\n```ts\n// Log the total number of rows in the table\nawait table.logNbRows();\n```"
  },
  {
    "model": "qwen3:30b",
    "prompt": "Your task is to generate a set of up to 10 relevant questions and answers based on the provided section of documentation. The questions should be those a junior developer or data analyst might have.\n\nFor each question, you must provide a code example as the answer. You can add comments to the code to explain the steps. A brief, one-sentence explanation may be included in a comment if the code alone is not a sufficient answer.\n\nThe questions must be directly related to the documentation section provided below and must not ask about topics outside its scope. The answer should be grounded in the documentation provided. Do not make assumptions.\n\nWrite simple and straightforward code examples. Don't create functions to encapsulate your code.\n\nYour answers should always be wrapped in triple backticks (```ts at the beginning and ``` at the end) for code blocks.\n\nIf the documentation section is about SimpleDB, make sure to wrap your answer with:\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\nconst sdb = new SimpleDB();\n[PUT THE CODE EXAMPLE HERE. IF THERE IS NO CODE TO ADD, JUST ADD A COMMENT SAYING \"Do your magic here!\"]\nawait sdb.done();\n```\n\nIf the documentation section is about SimpleTable, make sure to wrap your answer with:\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\nconst sdb = new SimpleDB();\nconst table = sdb.newTable();\nawait table.loadData(\"path/to/your/data.csv\"); // Remove this line if not needed or change the file extension if relevant\n[PUT THE CODE EXAMPLE HERE. IF THERE IS NO CODE TO ADD, JUST ADD A COMMENT SAYING \"Do your magic here!\"]\nawait sdb.done();\n```\n\nIf you need inspiration, here is a comprehensive example with comments.\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\n\n// We start a SimpleDB instance.\nconst sdb = new SimpleDB();\n\n// We create a new table\nconst fires = sdb.newTable(\"fires\");\n// We fetch the wildfires data. It's a csv.\nawait fires.loadData(\n  \"data/firesCanada2023.csv\",\n);\n\n// We summarize to count the number of fires\n// and sum up the area burnt in each province.\nawait fires.summarize({\n  values: \"hectares\",\n  categories: \"province\",\n  summaries: [\"count\", \"sum\"],\n  decimals: 0,\n});\n// We rename columns.\nawait fires.renameColumns({\n  count: \"nbFires\",\n  sum: \"burntArea\",\n});\n// We want the province with\n// the greatest burnt area first.\nawait fires.sort({ burntArea: \"desc\" });\n\n// We log the results. By default, the method\n// logs the first 10 rows, but there is 13\n// rows in our data. We also log the data types.\nawait fires.logTable({ nbRowsToLog: 13, types: true });\n\n// And we can write the data to a parquet, json or csv file.\nawait fires.writeData(\"./fires.parquet\");\n\n// We close everything.\nawait sdb.done();\n```\n\nReturn your response as a JSON object with the following structure:\n{\n  \"data\": [\n    { \"question\": \"question1\", \"answer\": \"answer1\" },\n    { \"question\": \"question2\", \"answer\": \"answer2\" },\n    ...\n  ]\n}\n\nHere's the documentation section:\n\n\n#### `logExtent`\n\nLogs the extent (minimum and maximum values) of a numeric column to the console.\n\n##### Signature\n\n```typescript\nasync logExtent(column: string): Promise<void>;\n```\n\n##### Parameters\n\n- **`column`**: - The name of the numeric column for which to log the extent.\n\n##### Returns\n\nA promise that resolves when the column extent has been logged to the console.\n\n##### Examples\n\n```ts\n// Log the extent of the 'price' column\nawait table.logExtent(\"price\");\n```\n\n### Examples\n\n```ts\n// Create a SimpleDB instance (in-memory by default)\nconst sdb = new SimpleDB();\n\n// Create a new table named \"employees\" within the database\nconst employees = sdb.newTable(\"employees\");\n\n// Load data from a CSV file into the \"employees\" table\nawait employees.loadData(\"./employees.csv\");\n\n// Log the first few rows of the \"employees\" table to the console\nawait employees.logTable();\n\n// Close the database connection and free up resources\nawait sdb.done();\n```\n\n```ts\n// Handling geospatial data\n// Create a SimpleDB instance\nconst sdb = new SimpleDB();\n\n// Create a new table for geospatial data\nconst boundaries = sdb.newTable(\"boundaries\");\n\n// Load geospatial data from a GeoJSON file\nawait boundaries.loadGeoData(\"./boundaries.geojson\");\n\n// Close the database connection\nawait sdb.done();\n```"
  }
]