[
  "# The Simple Data Analysis Library\n\nTo install the library with Deno, use:\n\n```bash\ndeno add jsr:@nshiab/simple-data-analysis\n```\n\nTo install the library with Node.js, use:\n\n```bash\nnpx jsr add @nshiab/simple-data-analysis\n```\n\nTo start, create a SimpleDB instance and then a SimpleTable from this instance:\n\n```ts\nimport { SimpleDB } from \"@nshiab/simple-data-analysis\";\n\nconst sdb = new SimpleDB();\nconst table = sdb.newTable(\"myTable\"); // This returns a SimpleTable instance\nawait table.loadData(\"path/to/your/data.csv\");\n\n// You can now perform various data analysis operations on the table.\n\nawait sdb.done(); // Ensure to call done when you're finished.\n```",
  "## class SimpleDB\nManages a DuckDB database instance, providing a simplified interface for\ndatabase operations.\n\n### Constructor\n\nCreates a new SimpleDB instance.\n\n#### Parameters\n\n- **`options`**: - Configuration options for the SimpleDB instance.\n- **`options.file`**: - The path to the database file. If not provided, an\n  in-memory database is used.\n- **`options.overwrite`**: - A flag indicating whether to overwrite the database\n  file if it already exists.\n- **`options.logDuration`**: - A flag indicating whether to log the total\n  execution duration.\n- **`options.nbRowsToLog`**: - The number of rows to display when logging a\n  table.\n- **`options.nbCharactersToLog`**: - The maximum number of characters to display\n  for text-based cells.\n- **`options.types`**: - A flag indicating whether to include data types when\n  logging a table.\n- **`options.cacheVerbose`**: - A flag indicating whether to log verbose\n  cache-related messages.\n- **`options.debug`**: - A flag indicating whether to log debugging information.\n- **`options.duckDbCache`**: - A flag indicating whether to use DuckDB's\n  external file cache.\n- **`options.progressBar`**: - A flag indicating whether to display a progress\n  bar for long-running operations.",
  "\n#### `newTable`\n\nCreates a new SimpleTable instance within the database.\n\n##### Signature\n\n```typescript\nnewTable(name?: string, projections?: Record<string, string>): SimpleTable;\n```\n\n##### Parameters\n\n- **`name`**: - The name of the new table. If not provided, a default name is\n  generated (e.g., \"table1\").\n- **`projections`**: - An object mapping column names to their geospatial\n  projections.\n\n##### Returns\n\nA new SimpleTable instance.\n\n##### Examples\n\n```ts\n// Create a table with a default name (e.g., \"table1\", \"table2\", etc.)\nconst dataTable = sdb.newTable();\n```\n\n```ts\n// Create a table with a specific name\nconst employees = sdb.newTable(\"employees\");\n```",
  "\n#### `getTable`\n\nRetrieves an existing SimpleTable instance from the database.\n\n##### Signature\n\n```typescript\nasync getTable(name: string): Promise<SimpleTable>;\n```\n\n##### Parameters\n\n- **`name`**: - The name of the table to retrieve.\n\n##### Returns\n\nA promise that resolves to the SimpleTable instance if found.\n\n##### Examples\n\n```ts\n// Retrieve the \"employees\" table\nconst employees = await sdb.getTable(\"employees\");\n```",
  "\n#### `removeTables`\n\nRemoves one or more tables from the database.\n\n##### Signature\n\n```typescript\nasync removeTables(tables: SimpleTable | string | (SimpleTable | string)[]): Promise<void>;\n```\n\n##### Parameters\n\n- **`tables`**: - A single table or an array of tables to remove, specified by\n  name or as SimpleTable instances.\n\n##### Returns\n\nA promise that resolves when the tables have been removed.\n\n##### Examples\n\n```ts\n// Remove a single table by name\nawait sdb.removeTables(\"employees\");\n```\n\n```ts\n// Remove multiple tables by name\nawait sdb.removeTables([\"customers\", \"products\"]);\n```\n\n```ts\n// Remove a single table using a SimpleTable instance\nconst employeesTable = sdb.newTable(\"employees\");\n// ... load data ...\nawait sdb.removeTables(employeesTable);\n```",
  "\n#### `selectTables`\n\nSelects one or more tables to keep in the database, removing all others.\n\n##### Signature\n\n```typescript\nasync selectTables(tables: SimpleTable | string | (SimpleTable | string)[]): Promise<void>;\n```\n\n##### Parameters\n\n- **`tables`**: - A single table or an array of tables to select, specified by\n  name or as SimpleTable instances.\n\n##### Returns\n\nA promise that resolves when the tables have been selected.\n\n##### Examples\n\n```ts\n// Select a single table by name, removing all other tables\nawait sdb.selectTables(\"employees\");\n```\n\n```ts\n// Select multiple tables by name, removing all other tables\nawait sdb.selectTables([\"customers\", \"products\"]);\n```\n\n```ts\n// Select a single table using a SimpleTable instance\nconst employeesTable = sdb.newTable(\"employees\");\n// ... load data ...\nawait sdb.selectTables(employeesTable);\n```",
  "\n#### `getTableNames`\n\nReturns an array of all table names in the database, sorted alphabetically.\n\n##### Signature\n\n```typescript\nasync getTableNames(): Promise<string[]>;\n```\n\n##### Returns\n\nA promise that resolves to an array of table names.\n\n##### Examples\n\n```ts\n// Get all table names\nconst tableNames = await sdb.getTableNames();\nconsole.log(tableNames); // Output: [\"employees\", \"customers\"]\n```",
  "\n#### `logTableNames`\n\nLogs the names of all tables in the database to the console, sorted\nalphabetically.\n\n##### Signature\n\n```typescript\nasync logTableNames(): Promise<void>;\n```\n\n##### Returns\n\nA promise that resolves when the table names have been logged.\n\n##### Examples\n\n```ts\n// Log all table names to the console\nawait sdb.logTableNames();\n// Example output: SimpleDB - Tables:  [\"employees\",\"customers\"]\n```",
  "\n#### `getTables`\n\nReturns an array of all SimpleTable instances in the database.\n\n##### Signature\n\n```typescript\nasync getTables(): Promise<SimpleTable[]>;\n```\n\n##### Returns\n\nA promise that resolves to an array of SimpleTable instances.\n\n##### Examples\n\n```ts\n// Get all SimpleTable instances\nconst tables = await sdb.getTables();\n```",
  "\n#### `hasTable`\n\nChecks if a table exists in the database.\n\n##### Signature\n\n```typescript\nasync hasTable(table: SimpleTable | string): Promise<boolean>;\n```\n\n##### Parameters\n\n- **`table`**: - The name of the table or a SimpleTable instance.\n\n##### Returns\n\nA promise that resolves to `true` if the table exists, `false` otherwise.\n\n##### Examples\n\n```ts\n// Check if a table named \"employees\" exists\nconst exists = await sdb.hasTable(\"employees\");\nconsole.log(exists); // Output: true or false\n```\n\n```ts\n// Check if a SimpleTable instance exists in the database\nconst myTable = sdb.newTable(\"my_data\");\nconst existsInstance = await sdb.hasTable(myTable);\nconsole.log(existsInstance); // Output: true or false\n```",
  "\n#### `getExtensions`\n\nReturns a list of installed DuckDB extensions.\n\n##### Signature\n\n```typescript\nasync getExtensions(): Promise<Record<string, string | number | boolean | Date | null>[]>;\n```\n\n##### Returns\n\nA promise that resolves to an array of objects, each representing an installed\nextension.\n\n##### Examples\n\n```ts\n// Get a list of all installed extensions\nconst extensions = await sdb.getExtensions();\nconsole.log(extensions); // Output: [{ extension_name: \"spatial\", loaded: true, ... }]\n```",
  "\n#### `customQuery`\n\nExecutes a custom SQL query directly against the DuckDB instance.\n\nIf you want to force the returned data to match the types of the columns, you\ncan use the `types` option.\n\n##### Signature\n\n```typescript\nasync customQuery(query: string, options?: { returnDataFrom?: \"query\" | \"none\"; table?: string; types?: Record<string, string> }): Promise<Record<string, string | number | boolean | Date | null>[] | null>;\n```\n\n##### Parameters\n\n- **`query`**: - The SQL query string to execute.\n- **`options`**: - Configuration options for the query.\n- **`options.returnDataFrom`**: - Specifies whether to return data from the\n  query. Can be `\"query\"` to return data or `\"none\"` (default) to not return\n  data.\n- **`options.table`**: - The name of the table associated with the query,\n  primarily used for debugging and logging.\n- **`options.types`**: - An optional object specifying data types for the query\n  parameters.\n\n##### Returns\n\nA promise that resolves to the query result as an array of objects if\n`returnDataFrom` is `\"query\"`, otherwise `null`.\n\n##### Examples\n\n```ts\n// Execute a query without returning data\nawait sdb.customQuery(\n  \"CREATE TABLE young_employees AS SELECT * FROM employees WHERE age > 30\",\n);\n```\n\n```ts\n// Execute a query and return the results\nconst youngEmployees = await sdb.customQuery(\n  \"SELECT * FROM employees WHERE age < 30\",\n  { returnDataFrom: \"query\" },\n);\nconsole.log(youngEmployees);\n```",
  "\n#### `loadDB`\n\nLoads a database from a specified file into the current SimpleDB instance.\nSupported file types are `.db` (DuckDB) and `.sqlite` (SQLite).\n\n##### Signature\n\n```typescript\nasync loadDB(file: string, options?: { name?: string; detach?: boolean }): Promise<void>;\n```\n\n##### Parameters\n\n- **`file`**: - The absolute path to the database file (e.g.,\n  \"./my_database.db\").\n- **`options`**: - Configuration options for loading the database.\n- **`options.name`**: - The name to assign to the loaded database within the\n  DuckDB instance. Defaults to the file name without extension.\n- **`options.detach`**: - If `true` (default), the database is detached after\n  loading its contents into memory. If `false`, the database remains attached.\n\n##### Returns\n\nA promise that resolves when the database has been loaded.\n\n##### Examples\n\n```ts\n// Load a DuckDB database file\nawait sdb.loadDB(\"./my_database.db\");\n```\n\n```ts\n// Load a SQLite database file and keep it attached\nawait sdb.loadDB(\"./my_database.sqlite\", { detach: false });\n```\n\n```ts\n// Load a database with a custom name\nawait sdb.loadDB(\"./archive.db\", { name: \"archive_db\" });\n```",
  "\n#### `writeDB`\n\nWrites the current state of the database to a specified file. Supported output\nfile types are `.db` (DuckDB) and `.sqlite` (SQLite).\n\n##### Signature\n\n```typescript\nasync writeDB(file: string, options?: { noMetaData?: boolean }): Promise<void>;\n```\n\n##### Parameters\n\n- **`file`**: - The absolute path to the output file (e.g.,\n  \"./my_exported_database.db\").\n- **`options`**: - Configuration options for writing the database.\n- **`options.noMetaData`**: - If `true`, metadata files (projections, indexes)\n  are not created alongside the database file. Defaults to `false`.\n\n##### Returns\n\nA promise that resolves when the database has been written to the file.\n\n##### Examples\n\n```ts\n// Write the current database to a DuckDB file\nawait sdb.writeDB(\"./my_exported_database.db\");\n```\n\n```ts\n// Write the current database to a SQLite file without metadata\nawait sdb.writeDB(\"./my_exported_database.sqlite\", { noMetaData: true });\n```",
  "\n#### `done`\n\nFrees up memory by closing the database connection and instance, and cleans up\nthe cache. If the database is file-based, it also compacts the database file to\noptimize storage.\n\n##### Signature\n\n```typescript\nasync done(): Promise<SimpleDB>;\n```\n\n##### Returns\n\nA promise that resolves to the SimpleDB instance after cleanup.\n\n##### Examples\n\n```ts\n// Close the database and clean up resources\nawait sdb.done();\n```\n\n### Examples\n\n```ts\n// Create an in-memory database instance\nconst sdb = new SimpleDB();\n// Create a new table named \"employees\"\nconst employees = sdb.newTable(\"employees\");\n// Load data from a CSV file into the \"employees\" table\nawait employees.loadData(\"./employees.csv\");\n// Log the first few rows of the \"employees\" table to the console\nawait employees.logTable();\n// Close the database connection and clean up resources\nawait sdb.done();\n```\n\n```ts\n// Create a persistent database instance, saving data to a file\n// To load an existing database, use the `loadDB` method instead\nconst sdb = new SimpleDB({ file: \"./my_database.db\" });\n// Perform database operations...\n// Close the database connection, which saves changes to the specified file\nawait sdb.done();\n```\n\n```ts\n// Create a database instance with custom options\nconst sdb = new SimpleDB({\n  debug: true, // Enable debugging output\n  nbRowsToLog: 20, // Set the number of rows to log by default\n});\n```",
  "## class SimpleTable\nRepresents a table within a SimpleDB database, capable of handling tabular,\ngeospatial, and vector data. SimpleTable instances are typically created via a\nSimpleDB instance.\n\n### Constructor\n\nCreates an instance of SimpleTable.\n\n#### Parameters\n\n- **`name`**: - The name of the table.\n- **`projections`**: - An object mapping column names to their geospatial\n  projections.\n- **`simpleDB`**: - The SimpleDB instance that this table belongs to.\n- **`options`**: - An optional object with configuration options:\n- **`options.debug`**: - A boolean indicating whether to enable debug mode.\n- **`options.nbRowsToLog`**: - The number of rows to log when displaying table\n  data.\n- **`options.nbCharactersToLog`**: - The maximum number of characters to log for\n  strings. Useful to avoid logging large text content.\n- **`options.types`**: - A boolean indicating whether to include data types when\n  logging a table.",
  "\n#### `renameTable`\n\nRenames the current table.\n\n##### Signature\n\n```typescript\nasync renameTable(name: string): Promise<void>;\n```\n\n##### Parameters\n\n- **`name`**: - The new name for the table.\n\n##### Returns\n\nA promise that resolves when the table has been renamed.\n\n##### Examples\n\n```ts\n// Rename the table to \"new_employees\"\nawait table.renameTable(\"new_employees\");\n```",
  "\n#### `setTypes`\n\nSets the data types for columns in a new table. If the table already exists, it\nwill be replaced. To convert the types of an existing table, use the\n`.convert()` method instead.\n\n##### Signature\n\n```typescript\nasync setTypes(types: Record<string, \"integer\" | \"float\" | \"number\" | \"string\" | \"date\" | \"time\" | \"datetime\" | \"datetimeTz\" | \"bigint\" | \"double\" | \"varchar\" | \"timestamp\" | \"timestamp with time zone\" | \"boolean\" | \"geometry\">): Promise<void>;\n```\n\n##### Parameters\n\n- **`types`**: - An object specifying the column names and their target data\n  types (JavaScript or SQL types).\n\n##### Returns\n\nA promise that resolves when the types have been set.\n\n##### Examples\n\n```ts\n// Set types for a new table\nawait table.setTypes({\n  name: \"string\",\n  salary: \"integer\",\n  raise: \"float\",\n});\n```",
  "\n#### `loadArray`\n\nLoads an array of JavaScript objects into the table.\n\n##### Signature\n\n```typescript\nasync loadArray(arrayOfObjects: Record<string, unknown>[]): Promise<SimpleTable>;\n```\n\n##### Parameters\n\n- **`arrayOfObjects`**: - An array of objects, where each object represents a\n  row and its properties represent columns.\n\n##### Returns\n\nA promise that resolves to the SimpleTable instance after the data has been\nloaded.\n\n##### Examples\n\n```ts\n// Load data from an array of objects\nconst data = [\n  { letter: \"a\", number: 1 },\n  { letter: \"b\", number: 2 },\n];\nawait table.loadArray(data);\n```",
  "\n#### `loadData`\n\nLoads data from one or more local or remote files into the table. Supported file\nformats include CSV, JSON, Parquet, and Excel.\n\n##### Signature\n\n```typescript\nasync loadData(files: string | string[], options?: { fileType?: \"csv\" | \"dsv\" | \"json\" | \"parquet\" | \"excel\"; autoDetect?: boolean; limit?: number; fileName?: boolean; unifyColumns?: boolean; columnTypes?: Record<string, string>; header?: boolean; allText?: boolean; delim?: string; skip?: number; nullPadding?: boolean; ignoreErrors?: boolean; compression?: \"none\" | \"gzip\" | \"zstd\"; encoding?: string; strict?: boolean; jsonFormat?: \"unstructured\" | \"newlineDelimited\" | \"array\"; records?: boolean; sheet?: string }): Promise<SimpleTable>;\n```\n\n##### Parameters\n\n- **`files`**: - The path(s) or URL(s) of the file(s) containing the data to be\n  loaded.\n- **`options`**: - An optional object with configuration options:\n- **`options.fileType`**: - The type of file to load (\"csv\", \"dsv\", \"json\",\n  \"parquet\", \"excel\"). Defaults to being inferred from the file extension.\n- **`options.autoDetect`**: - A boolean indicating whether to automatically\n  detect the data format. Defaults to `true`.\n- **`options.limit`**: - A number indicating the maximum number of rows to load.\n  Defaults to all rows.\n- **`options.fileName`**: - A boolean indicating whether to include the file\n  name as a new column in the loaded data. Defaults to `false`.\n- **`options.unifyColumns`**: - A boolean indicating whether to unify columns\n  across multiple files when their structures differ. Missing columns will be\n  filled with `NULL` values. Defaults to `false`.\n- **`options.columnTypes`**: - An object mapping column names to their expected\n  data types. By default, types are inferred.\n- **`options.header`**: - A boolean indicating whether the file has a header\n  row. Applicable to CSV files. Defaults to `true`.\n- **`options.allText`**: - A boolean indicating whether all columns should be\n  treated as text. Applicable to CSV files. Defaults to `false`.\n- **`options.delim`**: - The delimiter used in the file. Applicable to CSV and\n  DSV files. By default, the delimiter is inferred.\n- **`options.skip`**: - The number of lines to skip at the beginning of the\n  file. Applicable to CSV files. Defaults to `0`.\n- **`options.nullPadding`**: - If `true`, when a row has fewer columns than\n  expected, the remaining columns on the right will be padded with `NULL`\n  values. Defaults to `false`.\n- **`options.ignoreErrors`**: - If `true`, parsing errors encountered will be\n  ignored, and rows with errors will be skipped. Defaults to `false`.\n- **`options.compression`**: - The compression type of the file. Applicable to\n  CSV files. Defaults to `none`.\n- **`options.strict`**: - If `true`, an error will be thrown when encountering\n  any issues. If `false`, structurally incorrect files will be parsed\n  tentatively. Defaults to `true`.\n- **`options.encoding`**: - The encoding of the file. Applicable to CSV files.\n  Defaults to `utf-8`.\n- **`options.jsonFormat`**: - The format of JSON files (\"unstructured\",\n  \"newlineDelimited\", \"array\"). By default, the format is inferred.\n- **`options.records`**: - A boolean indicating whether each line in a\n  newline-delimited JSON file represents a record. Applicable to JSON files. By\n  default, it's inferred.\n- **`options.sheet`**: - A string indicating a specific sheet to import from an\n  Excel file. By default, the first sheet is imported.\n\n##### Returns\n\nA promise that resolves to the SimpleTable instance after the data has been\nloaded.\n\n##### Examples\n\n```ts\n// Load data from a single local CSV file\nawait table.loadData(\"./some-data.csv\");\n```\n\n```ts\n// Load data from a remote Parquet file\nawait table.loadData(\"https://some-website.com/some-data.parquet\");\n```\n\n```ts\n// Load data from multiple local JSON files\nawait table.loadData([\n  \"./some-data1.json\",\n  \"./some-data2.json\",\n  \"./some-data3.json\",\n]);\n```\n\n```ts\n// Load data from multiple remote Parquet files with column unification\nawait table.loadData([\n  \"https://some-website.com/some-data1.parquet\",\n  \"https://some-website.com/some-data2.parquet\",\n  \"https://some-website.com/some-data3.parquet\",\n], { unifyColumns: true });\n```",
  "\n#### `loadDataFromDirectory`\n\nLoads data from all supported files (CSV, JSON, Parquet, Excel) within a local\ndirectory into the table.\n\n##### Signature\n\n```typescript\nasync loadDataFromDirectory(directory: string, options?: { fileType?: \"csv\" | \"dsv\" | \"json\" | \"parquet\" | \"excel\"; autoDetect?: boolean; limit?: number; fileName?: boolean; unifyColumns?: boolean; columnTypes?: Record<string, string>; header?: boolean; allText?: boolean; delim?: string; skip?: number; nullPadding?: boolean; ignoreErrors?: boolean; compression?: \"none\" | \"gzip\" | \"zstd\"; encoding?: \"utf-8\" | \"utf-16\" | \"latin-1\"; strict?: boolean; jsonFormat?: \"unstructured\" | \"newlineDelimited\" | \"array\"; records?: boolean; sheet?: string }): Promise<SimpleTable>;\n```\n\n##### Parameters\n\n- **`directory`**: - The absolute path to the directory containing the data\n  files.\n- **`options`**: - An optional object with configuration options:\n- **`options.fileType`**: - The type of file to load (\"csv\", \"dsv\", \"json\",\n  \"parquet\", \"excel\"). Defaults to being inferred from the file extension.\n- **`options.autoDetect`**: - A boolean indicating whether to automatically\n  detect the data format. Defaults to `true`.\n- **`options.limit`**: - A number indicating the maximum number of rows to load.\n  Defaults to all rows.\n- **`options.fileName`**: - A boolean indicating whether to include the file\n  name as a new column in the loaded data. Defaults to `false`.\n- **`options.unifyColumns`**: - A boolean indicating whether to unify columns\n  across multiple files when their structures differ. Missing columns will be\n  filled with `NULL` values. Defaults to `false`.\n- **`options.columnTypes`**: - An object mapping column names to their expected\n  data types. By default, types are inferred.\n- **`options.header`**: - A boolean indicating whether the file has a header\n  row. Applicable to CSV files. Defaults to `true`.\n- **`options.allText`**: - A boolean indicating whether all columns should be\n  treated as text. Applicable to CSV files. Defaults to `false`.\n- **`options.delim`**: - The delimiter used in the file. Applicable to CSV and\n  DSV files. By default, the delimiter is inferred.\n- **`options.skip`**: - The number of lines to skip at the beginning of the\n  file. Applicable to CSV files. Defaults to `0`.\n- **`options.nullPadding`**: - If `true`, when a row has fewer columns than\n  expected, the remaining columns on the right will be padded with `NULL`\n  values. Defaults to `false`.\n- **`options.ignoreErrors`**: - If `true`, parsing errors encountered will be\n  ignored, and rows with errors will be skipped. Defaults to `false`.\n- **`options.compression`**: - The compression type of the file. Applicable to\n  CSV files. Defaults to `none`.\n- **`options.strict`**: - If `true`, an error will be thrown when encountering\n  any issues. If `false`, structurally incorrect files will be parsed\n  tentatively. Defaults to `true`.\n- **`options.encoding`**: - The encoding of the files. Applicable to CSV files.\n  Defaults to `utf-8`.\n- **`options.jsonFormat`**: - The format of JSON files (\"unstructured\",\n  \"newlineDelimited\", \"array\"). By default, the format is inferred.\n- **`options.records`**: - A boolean indicating whether each line in a\n  newline-delimited JSON file represents a record. Applicable to JSON files. By\n  default, it's inferred.\n- **`options.sheet`**: - A string indicating a specific sheet to import from an\n  Excel file. By default, the first sheet is imported.\n\n##### Returns\n\nA promise that resolves to the SimpleTable instance after the data has been\nloaded.\n\n##### Examples\n\n```ts\n// Load all supported data files from the \"./data/\" directory\nawait table.loadDataFromDirectory(\"./data/\");\n```",
  "\n#### `loadGeoData`\n\nLoads geospatial data from an external file or URL into the table. The\ncoordinates of files or URLs ending with `.json` or `.geojson` are automatically\nflipped to `[latitude, longitude]` axis order.\n\n##### Signature\n\n```typescript\nasync loadGeoData(file: string, options?: { toWGS84?: boolean; from?: string }): Promise<SimpleTable>;\n```\n\n##### Parameters\n\n- **`file`**: - The URL or absolute path to the external file containing the\n  geospatial data.\n- **`options`**: - An optional object with configuration options:\n- **`options.toWGS84`**: - If `true`, the method will attempt to reproject the\n  data to WGS84 with `[latitude, longitude]` axis order. If the file is `.json`\n  or `.geojson`, coordinates are automatically flipped, and this option has no\n  additional effect. Defaults to `false`.\n- **`options.from`**: - An optional string specifying the original projection of\n  the data, if the method is unable to detect it automatically.\n\n##### Returns\n\nA promise that resolves to the SimpleTable instance after the geospatial data\nhas been loaded.\n\n##### Examples\n\n```ts\n// Load geospatial data from a URL\nawait table.loadGeoData(\"https://some-website.com/some-data.geojson\");\n```\n\n```ts\n// Load geospatial data from a local file\nawait table.loadGeoData(\"./some-data.geojson\");\n```\n\n```ts\n// Load geospatial data from a shapefile and reproject to WGS84\nawait table.loadGeoData(\"./some-data.shp.zip\", { toWGS84: true });\n```",
  "\n#### `aiRowByRow`\n\nApplies a prompt to the value of each row in a specified column, storing the\nAI's response in a new column. This method automatically appends instructions to\nyour prompt; set `verbose` to `true` to see the full prompt.\n\nThis method supports Google Gemini, Vertex AI, and local models running with\nOllama. Credentials and model selection are determined by environment variables\n(`AI_KEY`, `AI_PROJECT`, `AI_LOCATION`, `AI_MODEL`) or directly via `options`,\nwith `options` taking precedence.\n\nFor Ollama, set the `OLLAMA` environment variable to `true`, ensure Ollama is\nrunning, and set `AI_MODEL` to your desired model name. You can also pass your\ninstance of Ollama to the `ollama` option.\n\nTo manage rate limits, use `batchSize` to process multiple rows per request and\n`rateLimitPerMinute` to introduce delays between requests. For higher rate\nlimits (business/professional accounts), `concurrent` allows parallel requests.\n\nThe `cache` option enables local caching of results in `.journalism-cache` (from\nthe `askAI` function in the\n[journalism library](https://github.com/nshiab/journalism)). Remember to add\n`.journalism-cache` to your `.gitignore`.\n\nIf the AI returns fewer items than expected in a batch, or if a custom `test`\nfunction fails, the `retry` option (a number greater than 0) will reattempt the\nrequest.\n\nTemperature is set to 0 for reproducibility, though consistency cannot be\nguaranteed.\n\nThis method does not support tables containing geometries.\n\n##### Signature\n\n```typescript\nasync aiRowByRow(column: string, newColumn: string, prompt: string, options?: { batchSize?: number; concurrent?: number; cache?: boolean; test?: (dataPoint: unknown) => any; retry?: number; model?: string; apiKey?: string; vertex?: boolean; project?: string; location?: string; ollama?: boolean | Ollama; verbose?: boolean; rateLimitPerMinute?: number; clean?: (response: string) => any; contextWindow?: number; thinkingBudget?: number; extraInstructions?: string }): Promise<void>;\n```\n\n##### Parameters\n\n- **`column`**: - The name of the column to be used as input for the AI prompt.\n- **`newColumn`**: - The name of the new column where the AI's response will be\n  stored.\n- **`prompt`**: - The input string to guide the AI's response.\n- **`options`**: - Configuration options for the AI request.\n- **`options.batchSize`**: - The number of rows to process in each batch.\n  Defaults to `1`.\n- **`options.concurrent`**: - The number of concurrent requests to send.\n  Defaults to `1`.\n- **`options.cache`**: - If `true`, the results will be cached locally. Defaults\n  to `false`.\n- **`options.test`**: - A function to validate the returned data point. If it\n  throws an error, the request will be retried (if `retry` is set). Defaults to\n  `undefined`.\n- **`options.retry`**: - The number of times to retry the request in case of\n  failure. Defaults to `0`.\n- **`options.rateLimitPerMinute`**: - The rate limit for AI requests in requests\n  per minute. The method will wait between requests if necessary. Defaults to\n  `undefined` (no limit).\n- **`options.model`**: - The AI model to use. Defaults to the `AI_MODEL`\n  environment variable.\n- **`options.apiKey`**: - The API key for the AI service. Defaults to the\n  `AI_KEY` environment variable.\n- **`options.vertex`**: - If `true`, uses Vertex AI. Automatically set to `true`\n  if `AI_PROJECT` and `AI_LOCATION` are set in the environment. Defaults to\n  `false`.\n- **`options.project`**: - The Google Cloud project ID for Vertex AI. Defaults\n  to the `AI_PROJECT` environment variable.\n- **`options.location`**: - The Google Cloud location for Vertex AI. Defaults to\n  the `AI_LOCATION` environment variable.\n- **`options.ollama`**: - If `true`, uses Ollama. Defaults to the `OLLAMA`\n  environment variable. If you want your Ollama instance to be used, you can\n  pass it here too.\n- **`options.verbose`**: - If `true`, logs additional debugging information,\n  including the full prompt sent to the AI. Defaults to `false`.\n- **`options.clean`**: - A function to clean the AI's response before JSON\n  parsing, testing, caching, and storing. Defaults to `undefined`.\n- **`options.contextWindow`**: - An option to specify the context window size\n  for Ollama models. By default, Ollama sets this depending on the model, which\n  can be lower than the actual maximum context window size of the model.\n- **`options.thinkingBudget`**: - Sets the reasoning token budget: 0 to disable\n  (default, though some models may reason regardless), -1 for a dynamic budget,\n  or > 0 for a fixed budget. For Ollama models, any non-zero value simply\n  enables reasoning, ignoring the specific budget amount.\n- **`options.extraInstructions`**: - Additional instructions to append to the\n  prompt, providing more context or guidance for the AI.\n\n##### Returns\n\nA promise that resolves when the AI processing is complete.\n\n##### Examples\n\n```ts\n// New table with a \"name\" column.\nawait table.loadArray([\n  { name: \"Marie\" },\n  { name: \"John\" },\n  { name: \"Alex\" },\n]);\n\n// Ask the AI to categorize names into a new \"gender\" column.\nawait table.aiRowByRow(\n  \"name\",\n  \"gender\",\n  `Guess whether it's a \"Man\" or a \"Woman\". If it could be both, return \"Neutral\".`,\n  {\n    cache: true, // Cache results locally\n    batchSize: 10, // Process 10 rows at once\n    test: (dataPoint: unknown) => { // Validate AI's response\n      if (\n        typeof dataPoint !== \"string\" ||\n        ![\"Man\", \"Woman\", \"Neutral\"].includes(dataPoint)\n      ) {\n        throw new Error(`Invalid response: ${dataPoint}`);\n      }\n    },\n    retry: 3, // Retry up to 3 times on failure\n    rateLimitPerMinute: 15, // Limit requests to 15 per minute\n    verbose: true, // Log detailed information\n  },\n);\n\n// Example results:\n// [\n//   { name: \"Marie\", gender: \"Woman\" },\n//   { name: \"John\", gender: \"Man\" },\n//   { name: \"Alex\", gender: \"Neutral\" },\n// ]\n```",
  "\n#### `aiEmbeddings`\n\nGenerates embeddings for a specified text column and stores the results in a new\ncolumn.\n\nThis method supports Google Gemini, Vertex AI, and local models running with\nOllama. Credentials and model selection are determined by environment variables\n(`AI_KEY`, `AI_PROJECT`, `AI_LOCATION`, `AI_EMBEDDINGS_MODEL`) or directly via\n`options`, with `options` taking precedence.\n\nFor Ollama, set the `OLLAMA` environment variable to `true`, ensure Ollama is\nrunning, and set `AI_EMBEDDINGS_MODEL` to your desired model name. You can also\npass your instance of Ollama to the `ollama` option.\n\nTo manage rate limits, use `rateLimitPerMinute` to introduce delays between\nrequests. For higher rate limits (business/professional accounts), `concurrent`\nallows parallel requests.\n\nThe `cache` option enables local caching of results in `.journalism-cache` (from\nthe `getEmbedding` function in the\n[journalism library](https://github.com/nshiab/journalism)). Remember to add\n`.journalism-cache` to your `.gitignore`.\n\nIf `createIndex` is `true`, an index will be created on the new column using the\n[duckdb-vss extension](https://github.com/duckdb/duckdb-vss). This is useful for\nspeeding up the `aiVectorSimilarity` method.\n\nThis method does not support tables containing geometries.\n\n##### Signature\n\n```typescript\nasync aiEmbeddings(column: string, newColumn: string, options?: { createIndex?: boolean; concurrent?: number; cache?: boolean; model?: string; apiKey?: string; vertex?: boolean; project?: string; location?: string; ollama?: boolean | Ollama; verbose?: boolean; rateLimitPerMinute?: number; contextWindow?: number }): Promise<void>;\n```\n\n##### Parameters\n\n- **`column`**: - The name of the column to be used as input for generating\n  embeddings.\n- **`newColumn`**: - The name of the new column where the generated embeddings\n  will be stored.\n- **`options`**: - Configuration options for the AI request.\n- **`options.createIndex`**: - If `true`, an index will be created on the new\n  column. Useful for speeding up the `aiVectorSimilarity` method. Defaults to\n  `false`.\n- **`options.concurrent`**: - The number of concurrent requests to send.\n  Defaults to `1`.\n- **`options.cache`**: - If `true`, the results will be cached locally. Defaults\n  to `false`.\n- **`options.rateLimitPerMinute`**: - The rate limit for AI requests in requests\n  per minute. The method will wait between requests if necessary. Defaults to\n  `undefined` (no limit).\n- **`options.model`**: - The AI model to use. Defaults to the\n  `AI_EMBEDDINGS_MODEL` environment variable.\n- **`options.apiKey`**: - The API key for the AI service. Defaults to the\n  `AI_KEY` environment variable.\n- **`options.vertex`**: - If `true`, uses Vertex AI. Automatically set to `true`\n  if `AI_PROJECT` and `AI_LOCATION` are set in the environment. Defaults to\n  `false`.\n- **`options.project`**: - The Google Cloud project ID for Vertex AI. Defaults\n  to the `AI_PROJECT` environment variable.\n- **`options.location`**: - The Google Cloud location for Vertex AI. Defaults to\n  the `AI_LOCATION` environment variable.\n- **`options.ollama`**: - If `true`, uses Ollama. Defaults to the `OLLAMA`\n  environment variable. If you want your Ollama instance to be used, you can\n  pass it here too.\n- **`options.contextWindow`**: - An option to specify the context window size\n  for Ollama models. By default, Ollama sets this depending on the model, which\n  can be lower than the actual maximum context window size of the model.\n- **`options.verbose`**: - If `true`, logs additional debugging information.\n  Defaults to `false`.\n\n##### Returns\n\nA promise that resolves when the embeddings have been generated and stored.\n\n##### Examples\n\n```ts\n// New table with a \"food\" column.\nawait table.loadArray([\n  { food: \"pizza\" },\n  { food: \"sushi\" },\n  { food: \"burger\" },\n  { food: \"pasta\" },\n  { food: \"salad\" },\n  { food: \"tacos\" },\n]);\n\n// Generate embeddings for the \"food\" column and store them in a new \"embeddings\" column.\nawait table.aiEmbeddings(\"food\", \"embeddings\", {\n  cache: true, // Cache results locally\n  rateLimitPerMinute: 15, // Limit requests to 15 per minute\n  createIndex: true, // Create an index on the new column for faster similarity searches\n  verbose: true, // Log detailed information\n});\n```",
  "\n#### `aiVectorSimilarity`\n\nCreates an embedding from a specified text and returns the most similar text\ncontent based on their embeddings. This method is useful for semantic search and\ntext similarity tasks, computing cosine distance and sorting results by\nsimilarity.\n\nTo create the embedding, this method supports Google Gemini, Vertex AI, and\nlocal models running with Ollama. Credentials and model selection are determined\nby environment variables (`AI_KEY`, `AI_PROJECT`, `AI_LOCATION`,\n`AI_EMBEDDINGS_MODEL`) or directly via `options`, with `options` taking\nprecedence.\n\nFor Ollama, set the `OLLAMA` environment variable to `true`, ensure Ollama is\nrunning, and set `AI_EMBEDDINGS_MODEL` to your desired model name. You can also\npass your instance of Ollama to the `ollama` option.\n\nThe `cache` option enables local caching of the specified text's embedding in\n`.journalism-cache` (from the `getEmbedding` function in the\n[journalism library](https://github.com/nshiab/journalism)). Remember to add\n`.journalism-cache` to your `.gitignore`.\n\nIf `createIndex` is `true`, an index will be created on the embeddings column\nusing the [duckdb-vss extension](https://github.com/duckdb/duckdb-vss) to speed\nup processing. If the index already exists, it will not be recreated.\n\n##### Signature\n\n```typescript\nasync aiVectorSimilarity(text: string, column: string, nbResults: number, options?: { createIndex?: boolean; outputTable?: string; cache?: boolean; model?: string; apiKey?: string; vertex?: boolean; project?: string; location?: string; ollama?: boolean | Ollama; contextWindow?: number; verbose?: boolean }): Promise<SimpleTable>;\n```\n\n##### Parameters\n\n- **`text`**: - The text for which to generate an embedding and find similar\n  content.\n- **`column`**: - The name of the column containing the embeddings to be used\n  for the similarity search.\n- **`nbResults`**: - The number of most similar results to return.\n- **`options`**: - An optional object with configuration options:\n- **`options.createIndex`**: - If `true`, an index will be created on the\n  embeddings column. Defaults to `false`.\n- **`options.outputTable`**: - The name of the output table where the results\n  will be stored. If not provided, the current table will be modified. Defaults\n  to `undefined`.\n- **`options.cache`**: - If `true`, the embedding of the input `text` will be\n  cached locally. Defaults to `false`.\n- **`options.model`**: - The AI model to use for generating the embedding.\n  Defaults to the `AI_EMBEDDINGS_MODEL` environment variable.\n- **`options.apiKey`**: - The API key for the AI service. Defaults to the\n  `AI_KEY` environment variable.\n- **`options.vertex`**: - If `true`, uses Vertex AI. Automatically set to `true`\n  if `AI_PROJECT` and `AI_LOCATION` are set in the environment. Defaults to\n  `false`.\n- **`options.project`**: - The Google Cloud project ID for Vertex AI. Defaults\n  to the `AI_PROJECT` environment variable.\n- **`options.location`**: - The Google Cloud location for Vertex AI. Defaults to\n  the `AI_LOCATION` environment variable.\n- **`options.ollama`**: - If `true`, uses Ollama. Defaults to the `OLLAMA`\n  environment variable. If you want your Ollama instance to be used, you can\n  pass it here too.\n- **`options.verbose`**: - If `true`, logs additional debugging information.\n  Defaults to `false`.\n- **`options.contextWindow`**: - An option to specify the context window size\n  for Ollama models. By default, Ollama sets this depending on the model, which\n  can be lower than the actual maximum context window size of the model.\n\n##### Returns\n\nA promise that resolves to the SimpleTable instance containing the similarity\nsearch results.\n\n##### Examples\n\n```ts\n// New table with a \"food\" column.\nawait table.loadArray([\n  { food: \"pizza\" },\n  { food: \"sushi\" },\n  { food: \"burger\" },\n  { food: \"pasta\" },\n  { food: \"salad\" },\n  { food: \"tacos\" },\n]);\n\n// Generate embeddings for the \"food\" column.\nawait table.aiEmbeddings(\"food\", \"embeddings\", { cache: true });\n\n// Find the 3 most similar foods to \"italian food\" based on embeddings.\nconst similarFoods = await table.aiVectorSimilarity(\n  \"italian food\",\n  \"embeddings\",\n  3,\n  {\n    createIndex: true, // Create an index on the embeddings column for faster searches\n    cache: true, // Cache the embedding of \"italian food\"\n  },\n);\n\n// Log the results\nawait similarFoods.logTable();\n```",
  "\n#### `aiQuery`\n\nGenerates and executes a SQL query based on a prompt. Additional instructions,\nsuch as column types, are automatically added to your prompt. Set `verbose` to\n`true` to see the full prompt.\n\nThis method supports Google Gemini, Vertex AI, and local models running with\nOllama. Credentials and model selection are determined by environment variables\n(`AI_KEY`, `AI_PROJECT`, `AI_LOCATION`, `AI_MODEL`) or directly via `options`,\nwith `options` taking precedence.\n\nFor Ollama, set the `OLLAMA` environment variable to `true`, ensure Ollama is\nrunning, and set `AI_MODEL` to your desired model name. You can also pass your\ninstance of Ollama to the `ollama` option.\n\nTemperature is set to 0 to aim for reproducible results. For future consistency,\nit's recommended to copy the generated query and execute it manually using\n`await sdb.customQuery(query)` or to cache the query using the `cache` option.\n\nWhen `cache` is `true`, the generated query will be cached locally in\n`.journalism-cache` (from the `askAI` function in the\n[journalism library](https://github.com/nshiab/journalism)), saving resources\nand time. Remember to add `.journalism-cache` to your `.gitignore`.\n\n##### Signature\n\n```typescript\nasync aiQuery(prompt: string, options?: { cache?: boolean; model?: string; apiKey?: string; vertex?: boolean; project?: string; location?: string; ollama?: boolean | Ollama; contextWindow?: number; thinkingBudget?: number; verbose?: boolean }): Promise<void>;\n```\n\n##### Parameters\n\n- **`prompt`**: - The input string to guide the AI in generating the SQL query.\n- **`options`**: - Configuration options for the AI request.\n- **`options.cache`**: - If `true`, the generated query will be cached locally.\n  Defaults to `false`.\n- **`options.model`**: - The AI model to use. Defaults to the `AI_MODEL`\n  environment variable.\n- **`options.apiKey`**: - The API key for the AI service. Defaults to the\n  `AI_KEY` environment variable.\n- **`options.vertex`**: - If `true`, uses Vertex AI. Automatically set to `true`\n  if `AI_PROJECT` and `AI_LOCATION` are set in the environment. Defaults to\n  `false`.\n- **`options.project`**: - The Google Cloud project ID for Vertex AI. Defaults\n  to the `AI_PROJECT` environment variable.\n- **`options.location`**: - The Google Cloud location for Vertex AI. Defaults to\n  the `AI_LOCATION` environment variable.\n- **`options.ollama`**: - If `true`, uses Ollama. Defaults to the `OLLAMA`\n  environment variable. If you want your Ollama instance to be used, you can\n  pass it here too.\n- **`options.contextWindow`**: - An option to specify the context window size\n  for Ollama models. By default, Ollama sets this depending on the model, which\n  can be lower than the actual maximum context window size of the model.\n- **`options.thinkingBudget`**: - Sets the reasoning token budget: 0 to disable\n  (default, though some models may reason regardless), -1 for a dynamic budget,\n  or > 0 for a fixed budget. For Ollama models, any non-zero value simply\n  enables reasoning, ignoring the specific budget amount.\n- **`options.verbose`**: - If `true`, logs additional debugging information,\n  including the full prompt sent to the AI. Defaults to `false`.\n\n##### Returns\n\nA promise that resolves when the AI query has been executed.\n\n##### Examples\n\n```ts\n// The AI will generate a query that will be executed, and\n// the result will replace the existing table.\n// If run again, it will use the previous query from the cache.\n// Don't forget to add .journalism-cache to your .gitignore file!\nawait table.aiQuery(\n  \"Give me the average salary by department\",\n  { cache: true, verbose: true },\n);\n```",
  "\n#### `insertRows`\n\nInserts rows, provided as an array of JavaScript objects, into the table.\n\n##### Signature\n\n```typescript\nasync insertRows(rows: Record<string, unknown>[]): Promise<void>;\n```\n\n##### Parameters\n\n- **`rows`**: - An array of objects, where each object represents a row to be\n  inserted and its properties correspond to column names.\n\n##### Returns\n\nA promise that resolves when the rows have been inserted.\n\n##### Examples\n\n```ts\n// Insert new rows into the table\nconst newRows = [\n  { letter: \"c\", number: 3 },\n  { letter: \"d\", number: 4 },\n];\nawait table.insertRows(newRows);\n```",
  "\n#### `insertTables`\n\nInserts all rows from one or more other tables into this table. If tables do not\nhave the same columns, an error will be thrown unless the `unifyColumns` option\nis set to `true`.\n\n##### Signature\n\n```typescript\nasync insertTables(tablesToInsert: SimpleTable | SimpleTable[], options?: { unifyColumns?: boolean }): Promise<void>;\n```\n\n##### Parameters\n\n- **`tablesToInsert`**: - The name(s) of the table(s) or SimpleTable instance(s)\n  from which rows will be inserted.\n- **`options`**: - An optional object with configuration options:\n- **`options.unifyColumns`**: - A boolean indicating whether to unify the\n  columns of the tables. If `true`, missing columns in a table will be filled\n  with `NULL` values. Defaults to `false`.\n\n##### Returns\n\nA promise that resolves when the rows have been inserted.\n\n##### Examples\n\n```ts\n// Insert all rows from 'tableB' into 'tableA'.\nawait tableA.insertTables(\"tableB\");\n```\n\n```ts\n// Insert all rows from 'tableB' and 'tableC' into 'tableA'.\nawait tableA.insertTables([\"tableB\", \"tableC\"]);\n```\n\n```ts\n// Insert rows from multiple tables, unifying columns. Missing columns will be filled with NULL.\nawait tableA.insertTables([\"tableB\", \"tableC\"], { unifyColumns: true });\n```",
  "\n#### `cloneTable`\n\nReturns a new table with the same structure and data as this table. The data can\nbe optionally filtered. Note that cloning large tables can be a slow operation.\n\n##### Signature\n\n```typescript\nasync cloneTable(nameOrOptions?: string | { outputTable?: string; conditions?: string; columns?: string | string[] }): Promise<SimpleTable>;\n```\n\n##### Parameters\n\n- **`nameOrOptions`**: - Either a string specifying the name of the new table,\n  or an optional object with configuration options. If not provided, a default\n  name (e.g., \"table1\", \"table2\") will be generated.\n- **`nameOrOptions.outputTable`**: - The name of the new table to be created in\n  the database. If not provided, a default name (e.g., \"table1\", \"table2\") will\n  be generated.\n- **`nameOrOptions.conditions`**: - A SQL `WHERE` clause condition to filter the\n  data during cloning. Defaults to no condition (clones all rows).\n- **`nameOrOptions.columns`**: - An array of column names to include in the\n  cloned table. If not provided, all columns will be included.\n\n##### Returns\n\nA promise that resolves to the new SimpleTable instance containing the cloned\ndata.\n\n##### Examples\n\n```ts\n// Clone tableA to a new table with a default generated name (e.g., \"table1\")\nconst tableB = await tableA.cloneTable();\n```\n\n```ts\n// Clone tableA to a new table named \"my_cloned_table\" using string parameter\nconst tableB = await tableA.cloneTable(\"my_cloned_table\");\n```\n\n```ts\n// Clone tableA to a new table named \"my_cloned_table\" using options object\nconst tableB = await tableA.cloneTable({ outputTable: \"my_cloned_table\" });\n```\n\n```ts\n// Clone tableA, including only rows where 'column1' is greater than 10\nconst tableB = await tableA.cloneTable({ conditions: `column1 > 10` });\n```\n\n```ts\n// Clone tableA with only specific columns\nconst tableB = await tableA.cloneTable({ columns: [\"name\", \"age\", \"city\"] });\n```\n\n```ts\n// Clone tableA to a specific table name with filtered data and specific columns\nconst tableB = await tableA.cloneTable({\n  outputTable: \"filtered_data\",\n  conditions: `status = 'active' AND created_date >= '2023-01-01'`,\n  columns: [\"name\", \"status\", \"created_date\"],\n});\n```",
  "\n#### `cloneColumn`\n\nClones an existing column in this table, creating a new column with identical\nvalues.\n\n##### Signature\n\n```typescript\nasync cloneColumn(originalColumn: string, newColumn: string): Promise<void>;\n```\n\n##### Parameters\n\n- **`originalColumn`**: - The name of the original column to clone.\n- **`newColumn`**: - The name of the new column to be created.\n\n##### Returns\n\nA promise that resolves when the column has been cloned.\n\n##### Examples\n\n```ts\n// Clone 'firstName' column as 'contactName'\nawait table.cloneColumn(\"firstName\", \"contactName\");\n```",
  "\n#### `cloneColumnWithOffset`\n\nClones a column in the table and offsets its values by a specified number of\nrows. This is useful for time-series analysis or comparing values across\ndifferent time points.\n\n##### Signature\n\n```typescript\nasync cloneColumnWithOffset(originalColumn: string, newColumn: string, options?: { offset?: number; categories?: string | string[] }): Promise<void>;\n```\n\n##### Parameters\n\n- **`originalColumn`**: - The name of the original column.\n- **`newColumn`**: - The name of the new column to be created with offset\n  values.\n- **`options`**: - An optional object with configuration options:\n- **`options.offset`**: - The number of rows to offset the values. A positive\n  number shifts values downwards (later rows), a negative number shifts values\n  upwards (earlier rows). Defaults to `1`.\n- **`options.categories`**: - A string or an array of strings representing\n  columns to partition the data by. The offset will be applied independently\n  within each category.\n\n##### Returns\n\nA promise that resolves when the column has been cloned with offset values.\n\n##### Examples\n\n```ts\n// Clone 'value' as 'previous_value', offsetting by 1 row (value of row N-1 goes to row N)\nawait table.cloneColumnWithOffset(\"value\", \"previous_value\");\n```\n\n```ts\n// Clone 'sales' as 'sales_2_days_ago', offsetting by 2 rows\nawait table.cloneColumnWithOffset(\"sales\", \"sales_2_days_ago\", { offset: 2 });\n```\n\n```ts\n// Clone 'temperature' as 'prev_temp_by_city', offsetting by 1 row within each 'city' category\nawait table.cloneColumnWithOffset(\"temperature\", \"prev_temp_by_city\", {\n  offset: 1,\n  categories: \"city\",\n});\n```\n\n```ts\n// Clone 'stock_price' as 'prev_price_by_stock_and_exchange', offsetting by 1 row within each 'stock_symbol' and 'exchange' category\nawait table.cloneColumnWithOffset(\n  \"stock_price\",\n  \"prev_price_by_stock_and_exchange\",\n  {\n    offset: 1,\n    categories: [\"stock_symbol\", \"exchange\"],\n  },\n);\n```",
  "\n#### `fill`\n\nFills `NULL` values in specified columns with the last non-`NULL` value from the\npreceding row.\n\n##### Signature\n\n```typescript\nasync fill(columns: string | string[]): Promise<void>;\n```\n\n##### Parameters\n\n- **`columns`**: - The column(s) for which to fill `NULL` values.\n\n##### Returns\n\nA promise that resolves when the `NULL` values have been filled.\n\n##### Examples\n\n```ts\n// Fill NULL values in 'column1' with the previous non-NULL value\nawait table.fill(\"column1\");\n```\n\n```ts\n// Fill NULL values in multiple columns\nawait table.fill([\"columnA\", \"columnB\"]);\n```",
  "\n#### `sort`\n\nSorts the rows of the table based on specified column(s) and order(s). If no\ncolumns are specified, all columns are sorted from left to right in ascending\norder.\n\n##### Signature\n\n```typescript\nasync sort(order?: Record<string, \"asc\" | \"desc\"> | null, options?: { lang?: Record<string, string> }): Promise<void>;\n```\n\n##### Parameters\n\n- **`order`**: - An object mapping column names to their sorting order: `\"asc\"`\n  for ascending or `\"desc\"` for descending. If `null`, all columns are sorted\n  ascendingly.\n- **`options`**: - An optional object with configuration options:\n- **`options.lang`**: - An object mapping column names to language codes for\n  collation (e.g., `{ column1: \"fr\" }`). See DuckDB Collations documentation for\n  more details: https://duckdb.org/docs/sql/expressions/collations.\n\n##### Returns\n\nA promise that resolves when the table has been sorted.\n\n##### Examples\n\n```ts\n// Sort all columns from left to right in ascending order\nawait table.sort();\n```\n\n```ts\n// Sort 'column1' in ascending order\nawait table.sort({ column1: \"asc\" });\n```\n\n```ts\n// Sort 'column1' ascendingly, then 'column2' descendingly\nawait table.sort({ column1: \"asc\", column2: \"desc\" });\n```\n\n```ts\n// Sort 'column1' considering French accents\nawait table.sort({ column1: \"asc\" }, { lang: { column1: \"fr\" } });\n```",
  "\n#### `selectColumns`\n\nSelects specific columns in the table, removing all others.\n\n##### Signature\n\n```typescript\nasync selectColumns(columns: string | string[]): Promise<void>;\n```\n\n##### Parameters\n\n- **`columns`**: - The name or an array of names of the columns to be selected.\n\n##### Returns\n\nA promise that resolves when the columns have been selected.\n\n##### Examples\n\n```ts\n// Select only the 'firstName' and 'lastName' columns, removing all other columns.\nawait table.selectColumns([\"firstName\", \"lastName\"]);\n```\n\n```ts\n// Select only the 'productName' column.\nawait table.selectColumns(\"productName\");\n```",
  "\n#### `skip`\n\nSkips the first `n` rows of the table, effectively removing them.\n\n##### Signature\n\n```typescript\nasync skip(nbRowsToSkip: number): Promise<void>;\n```\n\n##### Parameters\n\n- **`nbRowsToSkip`**: - The number of rows to skip from the beginning of the\n  table.\n\n##### Returns\n\nA promise that resolves when the rows have been skipped.\n\n##### Examples\n\n```ts\n// Skip the first 10 rows of the table\nawait table.skip(10);\n```",
  "\n#### `hasColumn`\n\nChecks if a column with the specified name exists in the table.\n\n##### Signature\n\n```typescript\nasync hasColumn(column: string): Promise<boolean>;\n```\n\n##### Parameters\n\n- **`column`**: - The name of the column to check.\n\n##### Returns\n\nA promise that resolves to `true` if the column exists, `false` otherwise.\n\n##### Examples\n\n```ts\n// Check if the table has a column named \"age\"\nconst hasAgeColumn = await table.hasColumn(\"age\");\nconsole.log(hasAgeColumn); // Output: true or false\n```",
  "\n#### `sample`\n\nSelects random rows from the table, removing all others. You can optionally\nspecify a seed to ensure repeatable sampling.\n\n##### Signature\n\n```typescript\nasync sample(quantity: number | string, options?: { seed?: number }): Promise<void>;\n```\n\n##### Parameters\n\n- **`quantity`**: - The number of rows to select (e.g., `100`) or a percentage\n  string (e.g., `\"10%\"`) specifying the sampling size.\n- **`options`**: - An optional object with configuration options:\n- **`options.seed`**: - A number specifying the seed for repeatable sampling.\n  Using the same seed will always yield the same random rows. Defaults to a\n  random seed.\n\n##### Returns\n\nA promise that resolves when the sampling is complete.\n\n##### Examples\n\n```ts\n// Select 100 random rows from the table\nawait table.sample(100);\n```\n\n```ts\n// Select 10% of the rows randomly\nawait table.sample(\"10%\");\n```\n\n```ts\n// Select random rows with a specific seed for repeatable results\nawait table.sample(\"10%\", { seed: 123 });\n```",
  "\n#### `selectRows`\n\nSelects a specified number of rows from this table. An offset can be applied to\nskip initial rows, and the results can be output to a new table.\n\n##### Signature\n\n```typescript\nasync selectRows(count: number | string, options?: { offset?: number; outputTable?: string | boolean }): Promise<SimpleTable>;\n```\n\n##### Parameters\n\n- **`count`**: - The number of rows to select.\n- **`options`**: - An optional object with configuration options:\n- **`options.offset`**: - The number of rows to skip from the beginning of the\n  table before selecting. Defaults to `0`.\n- **`options.outputTable`**: - If `true`, the selected rows will be stored in a\n  new table with a generated name. If a string, it will be used as the name for\n  the new table. If `false` or omitted, the current table will be modified.\n  Defaults to `false`.\n\n##### Returns\n\nA promise that resolves to the SimpleTable instance containing the selected rows\n(either the modified current table or a new table).\n\n##### Examples\n\n```ts\n// Select the first 100 rows of the current table\nawait table.selectRows(100);\n```\n\n```ts\n// Select 100 rows after skipping the first 50 rows\nawait table.selectRows(100, { offset: 50 });\n```\n\n```ts\n// Select 50 rows and store them in a new table with a generated name\nconst newTable = await table.selectRows(50, { outputTable: true });\n```\n\n```ts\n// Select 75 rows and store them in a new table named \"top_customers\"\nconst topCustomersTable = await table.selectRows(75, {\n  outputTable: \"top_customers\",\n});\n```",
  "\n#### `removeDuplicates`\n\nRemoves duplicate rows from this table, keeping only unique rows. Note that the\nresulting data order might differ from the original.\n\n##### Signature\n\n```typescript\nasync removeDuplicates(options?: { on?: string | string[] }): Promise<void>;\n```\n\n##### Parameters\n\n- **`options`**: - An optional object with configuration options:\n- **`options.on`**: - A column name or an array of column names to consider when\n  identifying duplicates. If specified, duplicates are determined based only on\n  the values in these columns. If omitted, all columns are considered.\n\n##### Returns\n\nA promise that resolves when the duplicate rows have been removed.\n\n##### Examples\n\n```ts\n// Remove duplicate rows based on all columns\nawait table.removeDuplicates();\n```\n\n```ts\n// Remove duplicate rows based only on the 'email' column\nawait table.removeDuplicates({ on: \"email\" });\n```\n\n```ts\n// Remove duplicate rows based on 'firstName' and 'lastName' columns\nawait table.removeDuplicates({ on: [\"firstName\", \"lastName\"] });\n```",
  "\n#### `removeMissing`\n\nRemoves rows with missing values from this table. By default, missing values\ninclude SQL `NULL`, as well as string representations like `\"NULL\"`, `\"null\"`,\n`\"NaN\"`, `\"undefined\"`, and empty strings `\"\"`.\n\n##### Signature\n\n```typescript\nasync removeMissing(options?: { columns?: string | string[]; missingValues?: (string | number)[]; invert?: boolean }): Promise<void>;\n```\n\n##### Parameters\n\n- **`options`**: - An optional object with configuration options:\n- **`options.columns`**: - A string or an array of strings specifying the\n  columns to consider for missing values. If omitted, all columns are\n  considered.\n- **`options.missingValues`**: - An array of values to be treated as missing\n  values instead of the default ones. Defaults to\n  `[\"undefined\", \"NaN\", \"null\", \"NULL\", \"\"]`.\n- **`options.invert`**: - A boolean indicating whether to invert the condition.\n  If `true`, only rows containing missing values will be kept. Defaults to\n  `false`.\n\n##### Returns\n\nA promise that resolves when the rows with missing values have been removed.\n\n##### Examples\n\n```ts\n// Remove rows with missing values in any column\nawait table.removeMissing();\n```\n\n```ts\n// Remove rows with missing values only in 'firstName' or 'lastName' columns\nawait table.removeMissing({ columns: [\"firstName\", \"lastName\"] });\n```\n\n```ts\n// Keep only rows with missing values in any column\nawait table.removeMissing({ invert: true });\n```\n\n```ts\n// Remove rows where 'age' is missing or is equal to -1\nawait table.removeMissing({ columns: \"age\", missingValues: [-1] });\n```",
  "\n#### `trim`\n\nTrims specified characters from the beginning, end, or both sides of string\nvalues in the given columns.\n\n##### Signature\n\n```typescript\nasync trim(columns: string | string[], options?: { character?: string; method?: \"leftTrim\" | \"rightTrim\" | \"trim\" }): Promise<void>;\n```\n\n##### Parameters\n\n- **`columns`**: - The column name or an array of column names to trim.\n- **`options`**: - An optional object with configuration options:\n- **`options.character`**: - The string to trim. Defaults to whitespace\n  characters.\n- **`options.method`**: - The trimming method to apply: `\"leftTrim\"` (removes\n  from the beginning), `\"rightTrim\"` (removes from the end), or `\"trim\"`\n  (removes from both sides). Defaults to `\"trim\"`.\n\n##### Returns\n\nA promise that resolves when the trimming operation is complete.\n\n##### Examples\n\n```ts\n// Trim whitespace from 'column1'\nawait table.trim(\"column1\");\n```\n\n```ts\n// Trim leading and trailing asterisks from 'productCode'\nawait table.trim(\"productCode\", { character: \"*\" });\n```\n\n```ts\n// Right-trim whitespace from 'description' and 'notes' columns\nawait table.trim([\"description\", \"notes\"], { method: \"rightTrim\" });\n```",
  "\n#### `filter`\n\nFilters rows from this table based on SQL conditions. Note that it's often\nfaster to use the `removeRows` method for simple removals. You can also use\nJavaScript syntax for conditions (e.g., `&&`, `||`, `===`, `!==`).\n\n##### Signature\n\n```typescript\nasync filter(conditions: string): Promise<void>;\n```\n\n##### Parameters\n\n- **`conditions`**: - The filtering conditions specified as a SQL `WHERE` clause\n  (e.g., `\"column1 > 10 AND column2 = 'value'\"`).\n\n##### Returns\n\nA promise that resolves when the rows have been filtered.\n\n##### Examples\n\n```ts\n// Keep only rows where the 'fruit' column is not 'apple'\nawait table.filter(`fruit != 'apple'`);\n```\n\n```ts\n// Keep rows where 'price' is greater than 100 AND 'quantity' is greater than 0\nawait table.filter(`price > 100 && quantity > 0`); // Using JS syntax\n```\n\n```ts\n// Keep rows where 'category' is 'Electronics' OR 'Appliances'\nawait table.filter(`category === 'Electronics' || category === 'Appliances'`); // Using JS syntax\n```\n\n```ts\n// Keep rows where 'lastPurchaseDate' is on or after '2023-01-01'\nawait table.filter(`lastPurchaseDate >= '2023-01-01'`);\n```",
  "\n#### `keep`\n\nKeeps rows in this table that have specific values in specified columns,\nremoving all other rows.\n\n##### Signature\n\n```typescript\nasync keep(columnsAndValues: Record<string, (number | string | Date | boolean | null)[] | (number | string | Date | boolean | null)>): Promise<void>;\n```\n\n##### Parameters\n\n- **`columnsAndValues`**: - An object where keys are column names and values are\n  the specific values (or an array of values) to keep in those columns.\n\n##### Returns\n\nA promise that resolves when the rows have been filtered.\n\n##### Examples\n\n```ts\n// Keep only rows where 'job' is 'accountant' or 'developer', AND 'city' is 'Montreal'\nawait table.keep({ job: [\"accountant\", \"developer\"], city: \"Montreal\" });\n```\n\n```ts\n// Keep only rows where 'status' is 'active'\nawait table.keep({ status: \"active\" });\n```",
  "\n#### `remove`\n\nRemoves rows from this table that have specific values in specified columns.\n\n##### Signature\n\n```typescript\nasync remove(columnsAndValues: Record<string, (number | string | Date | boolean | null)[] | (number | string | Date | boolean | null)>): Promise<void>;\n```\n\n##### Parameters\n\n- **`columnsAndValues`**: - An object where keys are column names and values are\n  the specific values (or an array of values) to remove from those columns.\n\n##### Returns\n\nA promise that resolves when the rows have been removed.\n\n##### Examples\n\n```ts\n// Remove rows where 'job' is 'accountant' or 'developer', AND 'city' is 'Montreal'\nawait table.remove({ job: [\"accountant\", \"developer\"], city: \"Montreal\" });\n```\n\n```ts\n// Remove rows where 'status' is 'inactive'\nawait table.remove({ status: \"inactive\" });\n```",
  "\n#### `removeRows`\n\nRemoves rows from this table based on SQL conditions. This method is similar to\n`filter()`, but removes rows instead of keeping them. You can also use\nJavaScript syntax for conditions (e.g., `&&`, `||`, `===`, `!==`).\n\n##### Signature\n\n```typescript\nasync removeRows(conditions: string): Promise<void>;\n```\n\n##### Parameters\n\n- **`conditions`**: - The filtering conditions specified as a SQL `WHERE` clause\n  (e.g., `\"fruit = 'apple'\"`).\n\n##### Returns\n\nA promise that resolves when the rows have been removed.\n\n##### Examples\n\n```ts\n// Remove rows where the 'fruit' column is 'apple'\nawait table.removeRows(`fruit = 'apple'`);\n```\n\n```ts\n// Remove rows where 'quantity' is less than 5\nawait table.removeRows(`quantity < 5`);\n```\n\n```ts\n// Remove rows where 'price' is less than 100 AND 'quantity' is 0\nawait table.removeRows(`price < 100 && quantity === 0`); // Using JS syntax\n```\n\n```ts\n// Remove rows where 'category' is 'Electronics' OR 'Appliances'\nawait table.removeRows(\n  `category === 'Electronics' || category === 'Appliances'`,\n); // Using JS syntax\n```",
  "\n#### `renameColumns`\n\nRenames one or more columns in the table.\n\n##### Signature\n\n```typescript\nasync renameColumns(names: Record<string, string>): Promise<void>;\n```\n\n##### Parameters\n\n- **`names`**: - An object mapping old column names to their new column names\n  (e.g., `{ \"oldName\": \"newName\", \"anotherOld\": \"anotherNew\" }`).\n\n##### Returns\n\nA promise that resolves when the columns have been renamed.\n\n##### Examples\n\n```ts\n// Rename \"How old?\" to \"age\" and \"Man or woman?\" to \"sex\"\nawait table.renameColumns({ \"How old?\": \"age\", \"Man or woman?\": \"sex\" });\n```\n\n```ts\n// Rename a single column\nawait table.renameColumns({ \"product_id\": \"productId\" });\n```",
  "\n#### `cleanColumnNames`\n\nCleans column names by removing non-alphanumeric characters and formatting them\nto camel case.\n\n##### Signature\n\n```typescript\nasync cleanColumnNames(): Promise<void>;\n```\n\n##### Returns\n\nA promise that resolves when the column names have been cleaned.\n\n##### Examples\n\n```ts\n// Clean all column names in the table\n// e.g., \"First Name\" becomes \"firstName\", \"Product ID\" becomes \"productId\"\nawait table.cleanColumnNames();\n```",
  "\n#### `longer`\n\nRestructures this table by stacking (unpivoting) columns. This is useful for\ntidying up data from a wide format to a long format.\n\nFor example, given a table showing employee counts per department per year:\n\n| Department | 2021 | 2022 | 2023 |\n| :--------- | :--- | :--- | :--- |\n| Accounting | 10   | 9    | 15   |\n| Sales      | 52   | 75   | 98   |\n\nWe can restructure it by putting all year columns into a new column named `Year`\nand their corresponding employee counts into a new column named `Employees`.\n\n##### Signature\n\n```typescript\nasync longer(columns: string[], columnsTo: string, valuesTo: string): Promise<void>;\n```\n\n##### Parameters\n\n- **`columns`**: - An array of strings representing the names of the columns to\n  be stacked (unpivoted).\n- **`columnsTo`**: - The name of the new column that will contain the original\n  column names (e.g., \"Year\").\n- **`valuesTo`**: - The name of the new column that will contain the values from\n  the stacked columns (e.g., \"Employees\").\n\n##### Returns\n\nA promise that resolves when the table has been restructured.\n\n##### Examples\n\n```ts\n// Restructure the table by stacking year columns into 'year' and 'employees'\nawait table.longer([\"2021\", \"2022\", \"2023\"], \"year\", \"employees\");\n```\n\nThe table will then look like this:\n\n| Department | Year | Employees |\n| :--------- | :--- | :-------- |\n| Accounting | 2021 | 10        |\n| Accounting | 2022 | 9         |\n| Accounting | 2023 | 15        |\n| Sales      | 2021 | 52        |\n| Sales      | 2022 | 75        |\n| Sales      | 2023 | 98        |",
  "\n#### `wider`\n\nRestructures this table by unstacking (pivoting) values, transforming data from\na long format to a wide format.\n\nFor example, given a table showing employee counts per department per year:\n\n| Department | Year | Employees |\n| :--------- | :--- | :-------- |\n| Accounting | 2021 | 10        |\n| Accounting | 2022 | 9         |\n| Accounting | 2023 | 15        |\n| Sales      | 2021 | 52        |\n| Sales      | 2022 | 75        |\n| Sales      | 2023 | 98        |\n\nWe can restructure it by creating new columns for each year, with the associated\nemployee counts as values.\n\n##### Signature\n\n```typescript\nasync wider(columnsFrom: string, valuesFrom: string): Promise<void>;\n```\n\n##### Parameters\n\n- **`columnsFrom`**: - The name of the column containing the values that will be\n  transformed into new column headers (e.g., \"Year\").\n- **`valuesFrom`**: - The name of the column containing the values to be spread\n  across the new columns (e.g., \"Employees\").\n\n##### Returns\n\nA promise that resolves when the table has been restructured.\n\n##### Examples\n\n```ts\n// Restructure the table by pivoting 'Year' into new columns with 'Employees' as values\nawait table.wider(\"Year\", \"Employees\");\n```\n\nThe table will then look like this:\n\n| Department | 2021 | 2022 | 2023 |\n| :--------- | :--- | :--- | :--- |\n| Accounting | 10   | 9    | 15   |\n| Sales      | 52   | 75   | 98   |",
  "\n#### `convert`\n\nConverts data types of specified columns to target types (JavaScript or SQL\ntypes).\n\nWhen converting timestamps, dates, or times to/from strings, you must provide a\n`datetimeFormat` option using\n[DuckDB's format specifiers](https://duckdb.org/docs/sql/functions/dateformat).\n\nWhen converting timestamps, dates, or times to/from numbers, the numerical\nrepresentation will be in milliseconds since the Unix epoch (1970-01-01 00:00:00\nUTC).\n\nWhen converting strings to numbers, commas (often used as thousand separators)\nwill be automatically removed before conversion.\n\n##### Signature\n\n```typescript\nasync convert(types: Record<string, \"integer\" | \"float\" | \"number\" | \"string\" | \"date\" | \"time\" | \"datetime\" | \"datetimeTz\" | \"bigint\" | \"double\" | \"varchar\" | \"timestamp\" | \"timestamp with time zone\" | \"boolean\">, options?: { try?: boolean; datetimeFormat?: string }): Promise<void>;\n```\n\n##### Parameters\n\n- **`types`**: - An object mapping column names to their target data types for\n  conversion.\n- **`options`**: - An optional object with configuration options:\n- **`options.try`**: - If `true`, values that cannot be converted will be\n  replaced by `NULL` instead of throwing an error. Defaults to `false`.\n- **`options.datetimeFormat`**: - A string specifying the format for date and\n  time conversions. Uses `strftime` and `strptime` functions from DuckDB. For\n  format specifiers, see\n  [DuckDB's documentation](https://duckdb.org/docs/sql/functions/dateformat).\n\n##### Returns\n\nA promise that resolves when the column types have been converted.\n\n##### Examples\n\n```ts\n// Convert 'column1' to string and 'column2' to integer (JavaScript types)\nawait table.convert({ column1: \"string\", column2: \"integer\" });\n```\n\n```ts\n// Convert 'column1' to VARCHAR and 'column2' to BIGINT (SQL types)\nawait table.convert({ column1: \"varchar\", column2: \"bigint\" });\n```\n\n```ts\n// Convert strings in 'column3' to datetime using a specific format\nawait table.convert({ column3: \"datetime\" }, { datetimeFormat: \"%Y-%m-%d\" });\n```\n\n```ts\n// Convert datetime values in 'column3' to strings using a specific format\nawait table.convert({ column3: \"string\" }, {\n  datetimeFormat: \"%Y-%m-%d %H:%M:%S\",\n});\n```\n\n```ts\n// Convert 'amount' to float, replacing unconvertible values with NULL\nawait table.convert({ amount: \"float\" }, { try: true });\n```",
  "\n#### `removeTable`\n\nRemoves the table from the database. After this operation, invoking methods on\nthis SimpleTable instance will result in an error.\n\n##### Signature\n\n```typescript\nasync removeTable(): Promise<void>;\n```\n\n##### Returns\n\nA promise that resolves when the table has been removed.\n\n##### Examples\n\n```ts\n// Remove the current table from the database\nawait table.removeTable();\n```",
  "\n#### `removeColumns`\n\nRemoves one or more columns from this table.\n\n##### Signature\n\n```typescript\nasync removeColumns(columns: string | string[]): Promise<void>;\n```\n\n##### Parameters\n\n- **`columns`**: - The name or an array of names of the columns to be removed.\n\n##### Returns\n\nA promise that resolves when the columns have been removed.\n\n##### Examples\n\n```ts\n// Remove 'column1' and 'column2' from the table\nawait table.removeColumns([\"column1\", \"column2\"]);\n```\n\n```ts\n// Remove a single column named 'tempColumn'\nawait table.removeColumns(\"tempColumn\");\n```",
  "\n#### `addColumn`\n\nAdds a new column to the table based on a specified data type (JavaScript or SQL\ntypes) and a SQL definition.\n\n##### Signature\n\n```typescript\nasync addColumn(newColumn: string, type: \"integer\" | \"float\" | \"number\" | \"string\" | \"date\" | \"time\" | \"datetime\" | \"datetimeTz\" | \"bigint\" | \"double\" | \"varchar\" | \"timestamp\" | \"timestamp with time zone\" | \"boolean\" | \"geometry\", definition: string, options?: { projection?: string }): Promise<void>;\n```\n\n##### Parameters\n\n- **`newColumn`**: - The name of the new column to be added.\n- **`type`**: - The data type for the new column. Can be a JavaScript type\n  (e.g., `\"number\"`, `\"string\"`) or a SQL type (e.g., `\"integer\"`, `\"varchar\"`).\n- **`definition`**: - A SQL expression defining how the values for the new\n  column should be computed (e.g., `\"column1 + column2\"`,\n  `\"ST_Centroid(geom_column)\"`).\n- **`options`**: - An optional object with configuration options:\n- **`options.projection`**: - Required if the new column stores geometries.\n  Specifies the geospatial projection of the new geometry column. You can reuse\n  the projection of an existing geometry column (available in\n  `table.projections`).\n\n##### Returns\n\nA promise that resolves when the new column has been added.\n\n##### Examples\n\n```ts\n// Add a new column 'total' as a float, calculated from 'column1' and 'column2'\nawait table.addColumn(\"total\", \"float\", \"column1 + column2\");\n```\n\n```ts\n// Add a new geometry column 'centroid' using the centroid of an existing 'country' geometry column\n// The projection of the new 'centroid' column is set to be the same as 'country'.\nawait table.addColumn(\"centroid\", \"geometry\", `ST_Centroid(\"country\")`, {\n  projection: table.projections.country,\n});\n```",
  "\n#### `addRowNumber`\n\nAdds a new column to the table containing the row number.\n\n##### Signature\n\n```typescript\nasync addRowNumber(newColumn: string): Promise<void>;\n```\n\n##### Parameters\n\n- **`newColumn`**: - The name of the new column that will store the row number.\n\n##### Returns\n\nA promise that resolves when the row number column has been added.\n\n##### Examples\n\n```ts\n// Add a new column named 'rowNumber' with the row number for each row\nawait table.addRowNumber(\"rowNumber\");\n```",
  "\n#### `crossJoin`\n\nPerforms a cross join operation with another table. A cross join returns the\nCartesian product of the rows from both tables, meaning all possible pairs of\nrows will be in the resulting table. This means that if the left table has `n`\nrows and the right table has `m` rows, the result will have `n * m` rows.\n\n##### Signature\n\n```typescript\nasync crossJoin(rightTable: SimpleTable, options?: { outputTable?: string | boolean }): Promise<SimpleTable>;\n```\n\n##### Parameters\n\n- **`rightTable`**: - The SimpleTable instance to cross join with.\n- **`options`**: - An optional object with configuration options:\n- **`options.outputTable`**: - If `true`, the results will be stored in a new\n  table with a generated name. If a string, it will be used as the name for the\n  new table. If `false` or omitted, the current table will be overwritten.\n  Defaults to `false`.\n\n##### Returns\n\nA promise that resolves to the SimpleTable instance containing the cross-joined\ndata (either the modified current table or a new table).\n\n##### Examples\n\n```ts\n// Perform a cross join with 'tableB', overwriting the current table (tableA)\nawait tableA.crossJoin(tableB);\n```\n\n```ts\n// Perform a cross join with 'tableB' and store the results in a new table with a generated name\nconst tableC = await tableA.crossJoin(tableB, { outputTable: true });\n```\n\n```ts\n// Perform a cross join with 'tableB' and store the results in a new table named 'tableC'\nconst tableC = await tableA.crossJoin(tableB, { outputTable: \"tableC\" });\n```",
  "\n#### `join`\n\nMerges the data of this table (considered the left table) with another table\n(the right table) based on a common column or multiple columns. Note that the\norder of rows in the returned data is not guaranteed to be the same as in the\noriginal tables. This operation might create temporary files in a `.tmp` folder;\nconsider adding `.tmp` to your `.gitignore`.\n\n##### Signature\n\n```typescript\nasync join(rightTable: SimpleTable, options?: { commonColumn?: string | string[]; type?: \"inner\" | \"left\" | \"right\" | \"full\"; outputTable?: string | boolean }): Promise<SimpleTable>;\n```\n\n##### Parameters\n\n- **`rightTable`**: - The SimpleTable instance to be joined with this table.\n- **`options`**: - An optional object with configuration options:\n- **`options.commonColumn`**: - The common column(s) used for the join\n  operation. If omitted, the method automatically searches for a column name\n  that exists in both tables. Can be a single string or an array of strings for\n  multiple join keys.\n- **`options.type`**: - The type of join operation to perform. Possible values\n  are `\"inner\"`, `\"left\"` (default), `\"right\"`, or `\"full\"`.\n- **`options.outputTable`**: - If `true`, the results will be stored in a new\n  table with a generated name. If a string, it will be used as the name for the\n  new table. If `false` or omitted, the current table will be overwritten.\n  Defaults to `false`.\n\n##### Returns\n\nA promise that resolves to the SimpleTable instance containing the joined data\n(either the modified current table or a new table).\n\n##### Examples\n\n```ts\n// Perform a left join with 'tableB' on a common column (auto-detected), overwriting tableA\nawait tableA.join(tableB);\n```\n\n```ts\n// Perform an inner join with 'tableB' on the 'id' column, storing results in a new table named 'tableC'\nconst tableC = await tableA.join(tableB, {\n  commonColumn: \"id\",\n  type: \"inner\",\n  outputTable: \"tableC\",\n});\n```\n\n```ts\n// Perform a join on multiple columns ('name' and 'category')\nawait tableA.join(tableB, { commonColumn: [\"name\", \"category\"] });\n```",
  "\n#### `replace`\n\nReplaces specified strings in the selected columns.\n\n##### Signature\n\n```typescript\nasync replace(columns: string | string[], strings: Record<string, string>, options?: { entireString?: boolean; regex?: boolean }): Promise<void>;\n```\n\n##### Parameters\n\n- **`columns`**: - The column name or an array of column names where string\n  replacements will occur.\n- **`strings`**: - An object mapping old strings to new strings (e.g.,\n  `{ \"oldValue\": \"newValue\" }`).\n- **`options`**: - An optional object with configuration options:\n- **`options.entireString`**: - A boolean indicating whether the entire cell\n  content must match the `oldString` for replacement to occur. Defaults to\n  `false` (replaces substrings).\n- **`options.regex`**: - A boolean indicating whether the `oldString` should be\n  treated as a regular expression for global replacement. Cannot be used with\n  `entireString: true`. Defaults to `false`.\n\n##### Returns\n\nA promise that resolves when the string replacements are complete.\n\n##### Examples\n\n```ts\n// Replace all occurrences of \"kilograms\" with \"kg\" in 'column1'\nawait table.replace(\"column1\", { \"kilograms\": \"kg\" });\n```\n\n```ts\n// Replace \"kilograms\" with \"kg\" and \"liters\" with \"l\" in 'column1' and 'column2'\nawait table.replace([\"column1\", \"column2\"], {\n  \"kilograms\": \"kg\",\n  \"liters\": \"l\",\n});\n```\n\n```ts\n// Replace only if the entire string in 'column1' is \"kilograms\"\nawait table.replace(\"column1\", { \"kilograms\": \"kg\" }, { entireString: true });\n```\n\n```ts\n// Replace any sequence of one or more digits with a hyphen in 'column1' using regex\nawait table.replace(\"column1\", { \"\\d+\": \"-\" }, { regex: true });\n```",
  "\n#### `lower`\n\nConverts string values in the specified columns to lowercase.\n\n##### Signature\n\n```typescript\nasync lower(columns: string | string[]): Promise<void>;\n```\n\n##### Parameters\n\n- **`columns`**: - The column name or an array of column names to be converted\n  to lowercase.\n\n##### Returns\n\nA promise that resolves when the strings have been converted to lowercase.\n\n##### Examples\n\n```ts\n// Convert strings in 'column1' to lowercase\nawait table.lower(\"column1\");\n```\n\n```ts\n// Convert strings in 'column1' and 'column2' to lowercase\nawait table.lower([\"column1\", \"column2\"]);\n```",
  "\n#### `upper`\n\nConverts string values in the specified columns to uppercase.\n\n##### Signature\n\n```typescript\nasync upper(columns: string | string[]): Promise<void>;\n```\n\n##### Parameters\n\n- **`columns`**: - The column name or an array of column names to be converted\n  to uppercase.\n\n##### Returns\n\nA promise that resolves when the strings have been converted to uppercase.\n\n##### Examples\n\n```ts\n// Convert strings in 'column1' to uppercase\nawait table.upper(\"column1\");\n```\n\n```ts\n// Convert strings in 'column1' and 'column2' to uppercase\nawait table.upper([\"column1\", \"column2\"]);\n```",
  "\n#### `capitalize`\n\nCapitalizes the first letter of each string in the specified columns and\nconverts the rest of the string to lowercase.\n\n##### Signature\n\n```typescript\nasync capitalize(columns: string | string[]): Promise<void>;\n```\n\n##### Parameters\n\n- **`columns`**: - The column name or an array of column names to be\n  capitalized.\n\n##### Returns\n\nA promise that resolves when the strings have been capitalized.\n\n##### Examples\n\n```ts\n// Capitalize strings in 'column1' (e.g., \"hello world\" becomes \"Hello world\")\nawait table.capitalize(\"column1\");\n```\n\n```ts\n// Capitalize strings in 'column1' and 'column2'\nawait table.capitalize([\"column1\", \"column2\"]);\n```",
  "\n#### `splitExtract`\n\nSplits strings in a specified column by a separator and extracts a substring at\na given index, storing the result in a new or existing column. If the index is\nout of bounds, an empty string will be returned for that row.\n\n##### Signature\n\n```typescript\nasync splitExtract(column: string, separator: string, index: number, newColumn: string): Promise<void>;\n```\n\n##### Parameters\n\n- **`column`**: - The name of the column containing the strings to be split.\n- **`separator`**: - The substring to use as a delimiter for splitting the\n  strings.\n- **`index`**: - The zero-based index of the substring to extract after\n  splitting. For example, `0` for the first part, `1` for the second, etc.\n- **`newColumn`**: - The name of the column where the extracted substrings will\n  be stored. To overwrite the original column, use the same name as `column`.\n\n##### Returns\n\nA promise that resolves when the strings have been split and extracted.\n\n##### Examples\n\n```ts\n// Split 'address' by comma and extract the second part (index 1) into a new 'city' column\n// e.g., \"123 Main St, Anytown, USA\" -> \"Anytown\"\nawait table.splitExtract(\"address\", \",\", 1, \"city\");\n```\n\n```ts\n// Split 'fileName' by dot and extract the first part (index 0), overwriting 'fileName'\n// e.g., \"document.pdf\" -> \"document\"\nawait table.splitExtract(\"fileName\", \".\", 0, \"fileName\");\n```",
  "\n#### `left`\n\nExtracts a specific number of characters from the beginning (left side) of\nstring values in the specified column.\n\n##### Signature\n\n```typescript\nasync left(column: string, numberOfCharacters: number): Promise<void>;\n```\n\n##### Parameters\n\n- **`column`**: - The name of the column containing the strings to be modified.\n- **`numberOfCharacters`**: - The number of characters to extract from the left\n  side of each string.\n\n##### Returns\n\nA promise that resolves when the strings have been updated.\n\n##### Examples\n\n```ts\n// Replace strings in 'productCode' with their first two characters\n// e.g., \"ABC-123\" becomes \"AB\"\nawait table.left(\"productCode\", 2);\n```",
  "\n#### `right`\n\nExtracts a specific number of characters from the end (right side) of string\nvalues in the specified column.\n\n##### Signature\n\n```typescript\nasync right(column: string, numberOfCharacters: number): Promise<void>;\n```\n\n##### Parameters\n\n- **`column`**: - The name of the column containing the strings to be modified.\n- **`numberOfCharacters`**: - The number of characters to extract from the right\n  side of each string.\n\n##### Returns\n\nA promise that resolves when the strings have been updated.\n\n##### Examples\n\n```ts\n// Replace strings in 'productCode' with their last two characters\n// e.g., \"ABC-123\" becomes \"23\"\nawait table.right(\"productCode\", 2);\n```",
  "\n#### `replaceNulls`\n\nReplaces `NULL` values in the specified columns with a given value.\n\n##### Signature\n\n```typescript\nasync replaceNulls(columns: string | string[], value: number | string | Date | boolean): Promise<void>;\n```\n\n##### Parameters\n\n- **`columns`**: - The column name or an array of column names in which to\n  replace `NULL` values.\n- **`value`**: - The value to replace `NULL` occurrences with.\n\n##### Returns\n\nA promise that resolves when the `NULL` values have been replaced.\n\n##### Examples\n\n```ts\n// Replace NULL values in 'column1' with 0\nawait table.replaceNulls(\"column1\", 0);\n```\n\n```ts\n// Replace NULL values in 'columnA' and 'columnB' with the string \"N/A\"\nawait table.replaceNulls([\"columnA\", \"columnB\"], \"N/A\");\n```\n\n```ts\n// Replace NULL values in 'dateColumn' with a specific date\nawait table.replaceNulls(\"dateColumn\", new Date(\"2023-01-01\"));\n```",
  "\n#### `concatenate`\n\nConcatenates values from specified columns into a new column.\n\n##### Signature\n\n```typescript\nasync concatenate(columns: string[], newColumn: string, options?: { separator?: string }): Promise<void>;\n```\n\n##### Parameters\n\n- **`columns`**: - An array of column names whose values will be concatenated.\n- **`newColumn`**: - The name of the new column to store the concatenated\n  values.\n- **`options`**: - An optional object with configuration options:\n- **`options.separator`**: - The string used to separate concatenated values.\n  Defaults to an empty string (`\"\"`).\n\n##### Returns\n\nA promise that resolves when the concatenation is complete.\n\n##### Examples\n\n```ts\n// Concatenate 'firstName' and 'lastName' into a new 'fullName' column\nawait table.concatenate([\"firstName\", \"lastName\"], \"fullName\");\n```\n\n```ts\n// Concatenate 'city' and 'country' into 'location', separated by a comma and space\nawait table.concatenate([\"city\", \"country\"], \"location\", { separator: \", \" });\n```",
  "\n#### `round`\n\nRounds numeric values in specified columns.\n\n##### Signature\n\n```typescript\nasync round(columns: string | string[], options?: { decimals?: number; method?: \"round\" | \"ceiling\" | \"floor\" }): Promise<void>;\n```\n\n##### Parameters\n\n- **`columns`**: - The column name or an array of column names containing\n  numeric values to be rounded.\n- **`options`**: - An optional object with configuration options:\n- **`options.decimals`**: - The number of decimal places to round to. Defaults\n  to `0` (rounds to the nearest integer).\n- **`options.method`**: - The rounding method to use: `\"round\"` (rounds to the\n  nearest integer, with halves rounding up), `\"ceiling\"` (rounds up to the\n  nearest integer), or `\"floor\"` (rounds down to the nearest integer). Defaults\n  to `\"round\"`.\n\n##### Returns\n\nA promise that resolves when the numeric values have been rounded.\n\n##### Examples\n\n```ts\n// Round 'column1' values to the nearest integer\nawait table.round(\"column1\");\n```\n\n```ts\n// Round 'column1' values to 2 decimal places\nawait table.round(\"column1\", { decimals: 2 });\n```\n\n```ts\n// Round 'column1' values down to the nearest integer (floor)\nawait table.round(\"column1\", { method: \"floor\" });\n```\n\n```ts\n// Round 'columnA' and 'columnB' values to 1 decimal place using ceiling method\nawait table.round([\"columnA\", \"columnB\"], { decimals: 1, method: \"ceiling\" });\n```",
  "\n#### `updateColumn`\n\nUpdates values in a specified column using a SQL expression.\n\n##### Signature\n\n```typescript\nasync updateColumn(column: string, definition: string): Promise<void>;\n```\n\n##### Parameters\n\n- **`column`**: - The name of the column to be updated.\n- **`definition`**: - The SQL expression used to set the new values in the\n  column (e.g., `\"column1 * 2\"`, `\"UPPER(column_name)\"`).\n\n##### Returns\n\nA promise that resolves when the column has been updated.\n\n##### Examples\n\n```ts\n// Update 'column1' with the left 5 characters of 'column2'\nawait table.updateColumn(\"column1\", `LEFT(column2, 5)`);\n```\n\n```ts\n// Double the values in 'price' column\nawait table.updateColumn(\"price\", `price * 2`);\n```\n\n```ts\n// Set 'status' to 'active' where 'isActive' is true\nawait table.updateColumn(\n  \"status\",\n  `CASE WHEN isActive THEN 'active' ELSE 'inactive' END`,\n);\n```",
  "\n#### `ranks`\n\nAssigns ranks to rows in a new column based on the values of a specified column.\n\n##### Signature\n\n```typescript\nasync ranks(values: string, newColumn: string, options?: { order?: \"asc\" | \"desc\"; categories?: string | string[]; noGaps?: boolean }): Promise<void>;\n```\n\n##### Parameters\n\n- **`values`**: - The column containing the values to be used for ranking.\n- **`newColumn`**: - The name of the new column where the ranks will be stored.\n- **`options`**: - An optional object with configuration options:\n- **`options.order`**: - The order of values for ranking: `\"asc\"` for ascending\n  (default) or `\"desc\"` for descending.\n- **`options.categories`**: - The column name or an array of column names that\n  define categories for ranking. Ranks will be assigned independently within\n  each category.\n- **`options.noGaps`**: - A boolean indicating whether to assign ranks without\n  gaps (dense ranking). If `true`, ranks will be consecutive integers (e.g., 1,\n  2, 2, 3). If `false` (default), ranks might have gaps (e.g., 1, 2, 2, 4).\n\n##### Returns\n\nA promise that resolves when the ranks have been assigned.\n\n##### Examples\n\n```ts\n// Compute ranks in a new 'rank' column based on 'score' values (ascending)\nawait table.ranks(\"score\", \"rank\");\n```\n\n```ts\n// Compute ranks in a new 'descRank' column based on 'score' values (descending)\nawait table.ranks(\"score\", \"descRank\", { order: \"desc\" });\n```\n\n```ts\n// Compute ranks within 'department' categories, based on 'salary' values, without gaps\nawait table.ranks(\"salary\", \"salaryRank\", {\n  categories: \"department\",\n  noGaps: true,\n});\n```\n\n```ts\n// Compute ranks within multiple categories ('department' and 'city')\nawait table.ranks(\"sales\", \"salesRank\", { categories: [\"department\", \"city\"] });\n```",
  "\n#### `quantiles`\n\nAssigns quantiles to rows in a new column based on specified column values.\n\n##### Signature\n\n```typescript\nasync quantiles(values: string, nbQuantiles: number, newColumn: string, options?: { categories?: string | string[] }): Promise<void>;\n```\n\n##### Parameters\n\n- **`values`**: - The column containing values from which quantiles will be\n  assigned.\n- **`nbQuantiles`**: - The number of quantiles to divide the data into (e.g.,\n  `4` for quartiles, `10` for deciles).\n- **`newColumn`**: - The name of the new column where the assigned quantiles\n  will be stored.\n- **`options`**: - An optional object with configuration options:\n- **`options.categories`**: - The column name or an array of column names that\n  define categories for computing quantiles. Quantiles will be assigned\n  independently within each category.\n\n##### Returns\n\nA promise that resolves when the quantiles have been assigned.\n\n##### Examples\n\n```ts\n// Assigns a quantile from 1 to 10 for each row in a new 'quantiles' column, based on 'column1' values.\nawait table.quantiles(\"column1\", 10, \"quantiles\");\n```\n\n```ts\n// Assigns quantiles within 'column2' categories, based on 'column1' values.\nawait table.quantiles(\"column1\", 10, \"quantiles\", { categories: \"column2\" });\n```\n\n```ts\n// Assigns quartiles (4 quantiles) to 'sales' data, storing results in 'salesQuartile'\nawait table.quantiles(\"sales\", 4, \"salesQuartile\");\n```",
  "\n#### `bins`\n\nAssigns bins for specified column values based on an interval size.\n\n##### Signature\n\n```typescript\nasync bins(values: string, interval: number, newColumn: string, options?: { startValue?: number }): Promise<void>;\n```\n\n##### Parameters\n\n- **`values`**: - The column containing values from which bins will be computed.\n- **`interval`**: - The interval size for binning the values.\n- **`newColumn`**: - The name of the new column where the bins will be stored.\n- **`options`**: - An optional object with configuration options:\n- **`options.startValue`**: - The starting value for binning. Defaults to the\n  minimum value in the specified column.\n\n##### Returns\n\nA promise that resolves when the bins have been assigned.\n\n##### Examples\n\n```ts\n// Assigns a bin for each row in a new 'bins' column based on 'column1' values, with an interval of 10.\n// If the minimum value in 'column1' is 5, the bins will follow this pattern: \"[5-14]\", \"[15-24]\", etc.\nawait table.bins(\"column1\", 10, \"bins\");\n```\n\n```ts\n// Assigns bins starting at a specific value (0) with an interval of 10.\n// The bins will follow this pattern: \"[0-9]\", \"[10-19]\", \"[20-29]\", etc.\nawait table.bins(\"column1\", 10, \"bins\", { startValue: 0 });\n```",
  "\n#### `proportionsHorizontal`\n\nComputes proportions horizontally across specified columns for each row.\n\nFor example, given a table showing counts of men, women, and non-binary\nindividuals per year:\n\n| Year | Men | Women | NonBinary |\n| :--- | :-- | :---- | :-------- |\n| 2021 | 564 | 685   | 145       |\n| 2022 | 354 | 278   | 56        |\n| 2023 | 856 | 321   | 221       |\n\nThis method computes the proportion of men, women, and non-binary individuals on\neach row, adding new columns for these proportions.\n\n##### Signature\n\n```typescript\nasync proportionsHorizontal(columns: string[], options?: { suffix?: string; decimals?: number }): Promise<void>;\n```\n\n##### Parameters\n\n- **`columns`**: - An array of column names for which proportions will be\n  computed on each row.\n- **`options`**: - An optional object with configuration options:\n- **`options.suffix`**: - A string suffix to append to the names of the new\n  columns storing the computed proportions. Defaults to `\"Perc\"`.\n- **`options.decimals`**: - The number of decimal places to round the computed\n  proportions. Defaults to `undefined` (no rounding).\n\n##### Returns\n\nA promise that resolves when the horizontal proportions have been computed.\n\n##### Examples\n\n```ts\n// Compute horizontal proportions for 'Men', 'Women', and 'NonBinary' columns, rounded to 2 decimal places\nawait table.proportionsHorizontal([\"Men\", \"Women\", \"NonBinary\"], {\n  decimals: 2,\n});\n```\n\nThe table will then look like this:\n\n| Year | Men | Women | NonBinary | MenPerc | WomenPerc | NonBinaryPerc |\n| :--- | :-- | :---- | :-------- | :------ | :-------- | :------------ |\n| 2021 | 564 | 685   | 145       | 0.4     | 0.49      | 0.10          |\n| 2022 | 354 | 278   | 56        | 0.51    | 0.4       | 0.08          |\n| 2023 | 856 | 321   | 221       | 0.61    | 0.23      | 0.16          |\n\nBy default, the new columns will be named with a suffix of `\"Perc\"`. You can\ncustomize this suffix using the `suffix` option.\n\n```ts\n// Compute horizontal proportions with a custom suffix \"Prop\"\nawait table.proportionsHorizontal([\"Men\", \"Women\", \"NonBinary\"], {\n  suffix: \"Prop\",\n  decimals: 2,\n});\n```\n\nThe table will then look like this:\n\n| Year | Men | Women | NonBinary | MenProp | WomenProp | NonBinaryProp |\n| :--- | :-- | :---- | :-------- | :------ | :-------- | :------------ |\n| 2021 | 564 | 685   | 145       | 0.4     | 0.49      | 0.10          |\n| 2022 | 354 | 278   | 56        | 0.51    | 0.4       | 0.08          |\n| 2023 | 856 | 321   | 221       | 0.61    | 0.23      | 0.16          |",
  "\n#### `proportionsVertical`\n\nComputes proportions vertically over a column's values, relative to the sum of\nall values in that column (or within specified categories).\n\n##### Signature\n\n```typescript\nasync proportionsVertical(column: string, newColumn: string, options?: { categories?: string | string[]; decimals?: number }): Promise<void>;\n```\n\n##### Parameters\n\n- **`column`**: - The column containing values for which proportions will be\n  computed. The proportions are calculated based on the sum of values in the\n  specified column.\n- **`newColumn`**: - The name of the new column where the proportions will be\n  stored.\n- **`options`**: - An optional object with configuration options:\n- **`options.categories`**: - The column name or an array of column names that\n  define categories for computing proportions. Proportions will be calculated\n  independently within each category.\n- **`options.decimals`**: - The number of decimal places to round the computed\n  proportions. Defaults to `undefined` (no rounding).\n\n##### Returns\n\nA promise that resolves when the vertical proportions have been computed.\n\n##### Examples\n\n```ts\n// Add a new column 'perc' with each 'column1' value divided by the sum of all 'column1' values\nawait table.proportionsVertical(\"column1\", \"perc\");\n```\n\n```ts\n// Compute proportions for 'column1' within 'column2' categories, rounded to two decimal places\nawait table.proportionsVertical(\"column1\", \"perc\", {\n  categories: \"column2\",\n  decimals: 2,\n});\n```\n\n```ts\n// Compute proportions for 'sales' within 'region' and 'product_type' categories\nawait table.proportionsVertical(\"sales\", \"sales_proportion\", {\n  categories: [\"region\", \"product_type\"],\n});\n```",
  "\n#### `summarize`\n\nCreates a summary table based on specified values, categories, and summary\noperations. This method allows you to aggregate data, calculate statistics\n(e.g., count, mean, sum), and group results by categorical columns.\n\n##### Signature\n\n```typescript\nasync summarize(options?: { values?: string | string[]; categories?: string | string[]; summaries?: (\"count\" | \"countUnique\" | \"countNull\" | \"min\" | \"max\" | \"mean\" | \"median\" | \"sum\" | \"skew\" | \"stdDev\" | \"var\") | (\"count\" | \"countUnique\" | \"countNull\" | \"min\" | \"max\" | \"mean\" | \"median\" | \"sum\" | \"skew\" | \"stdDev\" | \"var\")[] | Record<string, \"count\" | \"countUnique\" | \"countNull\" | \"min\" | \"max\" | \"mean\" | \"median\" | \"sum\" | \"skew\" | \"stdDev\" | \"var\">; decimals?: number; outputTable?: string | boolean; toMs?: boolean; noColumnValue?: boolean }): Promise<SimpleTable>;\n```\n\n##### Parameters\n\n- **`options`**: - An object with configuration options for summarization:\n- **`options.values`**: - The column name or an array of column names whose\n  values will be summarized. If omitted, all columns will be summarized.\n- **`options.categories`**: - The column name or an array of column names that\n  define categories for the summarization. Results will be grouped by these\n  categories.\n- **`options.summaries`**: - The summary operations to be performed. Can be a\n  single operation (e.g., `\"mean\"`), an array of operations (e.g.,\n  `[\"min\", \"max\"]`), or an object mapping new column names to operations (e.g.,\n  `{ avgSalary: \"mean\" }`). Supported operations include: `\"count\"`,\n  `\"countUnique\"`, `\"countNull\"`, `\"min\"`, `\"max\"`, `\"mean\"`, `\"median\"`,\n  `\"sum\"`, `\"skew\"`, `\"stdDev\"`, `\"var\"`.\n- **`options.decimals`**: - The number of decimal places to round the summarized\n  values. Defaults to `undefined` (no rounding).\n- **`options.outputTable`**: - If `true`, the results will be stored in a new\n  table with a generated name. If a string, it will be used as the name for the\n  new table. If `false` or omitted, the current table will be overwritten.\n  Defaults to `false`.\n- **`options.toMs`**: - If `true`, timestamps, dates, and times will be\n  converted to milliseconds before summarizing. This is useful when summarizing\n  mixed data types (numbers and dates) as values must be of the same type for\n  aggregation.\n- **`options.noColumnValue`**: - If `true`, the default `value` column will be\n  removed. This option only works when summarizing a single column without\n  categories. Defaults to `false`.\n\n##### Returns\n\nA promise that resolves to the SimpleTable instance containing the summarized\ndata (either the modified current table or a new table).\n\n##### Examples\n\n```ts\n// Summarize all columns with all available summary operations, overwriting the current table\nconst columns = await table.getColumns();\nawait table.summarize({ values: columns });\n```\n\n```ts\n// Summarize all columns and store the results in a new table with a generated name\nconst columns = await table.getColumns();\nconst summaryTable = await table.summarize({\n  values: columns,\n  outputTable: true,\n});\n```\n\n```ts\n// Summarize all columns and store the results in a new table named 'mySummary'\nconst columns = await table.getColumns();\nconst mySummaryTable = await table.summarize({\n  values: columns,\n  outputTable: \"mySummary\",\n});\n```\n\n```ts\n// Summarize a single column ('sales') with all available summary operations\nawait table.summarize({ values: \"sales\" });\n```\n\n```ts\n// Summarize multiple columns ('sales' and 'profit') with all available summary operations\nawait table.summarize({ values: [\"sales\", \"profit\"] });\n```\n\n```ts\n// Summarize 'sales' by 'region' (single category)\nawait table.summarize({ values: \"sales\", categories: \"region\" });\n```\n\n```ts\n// Summarize 'sales' by 'region' and 'product_type' (multiple categories)\nawait table.summarize({\n  values: \"sales\",\n  categories: [\"region\", \"product_type\"],\n});\n```\n\n```ts\n// Summarize 'sales' by 'region' with a specific summary operation (mean)\nawait table.summarize({\n  values: \"sales\",\n  categories: \"region\",\n  summaries: \"mean\",\n});\n```\n\n```ts\n// Summarize 'sales' by 'region' with specific summary operations (mean and sum)\nawait table.summarize({\n  values: \"sales\",\n  categories: \"region\",\n  summaries: [\"mean\", \"sum\"],\n});\n```\n\n```ts\n// Summarize 'sales' by 'region' with custom named summary operations\nawait table.summarize({\n  values: \"sales\",\n  categories: \"region\",\n  summaries: { averageSales: \"mean\", totalSales: \"sum\" },\n});\n```\n\n```ts\n// Summarize 'price' and 'cost', rounding aggregated values to 2 decimal places\nawait table.summarize({ values: [\"price\", \"cost\"], decimals: 2 });\n```\n\n```ts\n// Summarize 'timestamp_column' by converting to milliseconds first\nawait table.summarize({\n  values: \"timestamp_column\",\n  toMs: true,\n  summaries: \"mean\",\n});\n```\n\n```ts\n// Summarize a single column 'value_column' without the default 'value' column in the output\nawait table.summarize({ values: \"value_column\", noColumnValue: true });\n```",
  "\n#### `accumulate`\n\nComputes the cumulative sum of values in a column. For this method to work\nproperly, ensure your data is sorted first.\n\n##### Signature\n\n```typescript\nasync accumulate(column: string, newColumn: string, options?: { categories?: string | string[] }): Promise<void>;\n```\n\n##### Parameters\n\n- **`column`**: - The name of the column storing the values to be accumulated.\n- **`newColumn`**: - The name of the new column in which the computed cumulative\n  values will be stored.\n- **`options`**: - An optional object with configuration options:\n- **`options.categories`**: - The column name or an array of column names that\n  define categories for the accumulation. Accumulation will be performed\n  independently within each category.\n\n##### Returns\n\nA promise that resolves when the cumulative sum has been computed.\n\n##### Examples\n\n```ts\n// Compute the cumulative sum of 'sales' in a new 'cumulativeSales' column\n// Ensure the table is sorted by a relevant column (e.g., date) before calling this method.\nawait table.accumulate(\"sales\", \"cumulativeSales\");\n```\n\n```ts\n// Compute the cumulative sum of 'orders' within 'customer_id' categories\n// Ensure the table is sorted by 'customer_id' and then by a relevant order column (e.g., order_date).\nawait table.accumulate(\"orders\", \"cumulativeOrders\", {\n  categories: \"customer_id\",\n});\n```\n\n```ts\n// Compute the cumulative sum of 'revenue' within 'region' and 'product_category' categories\nawait table.accumulate(\"revenue\", \"cumulativeRevenue\", {\n  categories: [\"region\", \"product_category\"],\n});\n```",
  "\n#### `rolling`\n\nComputes rolling aggregations (e.g., rolling average, min, max) over a specified\ncolumn. For rows without enough preceding or following rows to form a complete\nwindow, `NULL` will be returned. For this method to work properly, ensure your\ndata is sorted by the relevant column(s) first.\n\n##### Signature\n\n```typescript\nasync rolling(column: string, newColumn: string, summary: \"min\" | \"max\" | \"mean\" | \"median\" | \"sum\", preceding: number, following: number, options?: { categories?: string | string[]; decimals?: number }): Promise<void>;\n```\n\n##### Parameters\n\n- **`column`**: - The name of the column storing the values to be aggregated.\n- **`newColumn`**: - The name of the new column in which the computed rolling\n  values will be stored.\n- **`summary`**: - The aggregation function to apply: `\"min\"`, `\"max\"`,\n  `\"mean\"`, `\"median\"`, or `\"sum\"`.\n- **`preceding`**: - The number of preceding rows to include in the rolling\n  window.\n- **`following`**: - The number of following rows to include in the rolling\n  window.\n- **`options`**: - An optional object with configuration options:\n- **`options.categories`**: - The column name or an array of column names that\n  define categories for the aggregation. Rolling aggregations will be computed\n  independently within each category.\n- **`options.decimals`**: - The number of decimal places to round the aggregated\n  values. Defaults to `undefined` (no rounding).\n\n##### Returns\n\nA promise that resolves when the rolling aggregation is complete.\n\n##### Examples\n\n```ts\n// Compute a 7-day rolling average of 'sales' with 3 preceding and 3 following rows\n// (total window size of 7: 3 preceding + current + 3 following)\nawait table.rolling(\"sales\", \"rollingAvgSales\", \"mean\", 3, 3);\n```\n\n```ts\n// Compute a rolling sum of 'transactions' within 'customer_id' categories\nawait table.rolling(\"transactions\", \"rollingSumTransactions\", \"sum\", 5, 0, {\n  categories: \"customer_id\",\n});\n```\n\n```ts\n// Compute a rolling maximum of 'temperature' rounded to 1 decimal place\nawait table.rolling(\"temperature\", \"rollingMaxTemp\", \"max\", 2, 2, {\n  decimals: 1,\n});\n```",
  "\n#### `correlations`\n\nCalculates correlations between columns. If no `x` and `y` columns are\nspecified, the method computes the correlations for all numeric column\ncombinations. Note that correlation is symmetrical: the correlation of `x` with\n`y` is the same as `y` with `x`.\n\n##### Signature\n\n```typescript\nasync correlations(options?: { x?: string; y?: string; categories?: string | string[]; decimals?: number; outputTable?: string | boolean }): Promise<SimpleTable>;\n```\n\n##### Parameters\n\n- **`options`**: - An optional object with configuration options:\n- **`options.x`**: - The name of the column for the x-values. If omitted,\n  correlations will be computed for all numeric columns.\n- **`options.y`**: - The name of the column for the y-values. If omitted,\n  correlations will be computed for all numeric columns.\n- **`options.categories`**: - The column name or an array of column names that\n  define categories. Correlation calculations will be performed independently\n  for each category.\n- **`options.decimals`**: - The number of decimal places to round the\n  correlation values. Defaults to `undefined` (no rounding).\n- **`options.outputTable`**: - If `true`, the results will be stored in a new\n  table with a generated name. If a string, it will be used as the name for the\n  new table. If `false` or omitted, the current table will be overwritten.\n  Defaults to `false`.\n\n##### Returns\n\nA promise that resolves to the SimpleTable instance containing the correlation\nresults (either the modified current table or a new table).\n\n##### Examples\n\n```ts\n// Compute correlations between all numeric columns, overwriting the current table\nawait table.correlations();\n```\n\n```ts\n// Compute correlations between 'column1' and all other numeric columns\nawait table.correlations({ x: \"column1\" });\n```\n\n```ts\n// Compute the correlation between 'column1' and 'column2'\nawait table.correlations({ x: \"column1\", y: \"column2\" });\n```\n\n```ts\n// Compute correlations within 'categoryColumn' and store results in a new table\nconst correlationTable = await table.correlations({\n  categories: \"categoryColumn\",\n  outputTable: true,\n});\n```\n\n```ts\n// Compute correlations, rounded to 2 decimal places\nawait table.correlations({ decimals: 2 });\n```",
  "\n#### `linearRegressions`\n\nPerforms linear regression analysis. The results include the slope, the\ny-intercept, and the R-squared value. If no `x` and `y` columns are specified,\nthe method computes linear regression analysis for all numeric column\npermutations. Note that linear regression analysis is asymmetrical: the linear\nregression of `x` over `y` is not the same as `y` over `x`.\n\n##### Signature\n\n```typescript\nasync linearRegressions(options?: { x?: string; y?: string; categories?: string | string[]; decimals?: number; outputTable?: string | boolean }): Promise<SimpleTable>;\n```\n\n##### Parameters\n\n- **`options`**: - An optional object with configuration options:\n- **`options.x`**: - The name of the column for the independent variable\n  (x-values). If omitted, linear regressions will be computed for all numeric\n  columns as x.\n- **`options.y`**: - The name of the column for the dependent variable\n  (y-values). If omitted, linear regressions will be computed for all numeric\n  columns as y.\n- **`options.categories`**: - The column name or an array of column names that\n  define categories. Linear regression analysis will be performed independently\n  for each category.\n- **`options.decimals`**: - The number of decimal places to round the regression\n  values (slope, intercept, r-squared). Defaults to `undefined` (no rounding).\n- **`options.outputTable`**: - If `true`, the results will be stored in a new\n  table with a generated name. If a string, it will be used as the name for the\n  new table. If `false` or omitted, the current table will be overwritten.\n  Defaults to `false`.\n\n##### Returns\n\nA promise that resolves to the SimpleTable instance containing the linear\nregression results (either the modified current table or a new table).\n\n##### Examples\n\n```ts\n// Compute all linear regressions between all numeric columns, overwriting the current table\nawait table.linearRegressions();\n```\n\n```ts\n// Compute linear regressions with 'column1' as the independent variable and all other numeric columns as dependent variables\nawait table.linearRegressions({ x: \"column1\" });\n```\n\n```ts\n// Compute the linear regression of 'sales' (y) over 'advertising' (x)\nawait table.linearRegressions({ x: \"advertising\", y: \"sales\" });\n```\n\n```ts\n// Compute linear regressions within 'region' categories and store results in a new table\nconst regressionTable = await table.linearRegressions({\n  categories: \"region\",\n  outputTable: true,\n});\n```\n\n```ts\n// Compute linear regressions, rounded to 3 decimal places\nawait table.linearRegressions({ decimals: 3 });\n```",
  "\n#### `outliersIQR`\n\nIdentifies outliers in a specified column using the Interquartile Range (IQR)\nmethod.\n\n##### Signature\n\n```typescript\nasync outliersIQR(column: string, newColumn: string, options?: { categories?: string | string[] }): Promise<void>;\n```\n\n##### Parameters\n\n- **`column`**: - The name of the column in which outliers will be identified.\n- **`newColumn`**: - The name of the new column where the boolean results\n  (`TRUE` for outlier, `FALSE` otherwise) will be stored.\n- **`options`**: - An optional object with configuration options:\n- **`options.categories`**: - The column name or an array of column names that\n  define categories. Outlier detection will be performed independently within\n  each category.\n\n##### Returns\n\nA promise that resolves when the outliers have been identified.\n\n##### Examples\n\n```ts\n// Look for outliers in the 'age' column and store results in a new 'isOutlier' column\nawait table.outliersIQR(\"age\", \"isOutlier\");\n```\n\n```ts\n// Look for outliers in 'salary' within 'gender' categories\nawait table.outliersIQR(\"salary\", \"salaryOutlier\", { categories: \"gender\" });\n```",
  "\n#### `zScore`\n\nComputes the Z-score for values in a specified column.\n\n##### Signature\n\n```typescript\nasync zScore(column: string, newColumn: string, options?: { categories?: string | string[]; decimals?: number }): Promise<void>;\n```\n\n##### Parameters\n\n- **`column`**: - The name of the column for which Z-scores will be calculated.\n- **`newColumn`**: - The name of the new column where the computed Z-scores will\n  be stored.\n- **`options`**: - An optional object with configuration options:\n- **`options.categories`**: - The column name or an array of column names that\n  define categories. Z-scores will be calculated independently within each\n  category.\n- **`options.decimals`**: - The number of decimal places to round the Z-score\n  values. Defaults to `undefined` (no rounding).\n\n##### Returns\n\nA promise that resolves when the Z-scores have been computed.\n\n##### Examples\n\n```ts\n// Calculate the Z-score for 'age' values and store results in a new 'ageZScore' column\nawait table.zScore(\"age\", \"ageZScore\");\n```\n\n```ts\n// Calculate Z-scores for 'salary' within 'department' categories\nawait table.zScore(\"salary\", \"salaryZScore\", { categories: \"department\" });\n```\n\n```ts\n// Calculate Z-scores for 'score', rounded to 2 decimal places\nawait table.zScore(\"score\", \"scoreZScore\", { decimals: 2 });\n```",
  "\n#### `normalize`\n\nNormalizes the values in a column using min-max normalization.\n\n##### Signature\n\n```typescript\nasync normalize(column: string, newColumn: string, options?: { categories?: string | string[]; decimals?: number }): Promise<void>;\n```\n\n##### Parameters\n\n- **`column`**: - The name of the column in which values will be normalized.\n- **`newColumn`**: - The name of the new column where normalized values will be\n  stored.\n- **`options`**: - An optional object with configuration options:\n- **`options.categories`**: - The column name or an array of column names that\n  define categories for the normalization. Normalization will be performed\n  independently within each category.\n- **`options.decimals`**: - The number of decimal places to round the normalized\n  values. Defaults to `undefined` (no rounding).\n\n##### Returns\n\nA promise that resolves when the values have been normalized.\n\n##### Examples\n\n```ts\n// Normalize the values in 'column1' and store them in a new 'normalizedColumn1' column\nawait table.normalize(\"column1\", \"normalizedColumn1\");\n```\n\n```ts\n// Normalize 'value' within 'group' categories\nawait table.normalize(\"value\", \"normalizedValue\", { categories: \"group\" });\n```\n\n```ts\n// Normalize 'data' values, rounded to 2 decimal places\nawait table.normalize(\"data\", \"normalizedData\", { decimals: 2 });\n```",
  "\n#### `updateWithJS`\n\nUpdates data in the table using a JavaScript function. The function receives the\nexisting rows as an array of objects and must return the modified rows as an\narray of objects. This method offers high flexibility for data manipulation but\ncan be slow for large tables as it involves transferring data between DuckDB and\nJavaScript. This method does not work with tables containing geometries.\n\n##### Signature\n\n```typescript\nasync updateWithJS(dataModifier: ((rows: Record<string, number | string | Date | boolean | null>[]) => any) | ((rows: Record<string, number | string | Date | boolean | null>[]) => any)): Promise<void>;\n```\n\n##### Parameters\n\n- **`dataModifier`**: - A synchronous or asynchronous function that takes the\n  existing rows (as an array of objects) and returns the modified rows (as an\n  array of objects).\n\n##### Returns\n\nA promise that resolves when the data has been updated.\n\n##### Examples\n\n```ts\n// Add 1 to values in 'column1'. If values are not numbers, they are replaced by null.\nawait table.updateWithJS((rows) => {\n  const modifiedRows = rows.map((d) => ({\n    ...d,\n    column1: typeof d.column1 === \"number\" ? d.column1 + 1 : null,\n  }));\n  return modifiedRows;\n});\n```\n\n```ts\n// Convert a date string to a Date object in 'dateColumn'\nawait table.updateWithJS((rows) => {\n  const modifiedRows = rows.map((d) => ({\n    ...d,\n    dateColumn: typeof d.dateColumn === \"string\"\n      ? new Date(d.dateColumn)\n      : d.dateColumn,\n  }));\n  return modifiedRows;\n});\n```",
  "\n#### `getSchema`\n\nReturns the schema of the table, including column names and their data types.\n\n##### Signature\n\n```typescript\nasync getSchema(): Promise<Record<string, string | null>[]>;\n```\n\n##### Returns\n\nA promise that resolves to an array of objects, where each object represents a\ncolumn with its name and data type.\n\n##### Examples\n\n```ts\n// Get the schema of the table\nconst schema = await table.getSchema();\nconsole.table(schema); // Log the schema in a readable table format\n```",
  "\n#### `getDescription`\n\nReturns descriptive statistical information about the columns, including details\nlike data types, number of null values, and distinct values.\n\n##### Signature\n\n```typescript\nasync getDescription(): Promise<Record<string, unknown>[]>;\n```\n\n##### Returns\n\nA promise that resolves to an array of objects, each representing descriptive\nstatistics for a column.\n\n##### Examples\n\n```ts\n// Get and log descriptive information about the table's columns\nconst description = await table.getDescription();\nconsole.table(description);\n```",
  "\n#### `getColumns`\n\nReturns a list of all column names in the table.\n\n##### Signature\n\n```typescript\nasync getColumns(): Promise<string[]>;\n```\n\n##### Returns\n\nA promise that resolves to an array of strings, where each string is a column\nname.\n\n##### Examples\n\n```ts\n// Get all column names from the table\nconst columns = await table.getColumns();\nconsole.log(columns); // e.g., [\"id\", \"name\", \"age\"]\n```",
  "\n#### `getNbColumns`\n\nReturns the number of columns in the table.\n\n##### Signature\n\n```typescript\nasync getNbColumns(): Promise<number>;\n```\n\n##### Returns\n\nA promise that resolves to a number representing the total count of columns.\n\n##### Examples\n\n```ts\n// Get the number of columns in the table\nconst nbColumns = await table.getNbColumns();\nconsole.log(nbColumns); // e.g., 3\n```",
  "\n#### `getNbRows`\n\nReturns the number of rows in the table.\n\n##### Signature\n\n```typescript\nasync getNbRows(): Promise<number>;\n```\n\n##### Returns\n\nA promise that resolves to a number representing the total count of rows.\n\n##### Examples\n\n```ts\n// Get the number of rows in the table\nconst nbRows = await table.getNbRows();\nconsole.log(nbRows); // e.g., 100\n```",
  "\n#### `getNbValues`\n\nReturns the total number of values in the table (number of columns multiplied by\nthe number of rows).\n\n##### Signature\n\n```typescript\nasync getNbValues(): Promise<number>;\n```\n\n##### Returns\n\nA promise that resolves to a number representing the total count of values.\n\n##### Examples\n\n```ts\n// Get the total number of values in the table\nconst nbValues = await table.getNbValues();\nconsole.log(nbValues); // e.g., 300 (if 3 columns and 100 rows)\n```",
  "\n#### `getTypes`\n\nReturns the data types of all columns in the table.\n\n##### Signature\n\n```typescript\nasync getTypes(): Promise<Record<string, string>>;\n```\n\n##### Returns\n\nA promise that resolves to an object where keys are column names and values are\ntheir corresponding data types (e.g., `{ \"id\": \"BIGINT\", \"name\": \"VARCHAR\" }`).\n\n##### Examples\n\n```ts\n// Get the data types of all columns\nconst dataTypes = await table.getTypes();\nconsole.log(dataTypes);\n```",
  "\n#### `getValues`\n\nReturns all values from a specific column.\n\n##### Signature\n\n```typescript\nasync getValues(column: string): Promise<(string | number | boolean | Date | null)[]>;\n```\n\n##### Parameters\n\n- **`column`**: - The name of the column from which to retrieve values.\n\n##### Returns\n\nA promise that resolves to an array containing all values from the specified\ncolumn.\n\n##### Examples\n\n```ts\n// Get all values from the 'productName' column\nconst productNames = await table.getValues(\"productName\");\nconsole.log(productNames); // e.g., [\"Laptop\", \"Mouse\", \"Keyboard\"]\n```",
  "\n#### `getMin`\n\nReturns the minimum value from a specific column.\n\n##### Signature\n\n```typescript\nasync getMin(column: string): Promise<string | number | boolean | Date | null>;\n```\n\n##### Parameters\n\n- **`column`**: - The name of the column from which to retrieve the minimum\n  value.\n\n##### Returns\n\nA promise that resolves to the minimum value of the specified column.\n\n##### Examples\n\n```ts\n// Get the minimum value from the 'price' column\nconst minPrice = await table.getMin(\"price\");\nconsole.log(minPrice); // e.g., 10.50\n```",
  "\n#### `getMax`\n\nReturns the maximum value from a specific column.\n\n##### Signature\n\n```typescript\nasync getMax(column: string): Promise<string | number | boolean | Date | null>;\n```\n\n##### Parameters\n\n- **`column`**: - The name of the column from which to retrieve the maximum\n  value.\n\n##### Returns\n\nA promise that resolves to the maximum value of the specified column.\n\n##### Examples\n\n```ts\n// Get the maximum value from the 'price' column\nconst maxPrice = await table.getMax(\"price\");\nconsole.log(maxPrice); // e.g., 99.99\n```",
  "\n#### `getExtent`\n\nReturns the extent (minimum and maximum values) of a specific column as an\narray.\n\n##### Signature\n\n```typescript\nasync getExtent(column: string): Promise<any>;\n```\n\n##### Parameters\n\n- **`column`**: - The name of the column from which to retrieve the extent.\n\n##### Returns\n\nA promise that resolves to an array `[min, max]` containing the minimum and\nmaximum values of the specified column.\n\n##### Examples\n\n```ts\n// Get the extent of the 'temperature' column\nconst tempExtent = await table.getExtent(\"temperature\");\nconsole.log(tempExtent); // e.g., [15.2, 30.1]\n```",
  "\n#### `getMean`\n\nReturns the mean (average) value from a specific numeric column.\n\n##### Signature\n\n```typescript\nasync getMean(column: string, options?: { decimals?: number }): Promise<number>;\n```\n\n##### Parameters\n\n- **`column`**: - The name of the numeric column from which to retrieve the mean\n  value.\n- **`options`**: - An optional object with configuration options:\n- **`options.decimals`**: - The number of decimal places to round the result to.\n  Defaults to `undefined` (no rounding).\n\n##### Returns\n\nA promise that resolves to the mean value of the specified column.\n\n##### Examples\n\n```ts\n// Get the mean of the 'age' column\nconst meanAge = await table.getMean(\"age\");\nconsole.log(meanAge); // e.g., 35.75\n```\n\n```ts\n// Get the mean of the 'salary' column, rounded to 2 decimal places\nconst meanSalary = await table.getMean(\"salary\", { decimals: 2 });\nconsole.log(meanSalary); // e.g., 55000.23\n```",
  "\n#### `getMedian`\n\nReturns the median value from a specific numeric column.\n\n##### Signature\n\n```typescript\nasync getMedian(column: string, options?: { decimals?: number }): Promise<number>;\n```\n\n##### Parameters\n\n- **`column`**: - The name of the numeric column from which to retrieve the\n  median value.\n- **`options`**: - An optional object with configuration options:\n- **`options.decimals`**: - The number of decimal places to round the result to.\n  Defaults to `undefined` (no rounding).\n\n##### Returns\n\nA promise that resolves to the median value of the specified column.\n\n##### Examples\n\n```ts\n// Get the median of the 'age' column\nconst medianAge = await table.getMedian(\"age\");\nconsole.log(medianAge); // e.g., 30\n```\n\n```ts\n// Get the median of the 'salary' column, rounded to 2 decimal places\nconst medianSalary = await table.getMedian(\"salary\", { decimals: 2 });\nconsole.log(medianSalary); // e.g., 50000.00\n```",
  "\n#### `getSum`\n\nReturns the sum of values from a specific numeric column.\n\n##### Signature\n\n```typescript\nasync getSum(column: string): Promise<number>;\n```\n\n##### Parameters\n\n- **`column`**: - The name of the numeric column from which to retrieve the sum.\n\n##### Returns\n\nA promise that resolves to the sum of values in the specified column.\n\n##### Examples\n\n```ts\n// Get the sum of the 'quantity' column\nconst totalQuantity = await table.getSum(\"quantity\");\nconsole.log(totalQuantity); // e.g., 1250\n```",
  "\n#### `getSkew`\n\nReturns the skewness of values from a specific numeric column.\n\n##### Signature\n\n```typescript\nasync getSkew(column: string, options?: { decimals?: number }): Promise<number>;\n```\n\n##### Parameters\n\n- **`column`**: - The name of the numeric column from which to retrieve the\n  skewness.\n- **`options`**: - An optional object with configuration options:\n- **`options.decimals`**: - The number of decimal places to round the result to.\n  Defaults to `undefined` (no rounding).\n\n##### Returns\n\nA promise that resolves to the skewness value of the specified column.\n\n##### Examples\n\n```ts\n// Get the skewness of the 'data' column\nconst dataSkew = await table.getSkew(\"data\");\nconsole.log(dataSkew); // e.g., 0.5\n```\n\n```ts\n// Get the skewness of the 'values' column, rounded to 2 decimal places\nconst valuesSkew = await table.getSkew(\"values\", { decimals: 2 });\nconsole.log(valuesSkew); // e.g., -0.25\n```",
  "\n#### `getStdDev`\n\nReturns the standard deviation of values from a specific numeric column.\n\n##### Signature\n\n```typescript\nasync getStdDev(column: string, options?: { decimals?: number }): Promise<number>;\n```\n\n##### Parameters\n\n- **`column`**: - The name of the numeric column from which to retrieve the\n  standard deviation.\n- **`options`**: - An optional object with configuration options:\n- **`options.decimals`**: - The number of decimal places to round the result to.\n  Defaults to `undefined` (no rounding).\n\n##### Returns\n\nA promise that resolves to the standard deviation value of the specified column.\n\n##### Examples\n\n```ts\n// Get the standard deviation of the 'height' column\nconst heightStdDev = await table.getStdDev(\"height\");\nconsole.log(heightStdDev); // e.g., 5.2\n```\n\n```ts\n// Get the standard deviation of the 'score' column, rounded to 3 decimal places\nconst scoreStdDev = await table.getStdDev(\"score\", { decimals: 3 });\nconsole.log(scoreStdDev); // e.g., 12.345\n```",
  "\n#### `getVar`\n\nReturns the variance of values from a specific numeric column.\n\n##### Signature\n\n```typescript\nasync getVar(column: string, options?: { decimals?: number }): Promise<number>;\n```\n\n##### Parameters\n\n- **`column`**: - The name of the numeric column from which to retrieve the\n  variance.\n- **`options`**: - An optional object with configuration options:\n- **`options.decimals`**: - The number of decimal places to round the result to.\n  Defaults to `undefined` (no rounding).\n\n##### Returns\n\nA promise that resolves to the variance value of the specified column.\n\n##### Examples\n\n```ts\n// Get the variance of the 'data' column\nconst dataVariance = await table.getVar(\"data\");\nconsole.log(dataVariance); // e.g., 25.5\n```\n\n```ts\n// Get the variance of the 'values' column, rounded to 2 decimal places\nconst valuesVariance = await table.getVar(\"values\", { decimals: 2 });\nconsole.log(valuesVariance); // e.g., 10.23\n```",
  "\n#### `getQuantile`\n\nReturns the value of a specific quantile from the values in a given numeric\ncolumn.\n\n##### Signature\n\n```typescript\nasync getQuantile(column: string, quantile: number, options?: { decimals?: number }): Promise<number>;\n```\n\n##### Parameters\n\n- **`column`**: - The name of the numeric column from which to calculate the\n  quantile.\n- **`quantile`**: - The quantile to calculate, expressed as a number between 0\n  and 1 (e.g., `0.25` for the first quartile, `0.5` for the median, `0.75` for\n  the third quartile).\n- **`options`**: - An optional object with configuration options:\n- **`options.decimals`**: - The number of decimal places to round the result to.\n  Defaults to `undefined` (no rounding).\n\n##### Returns\n\nA promise that resolves to the quantile value of the specified column.\n\n##### Examples\n\n```ts\n// Get the first quartile (25th percentile) of 'column1'\nconst firstQuartile = await table.getQuantile(\"column1\", 0.25);\nconsole.log(firstQuartile); // e.g., 15.7\n```\n\n```ts\n// Get the 90th percentile of 'score' values, rounded to 2 decimal places\nconst ninetiethPercentile = await table.getQuantile(\"score\", 0.9, {\n  decimals: 2,\n});\nconsole.log(ninetiethPercentile); // e.g., 88.55\n```",
  "\n#### `getUniques`\n\nReturns unique values from a specific column. The values are returned in\nascending order.\n\n##### Signature\n\n```typescript\nasync getUniques(column: string): Promise<(string | number | boolean | Date | null)[]>;\n```\n\n##### Parameters\n\n- **`column`**: - The name of the column from which to retrieve unique values.\n\n##### Returns\n\nA promise that resolves to an array containing the unique values from the\nspecified column, sorted in ascending order.\n\n##### Examples\n\n```ts\n// Get unique values from the 'category' column\nconst uniqueCategories = await table.getUniques(\"category\");\nconsole.log(uniqueCategories); // e.g., [\"Books\", \"Clothing\", \"Electronics\"]\n```",
  "\n#### `getFirstRow`\n\nReturns the first row of the table, optionally filtered by SQL conditions. You\ncan also use JavaScript syntax for conditions (e.g., `&&`, `||`, `===`, `!==`).\n\n##### Signature\n\n```typescript\nasync getFirstRow(options?: { conditions?: string }): Promise<Record<string, string | number | boolean | Date | null>>;\n```\n\n##### Parameters\n\n- **`options`**: - An optional object with configuration options:\n- **`options.conditions`**: - The filtering conditions specified as a SQL\n  `WHERE` clause (e.g., `\"category = 'Book'\"`).\n\n##### Returns\n\nA promise that resolves to an object representing the first row, or `null` if no\nrows match the conditions.\n\n##### Examples\n\n```ts\n// Get the very first row of the table\nconst firstRow = await table.getFirstRow();\nconsole.log(firstRow);\n```\n\n```ts\n// Get the first row where the 'category' is 'Book'\nconst firstRowBooks = await table.getFirstRow({\n  conditions: `category === 'Book'`,\n}); // Using JS syntax\nconsole.log(firstRowBooks);\n```",
  "\n#### `getLastRow`\n\nReturns the last row of the table, optionally filtered by SQL conditions. You\ncan also use JavaScript syntax for conditions (e.g., `&&`, `||`, `===`, `!==`).\n\n##### Signature\n\n```typescript\nasync getLastRow(options?: { conditions?: string }): Promise<Record<string, string | number | boolean | Date | null>>;\n```\n\n##### Parameters\n\n- **`options`**: - An optional object with configuration options:\n- **`options.conditions`**: - The filtering conditions specified as a SQL\n  `WHERE` clause (e.g., `\"category = 'Book'\"`).\n\n##### Returns\n\nA promise that resolves to an object representing the last row, or `null` if no\nrows match the conditions.\n\n##### Examples\n\n```ts\n// Get the very last row of the table\nconst lastRow = await table.getLastRow();\nconsole.log(lastRow);\n```\n\n```ts\n// Get the last row where the 'category' is 'Book'\nconst lastRowBooks = await table.getLastRow({\n  conditions: `category === 'Book'`,\n}); // Using JS syntax\nconsole.log(lastRowBooks);\n```",
  "\n#### `getTop`\n\nReturns the top `n` rows of the table, optionally filtered by SQL conditions.\nYou can also use JavaScript syntax for conditions (e.g., `&&`, `||`, `===`,\n`!==`).\n\n##### Signature\n\n```typescript\nasync getTop(count: number, options?: { conditions?: string }): Promise<Record<string, string | number | boolean | Date | null>[]>;\n```\n\n##### Parameters\n\n- **`count`**: - The number of rows to return from the top of the table.\n- **`options`**: - An optional object with configuration options:\n- **`options.conditions`**: - The filtering conditions specified as a SQL\n  `WHERE` clause (e.g., `\"category = 'Books'\"`).\n\n##### Returns\n\nA promise that resolves to an array of objects representing the top `n` rows.\n\n##### Examples\n\n```ts\n// Get the first 10 rows of the table\nconst top10 = await table.getTop(10);\nconsole.log(top10);\n```\n\n```ts\n// Get the first 5 rows where the 'category' is 'Books'\nconst top5Books = await table.getTop(5, { conditions: `category === 'Books'` }); // Using JS syntax\nconsole.log(top5Books);\n```",
  "\n#### `getBottom`\n\nReturns the bottom `n` rows of the table, optionally filtered by SQL conditions.\nBy default, the last row will be returned first. To preserve the original order,\nuse the `originalOrder` option. You can also use JavaScript syntax for\nconditions (e.g., `&&`, `||`, `===`, `!==`).\n\n##### Signature\n\n```typescript\nasync getBottom(count: number, options?: { originalOrder?: boolean; conditions?: string }): Promise<Record<string, string | number | boolean | Date | null>[]>;\n```\n\n##### Parameters\n\n- **`count`**: - The number of rows to return from the bottom of the table.\n- **`options`**: - An optional object with configuration options:\n- **`options.originalOrder`**: - A boolean indicating whether the rows should be\n  returned in their original order (`true`) or in reverse order (last row first,\n  `false`). Defaults to `false`.\n- **`options.conditions`**: - The filtering conditions specified as a SQL\n  `WHERE` clause (e.g., `\"category = 'Books'\"`).\n\n##### Returns\n\nA promise that resolves to an array of objects representing the bottom `n` rows.\n\n##### Examples\n\n```ts\n// Get the last 10 rows (last row first)\nconst bottom10 = await table.getBottom(10);\nconsole.log(bottom10);\n```\n\n```ts\n// Get the last 10 rows in their original order\nconst bottom10OriginalOrder = await table.getBottom(10, {\n  originalOrder: true,\n});\nconsole.log(bottom10OriginalOrder);\n```\n\n```ts\n// Get the last 5 rows where the 'category' is 'Books' (using JS syntax)\nconst bottom5Books = await table.getBottom(5, {\n  conditions: `category === 'Books'`,\n});\nconsole.log(bottom5Books);\n```",
  "\n#### `getRow`\n\nReturns a single row that matches the specified conditions. If no row matches or\nif more than one row matches, an error is thrown by default. You can also use\nJavaScript syntax for conditions (e.g., `AND`, `||`, `===`, `!==`).\n\n##### Signature\n\n```typescript\nasync getRow(conditions: string, options?: { noCheck?: boolean }): Promise<Record<string, string | number | boolean | Date | null> | undefined>;\n```\n\n##### Parameters\n\n- **`conditions`**: - The conditions to match, specified as a SQL `WHERE`\n  clause.\n- **`options`**: - Optional settings:\n- **`options.noCheck`**: - If `true`, no error will be thrown when no row or\n  more than one row match the condition. Defaults to `false`.\n\n##### Returns\n\nA promise that resolves to an object representing the matched row.\n\n##### Examples\n\n```ts\n// Get a row where 'name' is 'John'\nconst johnsRow = await table.getRow(`name = 'John'`);\nconsole.log(johnsRow);\n```\n\n```ts\n// Get a row where 'id' is 123 (using JS syntax)\nconst rowById = await table.getRow(`id === 123`);\nconsole.log(rowById);\n```\n\n```ts\n// Get a row without throwing an error if multiple matches or no match\nconst flexibleRow = await table.getRow(`status = 'pending'`, { noCheck: true });\nconsole.log(flexibleRow);\n```",
  "\n#### `getData`\n\nReturns the data from the table as an array of objects, optionally filtered by\nSQL conditions. You can also use JavaScript syntax for conditions (e.g., `&&`,\n`||`, `===`, `!==`).\n\n##### Signature\n\n```typescript\nasync getData(options?: { conditions?: string }): Promise<Record<string, string | number | boolean | Date | null>[]>;\n```\n\n##### Parameters\n\n- **`options`**: - An optional object with configuration options:\n- **`options.conditions`**: - The filtering conditions specified as a SQL\n  `WHERE` clause (e.g., `\"category = 'Book'\"`).\n\n##### Returns\n\nA promise that resolves to an array of objects, where each object represents a\nrow in the table.\n\n##### Examples\n\n```ts\n// Get all data from the table\nconst allData = await table.getData();\nconsole.log(allData);\n```\n\n```ts\n// Get data filtered by a condition (using JS syntax)\nconst booksData = await table.getData({ conditions: `category === 'Book'` });\nconsole.log(booksData);\n```",
  "\n#### `points`\n\nCreates point geometries from longitude and latitude columns. The geometries\nwill have `[latitude, longitude]` axis order.\n\n##### Signature\n\n```typescript\nasync points(columnLat: string, columnLon: string, newColumn: string): Promise<void>;\n```\n\n##### Parameters\n\n- **`columnLat`**: - The name of the column storing the latitude values.\n- **`columnLon`**: - The name of the column storing the longitude values.\n- **`newColumn`**: - The name of the new column where the point geometries will\n  be stored.\n\n##### Returns\n\nA promise that resolves when the point geometries have been created.\n\n##### Examples\n\n```ts\n// Create point geometries in a new 'geom' column using 'lat' and 'lon' columns\nawait table.points(\"lat\", \"lon\", \"geom\");\n```",
  "\n#### `isValidGeo`\n\nAdds a column with boolean values indicating the validity of geometries.\n\n##### Signature\n\n```typescript\nasync isValidGeo(newColumn: string, options?: { column?: string }): Promise<void>;\n```\n\n##### Parameters\n\n- **`newColumn`**: - The name of the new column where the boolean results\n  (`TRUE` for valid, `FALSE` for invalid) will be stored.\n- **`options`**: - An optional object with configuration options:\n- **`options.column`**: - The name of the column storing the geometries to be\n  checked. If omitted, the method will automatically attempt to find a geometry\n  column.\n\n##### Returns\n\nA promise that resolves when the validity check is complete.\n\n##### Examples\n\n```ts\n// Check if geometries are valid and store results in a new 'isValid' column\n// The method will automatically detect the geometry column.\nawait table.isValidGeo(\"isValid\");\n```\n\n```ts\n// Check validity of geometries in a specific column named 'myGeom'\nawait table.isValidGeo(\"isValidMyGeom\", { column: \"myGeom\" });\n```",
  "\n#### `nbVertices`\n\nAdds a column with the number of vertices (points) in each geometry.\n\n##### Signature\n\n```typescript\nasync nbVertices(newColumn: string, options?: { column?: string }): Promise<void>;\n```\n\n##### Parameters\n\n- **`newColumn`**: - The name of the new column where the vertex counts will be\n  stored.\n- **`options`**: - An optional object with configuration options:\n- **`options.column`**: - The name of the column storing the geometries. If\n  omitted, the method will automatically attempt to find a geometry column.\n\n##### Returns\n\nA promise that resolves when the vertex counts have been added.\n\n##### Examples\n\n```ts\n// Add a new column 'vertexCount' with the number of vertices for each geometry\n// The method will automatically detect the geometry column.\nawait table.nbVertices(\"vertexCount\");\n```\n\n```ts\n// Add vertex counts for geometries in a specific column named 'myGeom'\nawait table.nbVertices(\"myGeomVertices\", { column: \"myGeom\" });\n```",
  "\n#### `fixGeo`\n\nAttempts to make invalid geometries valid without removing any vertices.\n\n##### Signature\n\n```typescript\nasync fixGeo(column?: string): Promise<void>;\n```\n\n##### Parameters\n\n- **`column`**: - The name of the column storing the geometries to be fixed. If\n  omitted, the method will automatically attempt to find a geometry column.\n\n##### Returns\n\nA promise that resolves when the geometries have been processed.\n\n##### Examples\n\n```ts\n// Fix invalid geometries in the default geometry column\nawait table.fixGeo();\n```\n\n```ts\n// Fix invalid geometries in a specific column named 'myGeom'\nawait table.fixGeo(\"myGeom\");\n```",
  "\n#### `isClosedGeo`\n\nAdds a column with boolean values indicating whether geometries are closed\n(e.g., polygons) or open (e.g., linestrings).\n\n##### Signature\n\n```typescript\nasync isClosedGeo(newColumn: string, options?: { column?: string }): Promise<void>;\n```\n\n##### Parameters\n\n- **`newColumn`**: - The name of the new column where the boolean results\n  (`TRUE` for closed, `FALSE` for open) will be stored.\n- **`options`**: - An optional object with configuration options:\n- **`options.column`**: - The name of the column storing the geometries. If\n  omitted, the method will automatically attempt to find a geometry column.\n\n##### Returns\n\nA promise that resolves when the closed geometry check is complete.\n\n##### Examples\n\n```ts\n// Check if geometries are closed and store results in a new 'isClosed' column\nawait table.isClosedGeo(\"isClosed\");\n```\n\n```ts\n// Check closed status of geometries in a specific column named 'boundaryGeom'\nawait table.isClosedGeo(\"boundaryClosed\", { column: \"boundaryGeom\" });\n```",
  "\n#### `typeGeo`\n\nAdds a column with the geometry type (e.g., `\"POINT\"`, `\"LINESTRING\"`,\n`\"POLYGON\"`) for each geometry.\n\n##### Signature\n\n```typescript\nasync typeGeo(newColumn: string, options?: { column?: string }): Promise<void>;\n```\n\n##### Parameters\n\n- **`newColumn`**: - The name of the new column where the geometry types will be\n  stored.\n- **`options`**: - An optional object with configuration options:\n- **`options.column`**: - The name of the column storing the geometries. If\n  omitted, the method will automatically attempt to find a geometry column.\n\n##### Returns\n\nA promise that resolves when the geometry types have been added.\n\n##### Examples\n\n```ts\n// Add a new column 'geometryType' with the type of each geometry\nawait table.typeGeo(\"geometryType\");\n```\n\n```ts\n// Get the geometry type for geometries in a specific column named 'featureGeom'\nawait table.typeGeo(\"featureType\", { column: \"featureGeom\" });\n```",
  "\n#### `flipCoordinates`\n\nFlips the coordinate order of geometries in a specified column (e.g., from\n`[lon, lat]` to `[lat, lon]` or vice-versa). **Warning:** This method should be\nused with caution as it directly manipulates coordinate order and can affect the\naccuracy of geospatial operations if not used correctly. It also messes up with\nthe projections stored in `table.projections`.\n\n##### Signature\n\n```typescript\nasync flipCoordinates(column?: string): Promise<void>;\n```\n\n##### Parameters\n\n- **`column`**: - The name of the column storing the geometries. If omitted, the\n  method will automatically attempt to find a geometry column.\n\n##### Returns\n\nA promise that resolves when the coordinates have been flipped.\n\n##### Examples\n\n```ts\n// Flip coordinates in the default geometry column\nawait table.flipCoordinates();\n```\n\n```ts\n// Flip coordinates in a specific column named 'myGeom'\nawait table.flipCoordinates(\"myGeom\");\n```",
  "\n#### `reducePrecision`\n\nReduces the precision of geometries in a specified column to a given number of\ndecimal places.\n\n##### Signature\n\n```typescript\nasync reducePrecision(decimals: number, options?: { column?: string }): Promise<void>;\n```\n\n##### Parameters\n\n- **`decimals`**: - The number of decimal places to keep in the coordinates of\n  the geometries.\n- **`options`**: - An optional object with configuration options:\n- **`options.column`**: - The name of the column storing the geometries. If\n  omitted, the method will automatically attempt to find a geometry column.\n\n##### Returns\n\nA promise that resolves when the precision of the geometries has been reduced.\n\n##### Examples\n\n```ts\n// Reduce the precision of geometries in the default column to 3 decimal places\nawait table.reducePrecision(3);\n```\n\n```ts\n// Reduce the precision of geometries in a specific column named 'myGeom' to 2 decimal places\nawait table.reducePrecision(2, { column: \"myGeom\" });\n```",
  "\n#### `reproject`\n\nReprojects the geometries in a specified column to another Spatial Reference\nSystem (SRS). If reprojecting to WGS84 (`\"WGS84\"` or `\"EPSG:4326\"`), the\nresulting geometries will have `[latitude, longitude]` axis order.\n\n##### Signature\n\n```typescript\nasync reproject(to: string, options?: { from?: string; column?: string }): Promise<void>;\n```\n\n##### Parameters\n\n- **`to`**: - The target SRS (e.g., `\"EPSG:3347\"`, `\"WGS84\"`).\n- **`options`**: - An optional object with configuration options:\n- **`options.from`**: - The original projection of the geometries. If omitted,\n  the method attempts to automatically detect it. Provide this option if\n  auto-detection fails.\n- **`options.column`**: - The name of the column storing the geometries. If\n  omitted, the method will automatically attempt to find a geometry column.\n\n##### Returns\n\nA promise that resolves when the geometries have been reprojected.\n\n##### Examples\n\n```ts\n// Reproject geometries in the default column to EPSG:3347 (NAD83/Statistics Canada Lambert)\nawait table.reproject(\"EPSG:3347\");\n```\n\n```ts\n// Reproject geometries from EPSG:4326 to EPSG:3347, specifying the original projection\nawait table.reproject(\"EPSG:3347\", { from: \"EPSG:4326\" });\n```\n\n```ts\n// Reproject geometries in a specific column named 'myGeom' to EPSG:3347\nawait table.reproject(\"EPSG:3347\", { column: \"myGeom\", from: \"EPSG:4326\" });\n```",
  "\n#### `area`\n\nComputes the area of geometries in square meters (`\"m2\"`) or optionally square\nkilometers (`\"km2\"`). The input geometry is assumed to be in the EPSG:4326\ncoordinate system (WGS84), with `[latitude, longitude]` axis order.\n\n##### Signature\n\n```typescript\nasync area(newColumn: string, options?: { unit?: \"m2\" | \"km2\"; column?: string }): Promise<void>;\n```\n\n##### Parameters\n\n- **`newColumn`**: - The name of the new column where the computed areas will be\n  stored.\n- **`options`**: - An optional object with configuration options:\n- **`options.unit`**: - The unit for the computed area: `\"m2\"` (square meters)\n  or `\"km2\"` (square kilometers). Defaults to `\"m2\"`.\n- **`options.column`**: - The name of the column storing the geometries. If\n  omitted, the method will automatically attempt to find a geometry column.\n\n##### Returns\n\nA promise that resolves when the areas have been computed.\n\n##### Examples\n\n```ts\n// Compute the area of geometries in square meters and store in 'area_m2'\nawait table.area(\"area_m2\");\n```\n\n```ts\n// Compute the area of geometries in square kilometers and store in 'area_km2'\nawait table.area(\"area_km2\", { unit: \"km2\" });\n```\n\n```ts\n// Compute the area of geometries in a specific column named 'myGeom'\nawait table.area(\"myGeomArea\", { column: \"myGeom\" });\n```",
  "\n#### `length`\n\nComputes the length of line geometries in meters (`\"m\"`) or optionally\nkilometers (`\"km\"`). The input geometry is assumed to be in the EPSG:4326\ncoordinate system (WGS84), with `[latitude, longitude]` axis order.\n\n##### Signature\n\n```typescript\nasync length(newColumn: string, options?: { unit?: \"m\" | \"km\"; column?: string }): Promise<void>;\n```\n\n##### Parameters\n\n- **`newColumn`**: - The name of the new column where the computed lengths will\n  be stored.\n- **`options`**: - An optional object with configuration options:\n- **`options.unit`**: - The unit for the computed length: `\"m\"` (meters) or\n  `\"km\"` (kilometers). Defaults to `\"m\"`.\n- **`options.column`**: - The name of the column storing the geometries. If\n  omitted, the method will automatically attempt to find a geometry column.\n\n##### Returns\n\nA promise that resolves when the lengths have been computed.\n\n##### Examples\n\n```ts\n// Compute the length of line geometries in meters and store in 'length_m'\nawait table.length(\"length_m\");\n```\n\n```ts\n// Compute the length of line geometries in kilometers and store in 'length_km'\nawait table.length(\"length_km\", { unit: \"km\" });\n```\n\n```ts\n// Compute the length of geometries in a specific column named 'routeGeom'\nawait table.length(\"routeLength\", { column: \"routeGeom\" });\n```",
  "\n#### `perimeter`\n\nComputes the perimeter of polygon geometries in meters (`\"m\"`) or optionally\nkilometers (`\"km\"`). The input geometry is assumed to be in the EPSG:4326\ncoordinate system (WGS84), with `[latitude, longitude]` axis order.\n\n##### Signature\n\n```typescript\nasync perimeter(newColumn: string, options?: { unit?: \"m\" | \"km\"; column?: string }): Promise<void>;\n```\n\n##### Parameters\n\n- **`newColumn`**: - The name of the new column where the computed perimeters\n  will be stored.\n- **`options`**: - An optional object with configuration options:\n- **`options.unit`**: - The unit for the computed perimeter: `\"m\"` (meters) or\n  `\"km\"` (kilometers). Defaults to `\"m\"`.\n- **`options.column`**: - The name of the column storing the geometries. If\n  omitted, the method will automatically attempt to find a geometry column.\n\n##### Returns\n\nA promise that resolves when the perimeters have been computed.\n\n##### Examples\n\n```ts\n// Compute the perimeter of polygon geometries in meters and store in 'perimeter_m'\nawait table.perimeter(\"perimeter_m\");\n```\n\n```ts\n// Compute the perimeter of polygon geometries in kilometers and store in 'perimeter_km'\nawait table.perimeter(\"perimeter_km\", { unit: \"km\" });\n```\n\n```ts\n// Compute the perimeter of geometries in a specific column named 'landParcelGeom'\nawait table.perimeter(\"landParcelPerimeter\", { column: \"landParcelGeom\" });\n```",
  "\n#### `buffer`\n\nComputes a buffer (a polygon representing a specified distance around a\ngeometry) for geometries in a specified column. The distance is in the Spatial\nReference System (SRS) unit of the input geometries.\n\n##### Signature\n\n```typescript\nasync buffer(newColumn: string, distance: number, options?: { column?: string }): Promise<void>;\n```\n\n##### Parameters\n\n- **`newColumn`**: - The name of the new column where the buffered geometries\n  will be stored.\n- **`distance`**: - The distance for the buffer. This value is in the units of\n  the geometry's SRS.\n- **`options`**: - An optional object with configuration options:\n- **`options.column`**: - The name of the column storing the geometries. If\n  omitted, the method will automatically attempt to find a geometry column.\n\n##### Returns\n\nA promise that resolves when the buffers have been computed.\n\n##### Examples\n\n```ts\n// Create a buffer of 1 unit around geometries in the default column, storing results in 'bufferedGeom'\nawait table.buffer(\"bufferedGeom\", 1);\n```\n\n```ts\n// Create a buffer of 10 units around geometries in a specific column named 'pointsGeom'\nawait table.buffer(\"pointsBuffer\", 10, { column: \"pointsGeom\" });\n```",
  "\n#### `joinGeo`\n\nMerges the data of this table (considered the left table) with another table\n(the right table) based on a spatial relationship. Note that the order of rows\nin the returned data is not guaranteed to be the same as in the original tables.\nThis operation might create temporary files in a `.tmp` folder; consider adding\n`.tmp` to your `.gitignore`.\n\n##### Signature\n\n```typescript\nasync joinGeo(rightTable: SimpleTable, method: \"intersect\" | \"inside\" | \"within\", options?: { leftTableColumn?: string; rightTableColumn?: string; type?: \"inner\" | \"left\" | \"right\" | \"full\"; distance?: number; distanceMethod?: \"srs\" | \"haversine\" | \"spheroid\"; outputTable?: string | boolean }): Promise<SimpleTable>;\n```\n\n##### Parameters\n\n- **`rightTable`**: - The SimpleTable instance to be joined with this table.\n- **`method`**: - The spatial join method to use: `\"intersect\"` (geometries\n  overlap), `\"inside\"` (geometries of the left table are entirely within\n  geometries of the right table), or `\"within\"` (geometries of the left table\n  are within a specified distance of geometries in the right table).\n- **`options`**: - An optional object with configuration options:\n- **`options.leftTableColumn`**: - The name of the column storing geometries in\n  the left table (this table). If omitted, the method attempts to find one.\n- **`options.rightTableColumn`**: - The name of the column storing geometries in\n  the right table. If omitted, the method attempts to find one.\n- **`options.type`**: - The type of join operation to perform: `\"inner\"`,\n  `\"left\"` (default), `\"right\"`, or `\"full\"`. For some types (like `\"inside\"`),\n  the table order is important.\n- **`options.distance`**: - Required if `method` is `\"within\"`. The target\n  distance for the spatial join. The unit depends on `distanceMethod`.\n- **`options.distanceMethod`**: - The method for distance calculations: `\"srs\"`\n  (default, uses the SRS unit), `\"haversine\"` (uses meters, requires EPSG:4326\n  input), or `\"spheroid\"` (uses meters, requires EPSG:4326 input, most accurate\n  but slowest).\n- **`options.outputTable`**: - If `true`, the results will be stored in a new\n  table with a generated name. If a string, it will be used as the name for the\n  new table. If `false` or omitted, the current table will be overwritten.\n  Defaults to `false`.\n\n##### Returns\n\nA promise that resolves to the SimpleTable instance containing the spatially\njoined data (either the modified current table or a new table).\n\n##### Examples\n\n```ts\n// Merge data based on intersecting geometries, overwriting tableA\nawait tableA.joinGeo(tableB, \"intersect\");\n```\n\n```ts\n// Merge data where geometries in tableA are inside geometries in tableB\nawait tableA.joinGeo(tableB, \"inside\");\n```\n\n```ts\n// Merge data where geometries in tableA are within 10 units (SRS) of geometries in tableB\nawait tableA.joinGeo(tableB, \"within\", { distance: 10 });\n```\n\n```ts\n// Merge data where geometries in tableA are within 10 kilometers (Haversine) of geometries in tableB\n// Input geometries must be in EPSG:4326.\nawait tableA.joinGeo(tableB, \"within\", {\n  distance: 10,\n  distanceMethod: \"haversine\",\n  unit: \"km\",\n});\n```\n\n```ts\n// Merge data with specific geometry columns and an inner join type, storing results in a new table\nconst tableC = await tableA.joinGeo(tableB, \"intersect\", {\n  leftTableColumn: \"geometriesA\",\n  rightTableColumn: \"geometriesB\",\n  type: \"inner\",\n  outputTable: true,\n});\n```",
  "\n#### `intersection`\n\nComputes the intersection of two sets of geometries, creating new geometries\nwhere they overlap.\n\n##### Signature\n\n```typescript\nasync intersection(column1: string, column2: string, newColumn: string): Promise<void>;\n```\n\n##### Parameters\n\n- **`column1`**: - The name of the first column storing geometries.\n- **`column2`**: - The name of the second column storing geometries. Both\n  columns must have the same projection.\n- **`newColumn`**: - The name of the new column where the computed intersection\n  geometries will be stored.\n\n##### Returns\n\nA promise that resolves when the intersection geometries have been computed.\n\n##### Examples\n\n```ts\n// Compute the intersection of geometries in 'geomA' and 'geomB' columns, storing results in 'intersectGeom'\nawait table.intersection(\"geomA\", \"geomB\", \"intersectGeom\");\n```",
  "\n#### `removeIntersection`\n\nRemoves the intersection of two geometries from the first geometry, effectively\ncomputing the geometric difference.\n\n##### Signature\n\n```typescript\nasync removeIntersection(column1: string, column2: string, newColumn: string): Promise<void>;\n```\n\n##### Parameters\n\n- **`column1`**: - The name of the column storing the reference geometries.\n  These geometries will have the intersection removed.\n- **`column2`**: - The name of the column storing the geometries used to compute\n  the intersection. Both columns must have the same projection.\n- **`newColumn`**: - The name of the new column where the resulting geometries\n  (without the intersection) will be stored.\n\n##### Returns\n\nA promise that resolves when the geometries have been processed.\n\n##### Examples\n\n```ts\n// Remove the intersection of 'geomB' from 'geomA', storing the result in 'geomA_minus_geomB'\nawait table.removeIntersection(\"geomA\", \"geomB\", \"geomA_minus_geomB\");\n```",
  "\n#### `fillHoles`\n\nFills holes in polygon geometries.\n\n##### Signature\n\n```typescript\nasync fillHoles(column?: string): Promise<void>;\n```\n\n##### Parameters\n\n- **`column`**: - The name of the column storing the geometries. If omitted, the\n  method will automatically attempt to find a geometry column.\n\n##### Returns\n\nA promise that resolves when the holes have been filled.\n\n##### Examples\n\n```ts\n// Fill holes in geometries in the default geometry column\nawait table.fillHoles();\n```\n\n```ts\n// Fill holes in geometries in a specific column named 'polygonGeom'\nawait table.fillHoles(\"polygonGeom\");\n```",
  "\n#### `intersect`\n\nReturns `TRUE` if two geometries intersect (overlap in any way), and `FALSE`\notherwise.\n\n##### Signature\n\n```typescript\nasync intersect(column1: string, column2: string, newColumn: string): Promise<void>;\n```\n\n##### Parameters\n\n- **`column1`**: - The name of the first column storing geometries.\n- **`column2`**: - The name of the second column storing geometries. Both\n  columns must have the same projection.\n- **`newColumn`**: - The name of the new column where the boolean results\n  (`TRUE` for intersection, `FALSE` otherwise) will be stored.\n\n##### Returns\n\nA promise that resolves when the intersection check is complete.\n\n##### Examples\n\n```ts\n// Check if geometries in 'geomA' and 'geomB' intersect, storing results in 'doIntersect'\nawait table.intersect(\"geomA\", \"geomB\", \"doIntersect\");\n```",
  "\n#### `inside`\n\nReturns `TRUE` if all points of a geometry in `column1` lie inside a geometry in\n`column2`, and `FALSE` otherwise.\n\n##### Signature\n\n```typescript\nasync inside(column1: string, column2: string, newColumn: string): Promise<void>;\n```\n\n##### Parameters\n\n- **`column1`**: - The name of the column storing the geometries to be tested\n  for containment.\n- **`column2`**: - The name of the column storing the geometries to be tested as\n  containers. Both columns must have the same projection.\n- **`newColumn`**: - The name of the new column where the boolean results\n  (`TRUE` for inside, `FALSE` otherwise) will be stored.\n\n##### Returns\n\nA promise that resolves when the containment check is complete.\n\n##### Examples\n\n```ts\n// Check if geometries in 'pointGeom' are inside 'polygonGeom', storing results in 'isInsidePolygon'\nawait table.inside(\"pointGeom\", \"polygonGeom\", \"isInsidePolygon\");\n```",
  "\n#### `union`\n\nComputes the union of two geometries, creating a new geometry that represents\nthe merged area of both.\n\n##### Signature\n\n```typescript\nasync union(column1: string, column2: string, newColumn: string): Promise<void>;\n```\n\n##### Parameters\n\n- **`column1`**: - The name of the first column storing geometries.\n- **`column2`**: - The name of the second column storing geometries. Both\n  columns must have the same projection.\n- **`newColumn`**: - The name of the new column where the computed union\n  geometries will be stored.\n\n##### Returns\n\nA promise that resolves when the union geometries have been computed.\n\n##### Examples\n\n```ts\n// Compute the union of geometries in 'geomA' and 'geomB', storing results in 'unionGeom'\nawait table.union(\"geomA\", \"geomB\", \"unionGeom\");\n```",
  "\n#### `latLon`\n\nExtracts the latitude and longitude coordinates from point geometries. The input\ngeometry is assumed to be in the EPSG:4326 coordinate system (WGS84), with\n`[latitude, longitude]` axis order.\n\n##### Signature\n\n```typescript\nasync latLon(column: string, columnLat: string, columnLon: string): Promise<void>;\n```\n\n##### Parameters\n\n- **`column`**: - The name of the column storing the point geometries.\n- **`columnLat`**: - The name of the new column where the extracted latitude\n  values will be stored.\n- **`columnLon`**: - The name of the new column where the extracted longitude\n  values will be stored.\n\n##### Returns\n\nA promise that resolves when the latitude and longitude have been extracted.\n\n##### Examples\n\n```ts\n// Extract latitude and longitude from 'geom' column into new 'lat' and 'lon' columns\nawait table.latLon(\"geom\", \"lat\", \"lon\");\n```",
  "\n#### `simplify`\n\nSimplifies geometries while preserving their overall coverage. A higher\ntolerance results in more significant simplification.\n\n##### Signature\n\n```typescript\nasync simplify(tolerance: number, options?: { column?: string; simplifyBoundary?: boolean }): Promise<void>;\n```\n\n##### Parameters\n\n- **`tolerance`**: - A numeric value representing the simplification tolerance.\n  A higher value leads to greater simplification.\n- **`options`**: - An optional object with configuration options:\n- **`options.column`**: - The name of the column storing the geometries. If\n  omitted, the method will automatically attempt to find a geometry column.\n- **`options.simplifyBoundary`**: - If `true` (default), the boundary of the\n  geometries will also be simplified. If `false`, only the interior of the\n  geometries will be simplified, preserving the original boundary.\n\n##### Returns\n\nA promise that resolves when the geometries have been simplified.\n\n##### Examples\n\n```ts\n// Simplify geometries in the default column with a tolerance of 0.1\nawait table.simplify(0.1);\n```\n\n```ts\n// Simplify geometries in 'myGeom' column, preserving the boundary\nawait table.simplify(0.05, { column: \"myGeom\", simplifyBoundary: false });\n```",
  "\n#### `centroid`\n\nComputes the centroid of geometries. The values are returned in the SRS unit of\nthe input geometries.\n\n##### Signature\n\n```typescript\nasync centroid(newColumn: string, options?: { column?: string }): Promise<void>;\n```\n\n##### Parameters\n\n- **`newColumn`**: - The name of the new column where the computed centroid\n  geometries will be stored.\n- **`options`**: - An optional object with configuration options:\n- **`options.column`**: - The name of the column storing the geometries. If\n  omitted, the method will automatically attempt to find a geometry column.\n\n##### Returns\n\nA promise that resolves when the centroids have been computed.\n\n##### Examples\n\n```ts\n// Compute the centroid of geometries in the default column, storing results in 'centerPoint'\nawait table.centroid(\"centerPoint\");\n```\n\n```ts\n// Compute the centroid of geometries in a specific column named 'areaGeom'\nawait table.centroid(\"areaCentroid\", { column: \"areaGeom\" });\n```",
  "\n#### `distance`\n\nComputes the distance between geometries in two specified columns. By default,\nthe distance is calculated in the Spatial Reference System (SRS) unit of the\ninput geometries. You can optionally specify `\"spheroid\"` or `\"haversine\"`\nmethods to get results in meters or kilometers. If using `\"spheroid\"` or\n`\"haversine\"`, the input geometries must be in the EPSG:4326 coordinate system\n(WGS84), with `[latitude, longitude]` axis order.\n\n##### Signature\n\n```typescript\nasync distance(column1: string, column2: string, newColumn: string, options?: { unit?: \"m\" | \"km\"; method?: \"srs\" | \"haversine\" | \"spheroid\"; decimals?: number }): Promise<void>;\n```\n\n##### Parameters\n\n- **`column1`**: - The name of the first column storing geometries.\n- **`column2`**: - The name of the second column storing geometries.\n- **`newColumn`**: - The name of the new column where the computed distances\n  will be stored.\n- **`options`**: - An optional object with configuration options:\n- **`options.method`**: - The method to use for distance calculations: `\"srs\"`\n  (default, uses SRS unit), `\"haversine\"` (meters, requires EPSG:4326), or\n  `\"spheroid\"` (meters, requires EPSG:4326, most accurate but slowest).\n- **`options.unit`**: - If `method` is `\"spheroid\"` or `\"haversine\"`, you can\n  choose between `\"m\"` (meters, default) or `\"km\"` (kilometers).\n- **`options.decimals`**: - The number of decimal places to round the distance\n  values. Defaults to `undefined` (no rounding).\n\n##### Returns\n\nA promise that resolves when the distances have been computed.\n\n##### Examples\n\n```ts\n// Compute distance between 'geomA' and 'geomB' in SRS units, store in 'distance_srs'\nawait table.distance(\"geomA\", \"geomB\", \"distance_srs\");\n```\n\n```ts\n// Compute Haversine distance in meters between 'point1' and 'point2', store in 'distance_m'\n// Input geometries must be in EPSG:4326.\nawait table.distance(\"point1\", \"point2\", \"distance_m\", { method: \"haversine\" });\n```\n\n```ts\n// Compute Haversine distance in kilometers, rounded to 2 decimal places\n// Input geometries must be in EPSG:4326.\nawait table.distance(\"point1\", \"point2\", \"distance_km\", {\n  method: \"haversine\",\n  unit: \"km\",\n  decimals: 2,\n});\n```\n\n```ts\n// Compute Spheroid distance in kilometers\n// Input geometries must be in EPSG:4326.\nawait table.distance(\"area1\", \"area2\", \"distance_spheroid_km\", {\n  method: \"spheroid\",\n  unit: \"km\",\n});\n```",
  "\n#### `unnestGeo`\n\nUnnests geometries recursively, transforming multi-part geometries (e.g.,\nMultiPolygon) into individual single-part geometries (e.g., Polygon).\n\n##### Signature\n\n```typescript\nasync unnestGeo(column?: string): Promise<void>;\n```\n\n##### Parameters\n\n- **`column`**: - The name of the column storing the geometries to be unnested.\n  If omitted, the method will automatically attempt to find a geometry column.\n\n##### Returns\n\nA promise that resolves when the geometries have been unnested.\n\n##### Examples\n\n```ts\n// Unnest geometries in the default column\nawait table.unnestGeo();\n```\n\n```ts\n// Unnest geometries in a specific column named 'multiGeom'\nawait table.unnestGeo(\"multiGeom\");\n```",
  "\n#### `aggregateGeo`\n\nAggregates geometries in a specified column based on a chosen aggregation\nmethod.\n\n##### Signature\n\n```typescript\nasync aggregateGeo(method: \"union\" | \"intersection\", options?: { column?: string; categories?: string | string[]; outputTable?: string | boolean }): Promise<SimpleTable>;\n```\n\n##### Parameters\n\n- **`method`**: - The aggregation method to apply: `\"union\"` (combines all\n  geometries into a single multi-geometry) or `\"intersection\"` (computes the\n  intersection of all geometries).\n- **`options`**: - An optional object with configuration options:\n- **`options.column`**: - The name of the column storing the geometries to be\n  aggregated. If omitted, the method will automatically attempt to find a\n  geometry column.\n- **`options.categories`**: - The column name or an array of column names that\n  define categories for the aggregation. Aggregation will be performed\n  independently within each category.\n- **`options.outputTable`**: - If `true`, the results will be stored in a new\n  table with a generated name. If a string, it will be used as the name for the\n  new table. If `false` or omitted, the current table will be overwritten.\n  Defaults to `false`.\n\n##### Returns\n\nA promise that resolves to the SimpleTable instance containing the aggregated\ngeometries (either the modified current table or a new table).\n\n##### Examples\n\n```ts\n// Aggregate all geometries in the default column into a single union geometry\nawait table.aggregateGeo(\"union\");\n```\n\n```ts\n// Aggregate geometries by 'country' and compute their union\nawait table.aggregateGeo(\"union\", { categories: \"country\" });\n```\n\n```ts\n// Aggregate geometries in 'regions' column into their intersection, storing results in a new table\nconst intersectionTable = await table.aggregateGeo(\"intersection\", {\n  column: \"regions\",\n  outputTable: true,\n});\n```",
  "\n#### `linesToPolygons`\n\nTransforms closed linestring geometries into polygon geometries.\n\n##### Signature\n\n```typescript\nasync linesToPolygons(column?: string): Promise<void>;\n```\n\n##### Parameters\n\n- **`column`**: - The name of the column storing the linestring geometries. If\n  omitted, the method will automatically attempt to find a geometry column.\n\n##### Returns\n\nA promise that resolves when the transformation is complete.\n\n##### Examples\n\n```ts\n// Transform closed linestrings in the default geometry column into polygons\nawait table.linesToPolygons();\n```\n\n```ts\n// Transform closed linestrings in a specific column named 'routeLines' into polygons\nawait table.linesToPolygons(\"routeLines\");\n```",
  "\n#### `getBoundingBox`\n\nReturns the bounding box of geometries in `[minLat, minLon, maxLat, maxLon]`\norder. By default, the method will try to find the column with the geometries.\nThe input geometry is assumed to be in the EPSG:4326 coordinate system (WGS84),\nwith `[latitude, longitude]` axis order.\n\n##### Signature\n\n```typescript\nasync getBoundingBox(column?: string): Promise<any>;\n```\n\n##### Parameters\n\n- **`column`**: - The name of the column storing geometries. If omitted, the\n  method will automatically attempt to find a geometry column.\n\n##### Returns\n\nA promise that resolves to an array `[minLat, minLon, maxLat, maxLon]`\nrepresenting the bounding box.\n\n##### Examples\n\n```ts\n// Get the bounding box of geometries in the default column\nconst bbox = await table.getBoundingBox();\nconsole.log(bbox); // e.g., [45.0, -75.0, 46.0, -73.0]\n```\n\n```ts\n// Get the bounding box of geometries in a specific column named 'areaGeom'\nconst areaBbox = await table.getBoundingBox(\"areaGeom\");\nconsole.log(areaBbox);\n```",
  "\n#### `getGeoData`\n\nReturns the table's geospatial data as a GeoJSON object. If the table has\nmultiple geometry columns, you must specify which one to use. If the geometry\ncolumn's projection is WGS84 or EPSG:4326 (`[latitude, longitude]` axis order),\nthe coordinates will be flipped to follow the RFC7946 standard\n(`[longitude, latitude]` axis order) in the output GeoJSON.\n\n##### Signature\n\n```typescript\nasync getGeoData(column?: string, options?: { rewind?: boolean }): Promise<{ type: string; features: unknown[] }>;\n```\n\n##### Parameters\n\n- **`column`**: - The name of the column storing the geometries. If omitted, the\n  method will automatically attempt to find a geometry column.\n- **`options`**: - An optional object with configuration options:\n- **`options.rewind`**: - If `true`, rewinds the coordinates of polygons to\n  follow the spherical winding order (important for D3.js). Defaults to `false`.\n\n##### Returns\n\nA promise that resolves to a GeoJSON object representing the table's geospatial\ndata.\n\n##### Examples\n\n```ts\n// Get GeoJSON data from the default geometry column\nconst geojson = await table.getGeoData();\nconsole.log(geojson);\n```\n\n```ts\n// Get GeoJSON data from a specific geometry column named 'myGeometries'\nconst myGeomJson = await table.getGeoData(\"myGeometries\");\nconsole.log(myGeomJson);\n```\n\n```ts\n// Get GeoJSON data and rewind polygon coordinates for D3.js compatibility\nconst rewoundGeojson = await table.getGeoData(undefined, { rewind: true });\nconsole.log(rewoundGeojson);\n```",
  "\n#### `writeData`\n\nWrites the table's data to a file in various formats (CSV, JSON, Parquet,\nDuckDB, SQLite). If the specified path does not exist, it will be created.\n\n##### Signature\n\n```typescript\nasync writeData(file: string, options?: { compression?: boolean; dataAsArrays?: boolean; formatDates?: boolean }): Promise<void>;\n```\n\n##### Parameters\n\n- **`file`**: - The absolute path to the output file (e.g., `\"./output.csv\"`,\n  `\"./output.json\"`).\n- **`options`**: - An optional object with configuration options:\n- **`options.compression`**: - A boolean indicating whether to compress the\n  output file. If `true`, CSV and JSON files will be compressed with GZIP, while\n  Parquet files will use ZSTD. Defaults to `false`.\n- **`options.dataAsArrays`**: - For JSON files only. If `true`, JSON files are\n  written as a single object with arrays for each column (e.g.,\n  `{ \"col1\": [v1, v2], \"col2\": [v3, v4] }`) instead of an array of objects. This\n  can reduce file size for web projects. You can use the `arraysToData` function\n  from the\n  [journalism library](https://jsr.io/@nshiab/journalism/doc/~/arraysToData) to\n  convert it back.\n- **`options.formatDates`**: - For CSV and JSON files only. If `true`, date and\n  timestamp columns will be formatted as ISO 8601 strings (e.g.,\n  `\"2025-01-01T01:00:00.000Z\"`). Defaults to `false`.\n\n##### Returns\n\nA promise that resolves when the data has been written to the file.\n\n##### Examples\n\n```ts\n// Write data to a CSV file\nawait table.writeData(\"./output.csv\");\n```\n\n```ts\n// Write data to a JSON file with GZIP compression.\n// The output file will be named output.json.gz.\nawait table.writeData(\"./output.json\", { compression: true });\n```\n\n```ts\n// Write data to a Parquet file\nawait table.writeData(\"./output.parquet\");\n```\n\n```ts\n// Write data to a DuckDB database file\nawait table.writeData(\"./my_database.db\");\n```\n\n```ts\n// Write data to a SQLite database file\nawait table.writeData(\"./my_database.sqlite\");\n```\n\n```ts\n// Write JSON data with dates formatted as ISO strings\nawait table.writeData(\"./output_dates.json\", { formatDates: true });\n```",
  "\n#### `writeGeoData`\n\nWrites the table's geospatial data to a file in GeoJSON or GeoParquet format. If\nthe specified path does not exist, it will be created.\n\nFor GeoJSON files (`.geojson` or `.json`), if the projection is WGS84 or\nEPSG:4326 (`[latitude, longitude]` axis order), the coordinates will be flipped\nto follow the RFC7946 standard (`[longitude, latitude]` axis order) in the\noutput.\n\n##### Signature\n\n```typescript\nasync writeGeoData(file: string, options?: { precision?: number; compression?: boolean; rewind?: boolean; metadata?: unknown; formatDates?: boolean }): Promise<void>;\n```\n\n##### Parameters\n\n- **`file`**: - The absolute path to the output file (e.g.,\n  `\"./output.geojson\"`, `\"./output.geoparquet\"`).\n- **`options`**: - An optional object with configuration options:\n- **`options.precision`**: - For GeoJSON, the maximum number of figures after\n  the decimal separator to write in coordinates. Defaults to `undefined` (full\n  precision).\n- **`options.compression`**: - For GeoParquet, if `true`, the output will be\n  ZSTD compressed. Defaults to `false`.\n- **`options.rewind`**: - For GeoJSON, if `true`, rewinds the coordinates of\n  polygons to follow the right-hand rule (RFC 7946). Defaults to `false`.\n- **`options.metadata`**: - For GeoJSON, an object to be added as top-level\n  metadata to the GeoJSON output.\n- **`options.formatDates`**: - For GeoJSON, if `true`, formats date and\n  timestamp columns to ISO 8601 strings. Defaults to `false`.\n\n##### Returns\n\nA promise that resolves when the geospatial data has been written to the file.\n\n##### Examples\n\n```ts\n// Write geospatial data to a GeoJSON file\nawait table.writeGeoData(\"./output.geojson\");\n```\n\n```ts\n// Write geospatial data to a compressed GeoParquet file\nawait table.writeGeoData(\"./output.geoparquet\", { compression: true });\n```\n\n```ts\n// Write GeoJSON with specific precision and metadata\nawait table.writeGeoData(\"./output_high_precision.geojson\", {\n  precision: 6,\n  metadata: { source: \"SimpleDataAnalysis\" },\n});\n```",
  "\n#### `toSheet`\n\nClears a Google Sheet and populates it with the table's data. This method uses\nthe `overwriteSheetData` function from the\n[journalism library](https://jsr.io/@nshiab/journalism/doc/~/overwriteSheetData).\nRefer to its documentation for more details.\n\nBy default, this function looks for the API key in `GOOGLE_PRIVATE_KEY` and the\nservice account email in `GOOGLE_SERVICE_ACCOUNT_EMAIL` environment variables.\nIf you don't have credentials, refer to the\n[Google Spreadsheet authentication guide](https://theoephraim.github.io/node-google-spreadsheet/#/guides/authentication).\n\n##### Signature\n\n```typescript\nasync toSheet(sheetUrl: string, options?: { prepend?: string; lastUpdate?: boolean; timeZone?: \"Canada/Atlantic\" | \"Canada/Central\" | \"Canada/Eastern\" | \"Canada/Mountain\" | \"Canada/Newfoundland\" | \"Canada/Pacific\" | \"Canada/Saskatchewan\" | \"Canada/Yukon\"; raw?: boolean; apiEmail?: string; apiKey?: string }): Promise<void>;\n```\n\n##### Parameters\n\n- **`sheetUrl`**: - The URL pointing to a specific Google Sheet (e.g.,\n  `\"https://docs.google.com/spreadsheets/d/.../edit#gid=0\"`).\n- **`options`**: - An optional object with configuration options:\n- **`options.prepend`**: - Text to be added before the data in the sheet.\n- **`options.lastUpdate`**: - If `true`, adds a row before the data with the\n  date of the update.\n- **`options.timeZone`**: - If `lastUpdate` is `true`, this option allows\n  formatting the date to a specific time zone.\n- **`options.raw`**: - If `true`, Google Sheets will not attempt to guess the\n  data type and will not format or parse the values.\n- **`options.apiEmail`**: - If your API email is stored under a different\n  environment variable name, use this option to specify it.\n- **`options.apiKey`**: - If your API key is stored under a different\n  environment variable name, use this option to specify it.\n\n##### Returns\n\nA promise that resolves when the data has been written to the Google Sheet.\n\n##### Examples\n\n```ts\n// Write table data to a Google Sheet\nawait table.toSheet(\"https://docs.google.com/spreadsheets/d/.../edit#gid=0\");\n```\n\n```ts\n// Write data to a Google Sheet, prepending a message and including the last update timestamp\nawait table.toSheet(\"https://docs.google.com/spreadsheets/d/.../edit#gid=0\", {\n  prepend: \"Report generated on:\",\n  lastUpdate: true,\n  timeZone: \"Canada/Eastern\",\n});\n```",
  "\n#### `cache`\n\nCaches the results of computations in `./.sda-cache`. You should add\n`./.sda-cache` to your `.gitignore` file.\n\n##### Signature\n\n```typescript\nasync cache(run: () => any, options?: { ttl?: number }): Promise<void>;\n```\n\n##### Parameters\n\n- **`run`**: - A function wrapping the computations to be cached. This function\n  will be executed on the first run or if the cached data is invalid/expired.\n- **`options`**: - An optional object with configuration options:\n- **`options.ttl`**: - Time to live (in seconds). If the data in the cache is\n  older than this duration, the `run` function will be executed again to refresh\n  the cache. By default, there is no TTL, meaning the cache is only invalidated\n  if the `run` function's content changes.\n\n##### Returns\n\nA promise that resolves when the computations are complete or the data is loaded\nfrom cache.\n\n##### Examples\n\n```ts\n// Basic usage: computations are cached and re-run only if the function content changes\nconst sdb = new SimpleDB();\nconst table = sdb.newTable();\n\nawait table.cache(async () => {\n  await table.loadData(\"items.csv\");\n  await table.summarize({\n    values: \"price\",\n    categories: \"department\",\n    summaries: [\"min\", \"max\", \"mean\"],\n  });\n});\n\n// It's important to call done() on the SimpleDB instance to clean up the cache.\n// This prevents the cache from growing indefinitely.\nawait sdb.done();\n```\n\n```ts\n// Cache with a Time-To-Live (TTL) of 60 seconds\n// The computations will be re-run if the cached data is older than 1 minute or if the function content changes.\nconst sdb = new SimpleDB();\nconst table = sdb.newTable();\n\nawait table.cache(async () => {\n  await table.loadData(\"items.csv\");\n  await table.summarize({\n    values: \"price\",\n    categories: \"department\",\n    summaries: [\"min\", \"max\", \"mean\"],\n  });\n}, { ttl: 60 });\n\nawait sdb.done();\n```\n\n```ts\n// Enable verbose logging for cache operations via SimpleDB instance\nconst sdb = new SimpleDB({ cacheVerbose: true });\nconst table = sdb.newTable();\n\nawait table.cache(async () => {\n  await table.loadData(\"items.csv\");\n  await table.summarize({\n    values: \"price\",\n    categories: \"department\",\n    summaries: [\"min\", \"max\", \"mean\"],\n  });\n});\n\nawait sdb.done();\n```",
  "\n#### `writeChart`\n\nCreates an [Observable Plot](https://github.com/observablehq/plot) chart as an\nimage file (.png, .jpeg, or .svg) from the table data. To create maps, use the\n`writeMap` method.\n\n##### Signature\n\n```typescript\nasync writeChart(chart: (data: unknown[]) => any, path: string, options?: { style?: string; dark?: boolean }): Promise<void>;\n```\n\n##### Parameters\n\n- **`chart`**: - A function that takes data (as an array of objects) and returns\n  an Observable Plot chart (an `SVGSVGElement` or `HTMLElement`).\n- **`path`**: - The absolute path where the chart image will be saved (e.g.,\n  `\"./output/chart.png\"`).\n- **`options`**: - Optional object containing additional settings:\n- **`options.style`**: - A CSS string to customize the chart's appearance. This\n  is applied to a `<div>` element wrapping the Plot chart (which has the id\n  `chart`). Use this if the Plot `style` option is insufficient.\n- **`options.dark`**: - If `true`, switches the chart to dark mode. Defaults to\n  `false`.\n\n##### Returns\n\nA promise that resolves when the chart image has been saved.\n\n##### Examples\n\n```ts\nimport { dot, plot } from \"@observablehq/plot\";\n\nconst sdb = new SimpleDB();\nconst table = sdb.newTable();\nconst data = [{ year: 2024, value: 10 }, { year: 2025, value: 15 }];\nawait table.loadArray(data);\n\nconst chartFunction = (plotData: unknown[]) =>\n  plot({\n    marks: [\n      dot(plotData, { x: \"year\", y: \"value\" }),\n    ],\n  });\n\nconst outputPath = \"output/chart.png\";\n\nawait table.writeChart(chartFunction, outputPath);\n```",
  "\n#### `writeMap`\n\nCreates an [Observable Plot](https://github.com/observablehq/plot) map as an\nimage file (.png, .jpeg, or .svg) from the table's geospatial data. To create\ncharts from non-geospatial data, use the `writeChart` method.\n\n##### Signature\n\n```typescript\nasync writeMap(map: (geoData: { features: { properties: Record<string, unknown> }[] }) => any, path: string, options?: { column?: string; rewind?: boolean; style?: string; dark?: boolean }): Promise<void>;\n```\n\n##### Parameters\n\n- **`map`**: - A function that takes geospatial data (in GeoJSON format) and\n  returns an Observable Plot map (an `SVGSVGElement` or `HTMLElement`).\n- **`path`**: - The absolute path where the map image will be saved (e.g.,\n  `\"./output/map.png\"`).\n- **`options`**: - An optional object with configuration options:\n- **`options.column`**: - The name of the column storing geometries. If there is\n  only one geometry column, it will be used by default.\n- **`options.rewind`**: - If `true`, rewinds the coordinates of polygons to\n  follow the spherical winding order (important for D3.js). Defaults to `true`.\n- **`options.style`**: - A CSS string to customize the map's appearance. This is\n  applied to a `<div>` element wrapping the Plot map (which has the ID `chart`).\n  Use this if the Plot `style` option is insufficient.\n- **`options.dark`**: - If `true`, switches the map to dark mode. Defaults to\n  `false`.\n\n##### Returns\n\nA promise that resolves when the map image has been saved.\n\n##### Examples\n\n```ts\nimport { geo, plot } from \"@observablehq/plot\";\n\nconst sdb = new SimpleDB();\nconst table = sdb.newTable();\nawait table.loadGeoData(\"./CanadianProvincesAndTerritories.geojson\");\n\nconst mapFunction = (geoJsonData: { features: unknown[] }) =>\n  plot({\n    projection: {\n      type: \"conic-conformal\",\n      rotate: [100, -60],\n      domain: geoJsonData,\n    },\n    marks: [\n      geo(geoJsonData, { stroke: \"black\", fill: \"lightblue\" }),\n    ],\n  });\n\nconst outputPath = \"./output/map.png\";\n\nawait table.writeMap(mapFunction, outputPath);\n```",
  "\n#### `logTable`\n\nLogs a specified number of rows from the table to the console. By default, the\nfirst 10 rows are logged. You can optionally log the column types and filter the\ndata based on conditions. You can also use JavaScript syntax for conditions\n(e.g., `&&`, `||`, `===`, `!==`).\n\n##### Signature\n\n```typescript\nasync logTable(options?: \"all\" | number | { nbRowsToLog?: number | \"all\"; types?: boolean; conditions?: string }): Promise<void>;\n```\n\n##### Parameters\n\n- **`options`**: - Either the number of rows to log (a specific number or\n  `\"all\"`) or an object with configuration options:\n- **`options.nbRowsToLog`**: - The number of rows to log. Defaults to 10 or the\n  value set in the SimpleDB instance. Use `\"all\"` to log all rows.\n- **`options.types`**: - If `true`, logs the column types along with the data.\n  Defaults to `false`.\n- **`options.conditions`**: - A SQL `WHERE` clause condition to filter the data\n  before logging. Defaults to no condition.\n\n##### Returns\n\nA promise that resolves when the table data has been logged.\n\n##### Examples\n\n```ts\n// Log the first 10 rows (default behavior)\nawait table.logTable();\n```\n\n```ts\n// Log the first 50 rows\nawait table.logTable(50);\n```\n\n```ts\n// Log all rows\nawait table.logTable(\"all\");\n```\n\n```ts\n// Log the first 20 rows and include column types\nawait table.logTable({ nbRowsToLog: 20, types: true });\n```\n\n```ts\n// Log rows where 'status' is 'active' (using JS syntax for conditions)\nawait table.logTable({ conditions: `status === 'active'` });\n```",
  "\n#### `logLineChart`\n\nGenerates and logs a line chart to the console. The data should be sorted by the\nx-axis values for accurate representation.\n\n**Data Type Requirements:**\n\n- **X-axis values**: Must be `number` or `Date` objects.\n- **Y-axis values**: Must be `number` values.\n- All values must be non-null and defined.\n\n##### Signature\n\n```typescript\nasync logLineChart(x: string, y: string, options?: { formatX?: (d: unknown) => any; formatY?: (d: unknown) => any; smallMultiples?: string; fixedScales?: boolean; smallMultiplesPerRow?: number; width?: number; height?: number }): Promise<void>;\n```\n\n##### Parameters\n\n- **`x`**: - The name of the column to be used for the x-axis. Values must be\n  numbers or Date objects.\n- **`y`**: - The name of the column to be used for the y-axis. Values must be\n  numbers.\n- **`options`**: - An optional object with configuration options:\n- **`options.formatX`**: - A function to format the x-axis values for display.\n  It receives the raw x-value as input and should return a string. If the first\n  data point's x value is a Date, it defaults to formatting the date as\n  \"YYYY-MM-DD\".\n- **`options.formatY`**: - A function to format the y-axis values for display.\n  It receives the raw y-value as input and should return a string.\n- **`options.smallMultiples`**: - The name of a column to create small multiples\n  (also known as facets or trellis charts). Each unique value in this column\n  will generate a separate chart.\n- **`options.fixedScales`**: - If `true`, all small multiples will share the\n  same y-axis scale. Defaults to `false`.\n- **`options.smallMultiplesPerRow`**: - The number of small multiples to display\n  per row.\n- **`options.width`**: - The width of the chart in characters.\n- **`options.height`**: - The height of the chart in characters.\n\n##### Returns\n\nA promise that resolves when the chart has been logged to the console.\n\n##### Examples\n\n// Basic line chart\n\n```typescript\nconst data = [\n  { date: new Date(\"2023-01-01\"), value: 10 },\n  { date: new Date(\"2023-02-01\"), value: 20 },\n  { date: new Date(\"2023-03-01\"), value: 30 },\n  { date: new Date(\"2023-04-01\"), value: 40 },\n];\nawait table.loadArray(data);\nawait table.convert({ date: \"string\" }, { datetimeFormat: \"%x\" });\nawait table.logLineChart(\"date\", \"value\");\n```\n\n// Line chart with small multiples\n\n```typescript\nconst data = [\n  { date: new Date(\"2023-01-01\"), value: 10, category: \"A\" },\n  { date: new Date(\"2023-02-01\"), value: 20, category: \"A\" },\n  { date: new Date(\"2023-03-01\"), value: 30, category: \"A\" },\n  { date: new Date(\"2023-04-01\"), value: 40, category: \"A\" },\n  { date: new Date(\"2023-01-01\"), value: 15, category: \"B\" },\n  { date: new Date(\"2023-02-01\"), value: 25, category: \"B\" },\n  { date: new Date(\"2023-03-01\"), value: 35, category: \"B\" },\n  { date: new Date(\"2023-04-01\"), value: 45, category: \"B\" },\n];\nawait table.loadArray(data);\nawait table.convert({ date: \"string\" }, { datetimeFormat: \"%x\" });\nawait table.logLineChart(\"date\", \"value\", {\n  smallMultiples: \"category\",\n});\n```",
  "\n#### `logDotChart`\n\nGenerates and logs a dot chart to the console. The data should be sorted by the\nx-axis values for accurate representation.\n\n**Data Type Requirements:**\n\n- **X-axis values**: Must be `number` or `Date` objects.\n- **Y-axis values**: Must be `number` values.\n- All values must be non-null and defined.\n\n##### Signature\n\n```typescript\nasync logDotChart(x: string, y: string, options?: { formatX?: (d: unknown) => any; formatY?: (d: unknown) => any; smallMultiples?: string; fixedScales?: boolean; smallMultiplesPerRow?: number; width?: number; height?: number }): Promise<void>;\n```\n\n##### Parameters\n\n- **`x`**: - The name of the column to be used for the x-axis. Values must be\n  numbers or Date objects.\n- **`y`**: - The name of the column to be used for the y-axis. Values must be\n  numbers.\n- **`options`**: - An optional object with configuration options:\n- **`options.formatX`**: - A function to format the x-axis values for display.\n  It receives the raw x-value as input and should return a string. If the first\n  data point's x value is a Date, it defaults to formatting the date as\n  \"YYYY-MM-DD\".\n- **`options.formatY`**: - A function to format the y-axis values for display.\n  It receives the raw y-value as input and should return a string.\n- **`options.smallMultiples`**: - The name of a column to create small multiples\n  (also known as facets). Each unique value in this column will generate a\n  separate chart.\n- **`options.fixedScales`**: - If `true`, all small multiples will share the\n  same y-axis scale. Defaults to `false`.\n- **`options.smallMultiplesPerRow`**: - The number of small multiples to display\n  per row.\n- **`options.width`**: - The width of the chart in characters.\n- **`options.height`**: - The height of the chart in characters.\n\n##### Returns\n\nA promise that resolves when the chart has been logged to the console.\n\n##### Examples\n\n// Basic dot chart\n\n```typescript\nconst data = [\n  { date: new Date(\"2023-01-01\"), value: 10 },\n  { date: new Date(\"2023-02-01\"), value: 20 },\n  { date: new Date(\"2023-03-01\"), value: 30 },\n  { date: new Date(\"2023-04-01\"), value: 40 },\n];\nawait table.loadArray(data);\nawait table.convert({ date: \"string\" }, { datetimeFormat: \"%x\" });\nawait table.logDotChart(\"date\", \"value\");\n```\n\n// Dot chart with small multiples\n\n```typescript\nconst data = [\n  { date: new Date(\"2023-01-01\"), value: 10, category: \"A\" },\n  { date: new Date(\"2023-02-01\"), value: 20, category: \"A\" },\n  { date: new Date(\"2023-03-01\"), value: 30, category: \"A\" },\n  { date: new Date(\"2023-04-01\"), value: 40, category: \"A\" },\n  { date: new Date(\"2023-01-01\"), value: 15, category: \"B\" },\n  { date: new Date(\"2023-02-01\"), value: 25, category: \"B\" },\n  { date: new Date(\"2023-03-01\"), value: 35, category: \"B\" },\n  { date: new Date(\"2023-04-01\"), value: 45, category: \"B\" },\n];\nawait table.loadArray(data);\nawait table.convert({ date: \"string\" }, { datetimeFormat: \"%x\" });\nawait table.logDotChart(\"date\", \"value\", {\n  smallMultiples: \"category\",\n});\n```",
  "\n#### `logBarChart`\n\nGenerates and logs a bar chart to the console.\n\n##### Signature\n\n```typescript\nasync logBarChart(labels: string, values: string, options?: { formatLabels?: (d: unknown) => any; formatValues?: (d: unknown) => any; width?: number }): Promise<void>;\n```\n\n##### Parameters\n\n- **`labels`**: - The name of the column to be used for the labels (categories).\n- **`values`**: - The name of the column to be used for the values.\n- **`options`**: - An optional object with configuration options:\n- **`options.formatLabels`**: - A function to format the labels. Defaults to\n  converting the label to a string.\n- **`options.formatValues`**: - A function to format the values. Defaults to\n  converting the value to a string.\n- **`options.width`**: - The width of the chart in characters. Defaults to 40.\n\n##### Returns\n\nA promise that resolves when the chart has been logged to the console.\n\n##### Examples\n\n```typescript\nconst data = [\n  { category: \"A\", value: 10 },\n  { category: \"B\", value: 20 },\n];\nawait table.loadArray(data);\nawait table.logBarChart(\"category\", \"value\");\n```",
  "\n#### `logHistogram`\n\nGenerates and logs a histogram of a numeric column to the console.\n\n##### Signature\n\n```typescript\nasync logHistogram(values: string, options?: { bins?: number; formatLabels?: (min: number, max: number) => any; compact?: boolean; width?: number }): Promise<void>;\n```\n\n##### Parameters\n\n- **`values`**: - The name of the numeric column for which to generate the\n  histogram.\n- **`options`**: - An optional object with configuration options:\n- **`options.bins`**: - The number of bins (intervals) to use for the histogram.\n  Defaults to 10.\n- **`options.formatLabels`**: - A function to format the labels for the\n  histogram bins. It receives the lower and upper bounds of each bin as\n  arguments.\n- **`options.compact`**: - If `true`, the histogram will be displayed in a more\n  compact format. Defaults to `false`.\n- **`options.width`**: - The maximum width of the histogram bars in characters.\n\n##### Returns\n\nA promise that resolves when the histogram has been logged to the console.\n\n##### Examples\n\n// Basic histogram of the 'temperature' column\n\n```typescript\nawait table.logHistogram(\"temperature\");\n```\n\n// Histogram with 20 bins and custom label formatting\n\n```typescript\nawait table.logHistogram(\"age\", {\n  bins: 20,\n  formatLabels: (min, max) => `${min}-${max} years`,\n});\n```",
  "\n#### `logDescription`\n\nLogs descriptive information about the columns in the table to the console. This\nincludes details such as data types, number of null values, and number of\ndistinct values for each column. It internally calls the `getDescription` method\nto retrieve the descriptive statistics.\n\n##### Signature\n\n```typescript\nasync logDescription(): Promise<void>;\n```\n\n##### Returns\n\nA promise that resolves when the column description has been logged to the\nconsole.\n\n##### Examples\n\n```ts\n// Log descriptive information for all columns in the table\nawait table.logDescription();\n```",
  "\n#### `logProjections`\n\nLogs the projections of the geospatial data (if any) to the console.\n\n##### Signature\n\n```typescript\nasync logProjections(): Promise<SimpleTable>;\n```\n\n##### Returns\n\nA promise that resolves to the SimpleTable instance after logging the\nprojections.\n\n##### Examples\n\n```ts\n// Log the geospatial projections of the table\nawait table.logProjections();\n```",
  "\n#### `logTypes`\n\nLogs the types of all columns in the table to the console.\n\n##### Signature\n\n```typescript\nasync logTypes(): Promise<SimpleTable>;\n```\n\n##### Returns\n\nA promise that resolves to the SimpleTable instance after logging the column\ntypes.\n\n##### Examples\n\n```ts\n// Log the data types of all columns in the table\nawait table.logTypes();\n```",
  "\n#### `logUniques`\n\nLogs unique values for a specified column to the console. By default, a maximum\nof 100 values are logged (depending on your runtime). You can optionally\nstringify the values to see them all.\n\n##### Signature\n\n```typescript\nasync logUniques(column: string, options?: { stringify?: boolean }): Promise<SimpleTable>;\n```\n\n##### Parameters\n\n- **`column`**: - The name of the column from which to retrieve and log unique\n  values.\n- **`options`**: - An optional object with configuration options:\n- **`options.stringify`**: - If `true`, converts the unique values to a JSON\n  string before logging. Defaults to `false`.\n\n##### Returns\n\nA promise that resolves to the SimpleTable instance after logging the unique\nvalues.\n\n##### Examples\n\n```ts\n// Logs unique values for the column \"name\"\nawait table.logUniques(\"name\");\n```\n\n```ts\n// Logs unique values for the column \"name\" and stringifies them\nawait table.logUniques(\"name\", { stringify: true });\n```",
  "\n#### `logColumns`\n\nLogs the columns in the table to the console. You can optionally include their\ndata types.\n\n##### Signature\n\n```typescript\nasync logColumns(options?: { types?: boolean }): Promise<SimpleTable>;\n```\n\n##### Parameters\n\n- **`options`**: - An optional object with configuration options:\n- **`options.types`**: - If `true`, logs the column names along with their data\n  types. Defaults to `false`.\n\n##### Returns\n\nA promise that resolves to the SimpleTable instance after logging the columns.\n\n##### Examples\n\n```ts\n// Log only the column names\nawait table.logColumns();\n```\n\n```ts\n// Log column names along with their types\nawait table.logColumns({ types: true });\n```",
  "\n#### `logNbRows`\n\nLogs the total number of rows in the table to the console.\n\n##### Signature\n\n```typescript\nasync logNbRows(): Promise<SimpleTable>;\n```\n\n##### Returns\n\nA promise that resolves to the SimpleTable instance after logging the row count.\n\n##### Examples\n\n```ts\n// Log the total number of rows in the table\nawait table.logNbRows();\n```",
  "\n#### `logBottom`\n\nLogs the bottom `n` rows of the table to the console. By default, the last row\nwill be returned first. To preserve the original order, use the `originalOrder`\noption.\n\n##### Signature\n\n```typescript\nasync logBottom(count: number, options?: { originalOrder?: boolean }): Promise<void>;\n```\n\n##### Parameters\n\n- **`count`**: - The number of rows to log from the bottom of the table.\n\n##### Returns\n\nA promise that resolves when the rows have been logged to the console.\n\n##### Examples\n\n```ts\n// Log the last 10 rows (last row first)\nawait table.logBottom(10);\n```\n\n```ts\n// Log the last 5 rows in their original order\nawait table.logBottom(5, { originalOrder: true });\n```",
  "\n#### `logExtent`\n\nLogs the extent (minimum and maximum values) of a numeric column to the console.\n\n##### Signature\n\n```typescript\nasync logExtent(column: string): Promise<void>;\n```\n\n##### Parameters\n\n- **`column`**: - The name of the numeric column for which to log the extent.\n\n##### Returns\n\nA promise that resolves when the column extent has been logged to the console.\n\n##### Examples\n\n```ts\n// Log the extent of the 'price' column\nawait table.logExtent(\"price\");\n```\n\n### Examples\n\n```ts\n// Create a SimpleDB instance (in-memory by default)\nconst sdb = new SimpleDB();\n\n// Create a new table named \"employees\" within the database\nconst employees = sdb.newTable(\"employees\");\n\n// Load data from a CSV file into the \"employees\" table\nawait employees.loadData(\"./employees.csv\");\n\n// Log the first few rows of the \"employees\" table to the console\nawait employees.logTable();\n\n// Close the database connection and free up resources\nawait sdb.done();\n```\n\n```ts\n// Handling geospatial data\n// Create a SimpleDB instance\nconst sdb = new SimpleDB();\n\n// Create a new table for geospatial data\nconst boundaries = sdb.newTable(\"boundaries\");\n\n// Load geospatial data from a GeoJSON file\nawait boundaries.loadGeoData(\"./boundaries.geojson\");\n\n// Close the database connection\nawait sdb.done();\n```"
]